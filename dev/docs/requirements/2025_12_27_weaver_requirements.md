# Weaver（仮）要件まとめ（Rust 前提 / v1→拡張）

## 0. 目的

### 主目的

* ユーザーが渡した「やるべきことの集合」を実行し、**結果のまとまり**（成功/失敗/未完了 + 理由 + 試行ログ）を返す。
* 実行中に **進捗・ボトルネック** を観測でき、**途中停止（キャンセル）** と **途中経過取得（status）** ができる。
* 失敗しても自動で **再試行**・**代替/追加の手**・**分解** を行い、前に進める。
* 「このままでは進まない」を検知して **止められる**（stuck / budget）。

### 第二目的（学習・設計）

* Rust の **非同期処理**（tokio 等）と、**所有権/ライフタイム**を実装を通じて理解する。
* 実装で **関数型っぽい性質**（副作用の分離、合成、代数的データ型、Result/Option中心、純粋関数化）を活かす。

---

## 1. スコープ

### v1（必須で満たす範囲）

* 1つのプロセス内で動く（分散はしない）
* タスク集合を受け取って実行し、結果を返せる
* 自動リトライ（最大回数・遅延/バックオフ）
* “進めない” を検知して停止（stuck / 予算）
* 状態・試行・判断理由が残る（説明可能性）
* status / cancel ができる

### v1 では必須にしない（設計余地）

* 実行機構：キュー/ワーカー/スレッド/DelayQueue などは差し替え可能な前提
* 永続化（DB）や複数プロセス
* 高度な並行度制御（キー直列化、優先度の精緻化、DAG最適化）
* リース/可視タイムアウト/ワーカー落ち復旧（v2以降）

---

## 2. 用語（ドメイン語彙）

* **Job**: 入力として受け取った「やることセット」全体の単位（実行・キャンセル・結果取得の単位）
* **Task**: 追跡対象の最小単位（入力由来も、実行中に増えたものも含む）
* **Attempt**: Task の1回の試行（何をやったか、何が起きたか）
* **Outcome**: Attempt の結果（共通形式）
* **Decision**: 次の手の決定記録（リトライ/分解/依存追加/停止など）
* **Artifact**: 生成物/参照（ファイル、URL、stdout など）
* **Dependency**: タスク間の依存（実行中に追加されてもよい）
* **Budget**: 試行回数、時間、期限、コスト等の制約

---

## 3. 入力要件（Job の受付）

### Job 入力（JobSpec）

* Job は **複数の TaskSpec** を含む
* Job には予算（Budget）を持てる（例：全体期限、最大試行回数、最大コスト）

### Task 入力（TaskSpec）

各 Task は以下を持てる（任意/必須は実装判断だが、表現できることが要件）

* **人間向け説明**: `title` / `intent`
* **ゴール**: `goal`（完了条件に相当する情報）
* **制約**: `constraints`（最大試行回数、タイムアウト、優先度など）
* **実行の手がかり**（実装に委ねる）

  * 例: `task_type + payload`（ハンドラ登録制）
  * 例: `action`（command/http/function/llm などの統一表現）

---

## 4. 出力要件（結果のまとまり）

### Job 結果（JobResult）

最低限、以下を含むこと：

* `completed` / `failed` / `incomplete` の分類
* それぞれの **理由**（なぜ成功/失敗/未完了か）
* **実行ログ/根拠**（何を試したか：Attempt 履歴）
* 追加で、判断の根拠（Decision 履歴）を辿れること

### Outcome（共通結果形式）の要件

* `kind` は最低限以下を区別する

  * `SUCCESS`: 前進した（完了、または中間成果でもよい）
  * `FAILURE`: 条件次第で回復し得る失敗（再試行/代替/分解の余地がある）
  * `BLOCKED`: このままでは進めない（情報不足/前提不足/介入が必要）
* 成功時：成果（Artifact/参照）を持てる
* 失敗時：理由、再試行のヒント、別案のヒントを持てる
* BLOCKED 時：不足前提、必要な介入の種類を表せる

---

## 5. 実行中に必要なこと（運用要件）

### 進捗の観測（Status）

* 現在の件数が見える

  * 例: succeeded / failed / blocked / running / runnable / pending
* **ボトルネックが見える**

  * 例: 依存待ち、バックオフ待ち、介入待ち、予算切れ寸前 など
* 任意: 直近の Attempt/Decision の要約（「いま何をしているか」が追える）

### キャンセル（Cancel）

* Job をキャンセルできる
* キャンセル後の期待挙動（v1指針）

  * 新規スケジュールは停止
  * 実行中の Attempt は「止められれば止める」/「止められなければ完了を待つ」いずれでもよいが、最終状態が矛盾しないこと
  * 結果には “キャンセルされた” 理由が残ること

---

## 6. “勝手に前に進む” 振る舞い（コア価値）

### 6.1 リトライ（自動回復）

* 失敗したら再試行できる（最大回数は Task/Job で設定可能）
* 再試行は遅延（バックオフ）を取れる
* 同じことを無限に繰り返さない

  * 回数上限
  * 期限（deadline）
  * 総時間/総コスト上限 など

> 実装方針としては「その場で sleep し続ける」より、**再投入（再スケジュール）**のほうが、監視・キャンセル・並列化に強い。

### 6.2 分解（大きすぎて実行できないとき）

* Task が抽象的/巨大でそのまま実行できない場合、実行可能単位へ分解して試せる
* 分解で増えた Task も **同一の追跡枠組み**（状態・Attempt・Outcome・Decision）に入る
* 分解後の親 Task は以下を表現できる

  * 子が揃ったら親を再試行する
  * 子の達成で親を達成扱いにする（合成ゴール）

### 6.3 実行結果から “次の手” を決める

* Attempt の観測（stdout/stderr、エラー、レスポンス等）を材料に、次の手を変えられる
* 例

  * コマンド結果に応じて次コマンドを変える
  * LLM/Agent の提案を採用する（採用/不採用の Decision が残る）
  * 足りない前提（設定/ファイル/依存）を補う Task を追加する

---

## 7. 依存・順序の要件

* Task 間に「終わらないと進めない」関係を表せる
* 依存は入力時点で固定でなくてよい

  * 実行中に発見・追加されてもよい
* 依存が解けたら自動的に進める（可能なら）
* 依存には以下のようなケースを含められる

  * 前提 Task が成功するまで待つ
  * 分解で出た要素が揃ったら親に戻る（合成ゴール）

---

## 8. “stuck / 止め時” の要件

Job が継続できない状態を検知し、適切に終了できること。

* **RUNNABLE が存在しない**のに未完了が残る

  * BLOCKED ばかり
  * 依存サイクル
  * バックオフ待ちのみ（この場合は「待つ」扱いでもよいが、期限で止まる）
* **Budget 到達**

  * max_attempts 超過
  * deadline 超過
  * max_total_time / max_total_cost 超過
* 終了時は必ず「なぜ止めたか」が結果に残ること

---

## 9. 観測・説明責任（監査可能性）

あとから説明できるよう、以下を保存する（保存先は v1 はインメモリでも可、将来差し替え想定）。

* Attempt 履歴

  * 何をやったか（Action）
  * 何が起きたか（Observation）
  * Outcome（SUCCESS/FAILURE/BLOCKED + reason）
* Decision 履歴

  * どの観測を根拠に
  * どの方針（policy）で
  * 何を変更したか（再試行スケジュール/分解/依存追加/停止）
* Budget による打ち切りの記録（どの制約が効いたか）

---

## 10. API / インターフェース要件（ライブラリ or サービス）

### 必須ユースケース（最小）

* `submit_job(JobSpec) -> JobId`
* `get_status(JobId) -> JobStatus`
* `cancel_job(JobId) -> CancelAck`
* `get_result(JobId) -> JobResult`（完了していなければ途中経過でもよい/エラーでもよい）

### できたら

* `get_task(TaskId) -> TaskDetail`（Attempt/Decision 含む）
* `list_tasks(JobId, filter) -> Vec<TaskSummary>`
* `subscribe_events(JobId) -> Stream<Event>`（SSE/WebSocket/チャネルなど）

---

## 11. Rust 前提の非機能要件（実装ガードレール）

### 非同期（tokio 等）

* ロック保持中に `.await` しない（デッドロック/遅延増大を避ける）
* 実行（Runner）はロック外で行う（TaskEnvelope 等は clone/Arc 化）
* ブロッキング処理は `spawn_blocking` などで隔離可能にする
* キャンセルされ得る前提で状態遷移が壊れないようにする

### 所有権/ライフタイムを破綻させない設計（要求として）

* 長寿命データ（TaskRecord 等）と短寿命データ（Attempt 実行時の一時値）を分離する
* 参照をキュー内部に保持しない（必要なら `TaskId` のみ保持し、実体は別マップに置く等）
* 共有は `Arc`、可変共有は `Mutex/RwLock` or message passing を選べるようにする

### 関数型っぽさを活かす（要求として）

* “判断（Decider）” は **できるだけ純粋関数**に寄せる

  * 入力: 現在状態 + 観測/結果
  * 出力: 次の操作（再試行/分解/依存追加/停止）＝副作用の指示
* “実行（Runner）” に副作用を閉じ込める
* 状態・結果は `enum`（代数的データ型）で表現し、`match` による網羅性で事故を減らす
* 可能な限り `Result/Option` とイテレータ合成（map/and_then/fold）で分岐を整理する

---

## 12. v1 の成功条件（チェックリスト）

* [ ] タスク集合を受け取り、実行して、結果のまとまりを返せる
* [ ] 失敗しても自動で再試行できる（最大回数 + 遅延）
* [ ] “進まない” を検知して止められる（stuck / budget）
* [ ] 結果に「何を試したか／なぜ止めたか」が残る
* [ ] status / cancel が機能する

---

## 13. 将来拡張（方向性だけ）

* 永続化ストア（SQLite/Postgres/Redis等）への差し替え
* 複数プロセス/分散ワーカー、lease/再配布
* 依存解決の高度化（DAG、優先度、リソース制限）
* Human-in-the-loop（BLOCKED の介入入力→再開）
* イベントソーシング/監査ログの強化
* LLM/Agent を Decider の一戦略として追加（採用判断を記録）

---

必要なら次に、**この要件をそのまま Rust の型（enum/struct/trait）へ落とし込んだ「インターフェース案」**（Queue/Executor/Decider/Repository の trait、Job/Task/Attempt/Outcome の型、status/result の DTO）まで一気に書けます。
