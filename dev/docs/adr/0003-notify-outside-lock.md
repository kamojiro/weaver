# ADR-0003: ロック外での notify による非同期安全性

- 日付: 2025-12-28
- ステータス: 承認
- レイヤ: core
- 種別: 非同期パターン / インフラストラクチャ
- 関連コンポーネント: `weaver-core::queue::memory::InMemoryLease`

---

## 1. 背景 / コンテキスト

非同期処理において、ロックと通知（notify）をどう組み合わせるかを決定する必要がある。

- **目的・解決したいこと:**
  - デッドロックを回避する
  - ロック競合を最小化し、スループットを向上させる
  - Tokio の非同期ランタイムで安全に動作させる

- **前提・制約:**
  - `InMemoryQueueState` 全体を `Arc<Mutex<_>>` で保護
  - 複数の Worker が並行してタスクを処理
  - タスク完了/失敗時に待機中の Worker を起こす必要がある
  - CLAUDE.md の要件：「ロック保持中に `.await` しない」を厳守

- **この ADR がカバーする範囲:**
  - ロックと notify のタイミング制御
  - スコープを使ったロック解放パターン

---

## 2. 決定

**ロック内で状態を更新し、ロックを解放してから notify する。**

パターン：
```rust
let should_notify = {
    let mut state = self.queue.lock().await;
    // 状態更新（同期処理のみ）
    true  // または false
};  // ← ロック自動解放

// ロック外で非同期操作
if should_notify {
    self.notify.notify_one();
}
```

スコープを使ってロック保持時間を明示的に制御し、notify は必ずロック外で実行する。

---

## 3. 選択肢と評価

### 採用案（本 ADR の決定）

**ロック外 notify + スコープによるロック制御**

- **メリット:**
  - ロック保持時間を最小化（状態更新だけ）
  - 並行性の向上（他の Worker がすぐにロックを獲得可能）
  - デッドロック回避（ロック内で `.await` しない）
  - コンパイラがロック解放を保証（スコープ終了時に自動 drop）

- **デメリット / リスク:**
  - やや冗長（`should_notify` のような変数を経由）
  - 開発者がパターンを理解する必要がある

### 代替案 A: ロック内で notify

```rust
let mut state = self.queue.lock().await;
// 状態更新
self.notify.notify_one();  // ← ロック保持中
```

- **採用しなかった理由:**
  - 他の Worker が起きてもロックを獲得できない（Worker A がまだ保持中）
  - レイテンシ増加
  - ロック競合の増加

### 代替案 B: ロック内で非同期操作

```rust
let mut state = self.queue.lock().await;
// 状態更新
some_async_operation().await;  // ← ロック保持中に .await
```

- **採用しなかった理由:**
  - **致命的**: デッドロックのリスク
  - CLAUDE.md の要件違反
  - パフォーマンス劣化

---

## 4. 根拠（評価軸と判断）

- **ビジョンとの整合:**
  - 非同期処理のベストプラクティス：副作用の分離（状態更新とイベント通知）
  - Rust の所有権を活用：スコープでロック寿命を制御

- **非機能要件:**
  - パフォーマンス：ロック保持時間最小化によりスループット向上
  - 安全性：デッドロックを設計レベルで回避
  - 可読性：スコープで意図が明確

- **Tokio のベストプラクティス:**
  - ロック保持中に `.await` しない（公式ドキュメント推奨）
  - `Notify` の効率的な使用（起こすべき時だけ notify）

---

## 5. 影響範囲

- **コード:**
  - `crates/weaver-core/src/queue/memory.rs`:
    - `InMemoryLease::ack()`: ロック外で（現在は不要だが一貫性のため）
    - `InMemoryLease::fail()`: スコープ + ロック外 notify パターンを実装
  - 将来の状態更新箇所すべてに適用

- **開発プロセス:**
  - 新しい非同期処理を追加する際、このパターンをテンプレートとして使用
  - コードレビューで「ロック内 .await」を検出

---

## 6. ロールアウト / 移行方針

- **実装状況:** 実装済み（2025-12-28、コミット `53f3b96`）
- **実装済みの要素:**
  - `InMemoryLease::fail()` でのスコープパターン
  - `should_notify` によるロックスコープ外への情報持ち出し
  - notify_one() のロック外実行

- **将来の適用:**
  - 新しい状態遷移（例: cancel）でも同じパターンを適用
  - Job-level abstraction（Phase 2）でも踏襲

---

## 7. オープンな論点 / フォローアップ

- **細粒度ロック:** 将来的に records と ready/scheduled を別々にロックする場合でも、このパターンを維持するか？
- **メトリクス送信:** notify 以外の非同期操作（メトリクス送信など）も同様にロック外で実行する
- **イベントバス:** 将来的なイベント駆動アーキテクチャでも、イベント発行をロック外で行う

---

## 8. 関連 ADR

- **ADR-0001**: TaskId のみを保持する3つのデータ構造分離（ロック最小化の基盤）
- **ADR-0002**: TaskRecord への状態遷移の集約（状態更新をロック内で安全に実行）
- **ADR-0004**: tokio::select! による複数イベント待機（notify される側のパターン）
