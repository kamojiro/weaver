# ADR-0004: tokio::select! による複数イベント待機

- 日付: 2025-12-28
- ステータス: 承認
- レイヤ: core
- 種別: 非同期パターン / インフラストラクチャ
- 関連コンポーネント: `weaver-core::queue::memory::InMemoryQueue::lease()`

---

## 1. 背景 / コンテキスト

Worker がタスクを待機する際、複数の異なるイベントを効率的に待つ方法を決定する必要がある。

- **目的・解決したいこと:**
  - 新しいタスクが enqueue されたら即座に実行
  - リトライ時刻になったら scheduled タスクを ready に昇格
  - CPU を無駄遣いせず、レイテンシを最小化

- **前提・制約:**
  - Worker は2種類のイベントを待つ：
    1. 新しいタスクの enqueue（notify 経由）
    2. scheduled タスクのリトライ時刻到来（時間経過）
  - scheduled がない場合は notify のみ待つ
  - ポーリング（定期的な sleep）は避けたい

- **この ADR がカバーする範囲:**
  - `lease()` メソッド内の待機ロジック
  - `tokio::select!` の使い方

---

## 2. 決定

**tokio::select! を使って複数イベントを並行待機する。**

実装パターン：
```rust
if let Some(wake_time) = next_wake {
    tokio::select! {
        _ = self.notify.notified() => {},       // 新タスク通知
        _ = tokio::time::sleep_until(wake_time.into()) => {},  // リトライ時刻
    }
} else {
    self.notify.notified().await;  // scheduled なし、通知のみ
}
```

どちらか先に発生したイベントで起床し、ループして状態をチェックする。

---

## 3. 選択肢と評価

### 採用案（本 ADR の決定）

**tokio::select! による並行待機**

- **メリット:**
  - どちらのイベントでも即座に反応（レイテンシ最小）
  - CPU を無駄遣いしない（真の待機、スリープ）
  - コードが簡潔で意図が明確
  - Tokio ランタイムが効率的にスケジューリング

- **デメリット / リスク:**
  - `tokio::select!` の動作理解が必要（短絡評価、キャンセル安全性）
  - わずかなランタイムオーバーヘッド（実用上問題ない）

### 代替案 A: 通知のみ待機（リトライ時刻を無視）

```rust
self.notify.notified().await;
```

- **採用しなかった理由:**
  - scheduled タスクのリトライ時刻が来ても起きない
  - リトライ遅延が不正確になる
  - 別途タイマースレッドが必要になる

### 代替案 B: ポーリング（定期的に sleep）

```rust
loop {
    tokio::time::sleep(Duration::from_millis(100)).await;
    // scheduled をチェック
    if has_ready_tasks() { break; }
}
```

- **採用しなかった理由:**
  - CPU 無駄遣い（常に起きてチェック）
  - レイテンシ増加（最大 100ms の遅延）
  - 精度が低い（リトライ時刻がずれる）

### 代替案 C: 専用タイマースレッド

```rust
// 別スレッドでタイマー管理、時刻になったら notify
```

- **採用しなかった理由:**
  - 複雑性が増す（スレッド管理、チャネル通信）
  - Tokio の機能を使えば不要
  - メモリオーバーヘッド

---

## 4. 根拠（評価軸と判断）

- **ビジョンとの整合:**
  - 効率的な実行：リソースを無駄にせず、必要な時だけ動く
  - シンプルな設計：複雑な制御フローを避ける

- **非機能要件:**
  - パフォーマンス：レイテンシ最小、CPU 効率的
  - 精度：リトライ時刻を正確に守れる
  - 保守性：select! の意図が明確、デバッグしやすい

- **Tokio のベストプラクティス:**
  - `select!` は複数イベント待機の標準パターン
  - `sleep_until` で正確なタイミング制御
  - `Notify` との組み合わせは推奨パターン

---

## 5. 影響範囲

- **コード:**
  - `crates/weaver-core/src/queue/memory.rs::lease()`:
    - 167-175行目で select! パターン実装
    - `next_wake` の有無で分岐（scheduled がない場合の最適化）

- **パフォーマンス特性:**
  - 新タスク enqueue → Worker 起床：マイクロ秒オーダー
  - リトライ時刻到来 → 昇格：ミリ秒精度
  - アイドル時の CPU 使用率：ほぼ 0%

- **将来のコンポーネント:**
  - 依存関係解決（Phase 5）でも同様のパターンを適用可能
  - キャンセル処理でも select! を活用

---

## 6. ロールアウト / 移行方針

- **実装状況:** 実装済み（2025-12-28、コミット `53f3b96`）
- **実装済みの要素:**
  - `lease()` での select! パターン
  - `next_wake` による scheduled タスクの次回時刻取得
  - scheduled がない場合の最適化（通知のみ待機）

- **テスト:**
  - 手動テスト：CLI で意図的失敗タスクを実行し、リトライ遅延を確認
  - 今後の自動テスト：時刻制御が必要（Tokio の test utilities 使用）

---

## 7. オープンな論点 / フォローアップ

- **3つ以上のイベント:** 将来的にキャンセルシグナル、外部イベントなども select! に追加する可能性
- **優先度:** select! は公平にポーリングするが、優先度付けが必要な場合の対処
- **タイムアウト:** Job 全体のデッドラインを select! に追加する（Phase 6: Budget）
- **キャンセル安全性:** 現在の実装はキャンセル安全だが、将来の変更時に注意

---

## 8. 関連 ADR

- **ADR-0001**: TaskId のみを保持する3つのデータ構造分離（scheduled の時刻管理基盤）
- **ADR-0003**: ロック外での notify による非同期安全性（notify を select! で受け取る側）
