# å®Ÿè£…è¨˜éŒ² - 2025/12/29

Phase 2 (Job-level Abstraction) ã¨ Phase 3 (Attempt/Decision è¨˜éŒ²) ã«å–ã‚Šçµ„ã¿ã¾ã—ãŸã€‚

**ã‚¿ã‚¹ã‚¯ä¸€è¦§**: å…¨ä½“ã®ã‚¿ã‚¹ã‚¯ã¨é€²æ—ã¯ `tasks.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ“ å­¦ç¿’ãƒ¡ãƒ¢

### å®Ÿè£…æ¸ˆã¿ã®ç†è§£

#### Queue ã¨ Worker ã®åˆ†é›¢
- Queue: çŠ¶æ…‹ç®¡ç†ï¼ˆQueued â†’ Running â†’ Succeeded/RetryScheduled/Deadï¼‰
- Worker: å‰¯ä½œç”¨ã®å®Ÿè¡Œï¼ˆRuntime ã‚’é€šã˜ã¦ Handler ã‚’å‘¼ã³å‡ºã™ï¼‰
- TaskLease: Queue ã¨ Worker ã®å¢ƒç•Œï¼ˆack/fail ã§çµæœã‚’å ±å‘Šï¼‰

#### éåŒæœŸã®æ³¨æ„ç‚¹
- ãƒ­ãƒƒã‚¯ä¿æŒä¸­ã« `.await` ã—ãªã„è¨­è¨ˆ
- TaskEnvelope ã‚’ clone/Arc åŒ–ã—ã¦ãƒ­ãƒƒã‚¯å¤–ã§å®Ÿè¡Œ
- ã‚­ãƒ£ãƒ³ã‚»ãƒ«å®‰å…¨æ€§ã‚’è€ƒæ…®ã—ãŸçŠ¶æ…‹é·ç§»

#### é–¢æ•°å‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
- Handler ã¯ trait ã¨ã—ã¦æŠ½è±¡åŒ–
- å°†æ¥çš„ã« Decider ã‚‚ç´”ç²‹é–¢æ•°ã¨ã—ã¦åˆ†é›¢äºˆå®š

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²

### 1. TaskState ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/state.rs`)

ã‚¿ã‚¹ã‚¯çŠ¶æ…‹ãƒã‚·ãƒ³ã‚’ enum ã§å®šç¾©ï¼š

```rust
pub enum TaskState {
    Queued,          // å®Ÿè¡Œå¯èƒ½
    Running,         // å®Ÿè¡Œä¸­
    Succeeded,       // æˆåŠŸ
    RetryScheduled,  // ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿ
    Dead,            // æ°¸ä¹…å¤±æ•—
}
```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹**: enum ã§çŠ¶æ…‹ã‚’è¡¨ç¾ã—ã€`match` ã§ç¶²ç¾…æ€§ãƒã‚§ãƒƒã‚¯
- **ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰**: `is_terminal()`, `is_runnable()` ã§çŠ¶æ…‹åˆ¤å®šã‚’æŠ½è±¡åŒ–

---

### 2. TaskRecord ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/record.rs`)

ã‚¿ã‚¹ã‚¯ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨çŠ¶æ…‹é·ç§»ãƒ­ã‚¸ãƒƒã‚¯ï¼š

- ã‚¿ã‚¹ã‚¯ã®ã€Œå˜ä¸€ã®çœŸå®Ÿã®æºï¼ˆSingle Source of Truthï¼‰ã€
- ã‚­ãƒ¥ãƒ¼ã®æ§‹é€ ä½“ï¼ˆready/scheduledï¼‰ã¯ TaskId ã®ã¿ã‚’ä¿æŒ
- ã™ã¹ã¦ã®çŠ¶æ…‹é·ç§»ã¯ã“ã®ãƒ¬ã‚³ãƒ¼ãƒ‰å†…ã§å®Ÿè¡Œ

**çŠ¶æ…‹é·ç§»ãƒ¡ã‚½ãƒƒãƒ‰**
- `start_attempt()`: Queued â†’ Runningï¼ˆattempts ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼‰
- `mark_succeeded()`: Running â†’ Succeeded
- `mark_dead()`: Running â†’ Dead
- `schedule_retry()`: Running â†’ RetryScheduled
- `requeue()`: RetryScheduled â†’ Queued

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ãƒ‡ãƒ¼ã‚¿ã®åˆ†é›¢**: é•·å¯¿å‘½ãƒ‡ãƒ¼ã‚¿ï¼ˆTaskRecordï¼‰ã¨ã‚­ãƒ¥ãƒ¼æ§‹é€ ã®åˆ†é›¢
- **ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—**: `created_at`, `updated_at` ã§ observability ã‚’ç¢ºä¿
- **çŠ¶æ…‹é·ç§»ã®æ˜ç¤ºåŒ–**: å„é·ç§»ã‚’å°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ã«åˆ†é›¢

---

### 3. RetryPolicy ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/retry.rs:45-56`)

æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®å®Ÿè£…ï¼š

```rust
pub fn next_delay(&self, attempts: u32) -> Duration {
    let base_secs = self.base_delay.as_secs_f64();
    let delay_secs = base_secs * self.multiplier.powi((attempts.saturating_sub(1)) as i32);
    Duration::from_secs_f64(delay_secs)
}
```

**ãƒãƒƒã‚¯ã‚ªãƒ•è¨ˆç®—ä¾‹** (base=2s, multiplier=2.0)
- attempt 1: 2ç§’
- attempt 2: 4ç§’
- attempt 3: 8ç§’
- attempt 4: 16ç§’
- attempt 5: 32ç§’

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ç´”ç²‹é–¢æ•°**: å‰¯ä½œç”¨ãªã—ã€åŒã˜å…¥åŠ›ã«å¯¾ã—ã¦åŒã˜å‡ºåŠ›
- **ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼å¯¾ç­–**: `saturating_sub(1)` ã§å®‰å…¨ã«è¨ˆç®—
- **å‹å¤‰æ›**: Duration â‡„ f64 ã®å¤‰æ›ãƒ‘ã‚¿ãƒ¼ãƒ³

---

### 4. InMemoryQueue ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs`)

3ã¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã£ãŸã‚­ãƒ¥ãƒ¼ç®¡ç†ï¼š

1. **records** (`HashMap<TaskId, TaskRecord>`): ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãƒ¬ã‚³ãƒ¼ãƒ‰
2. **ready** (`VecDeque<TaskId>`): å³åº§ã«å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ID
3. **scheduled** (`BinaryHeap<ScheduledTask>`): ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿä¸­ã®ã‚¿ã‚¹ã‚¯ï¼ˆæ™‚åˆ»é †ï¼‰

**é‡è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆ**

#### 4.1 scheduled â†’ ready ã®è‡ªå‹•æ˜‡æ ¼

```rust
fn promote_scheduled_tasks(&mut self) {
    let now = Instant::now();
    while let Some(entry) = self.scheduled.peek() {
        if entry.next_run_at > now {
            break; // BinaryHeap ã¯ã‚½ãƒ¼ãƒˆæ¸ˆã¿
        }
        // æ™‚åˆ»åˆ°é”ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ ready ã«ç§»å‹•
    }
}
```

#### 4.2 lease() ã®å¾…æ©Ÿãƒ­ã‚¸ãƒƒã‚¯

```rust
async fn lease(&self) -> Option<Box<dyn TaskLease>> {
    loop {
        // (1) scheduled ã‚¿ã‚¹ã‚¯ã‚’æ˜‡æ ¼
        // (2) ready ã‹ã‚‰å–å¾—ã§ãã‚Œã°ãƒªãƒ¼ã‚¹
        // (3) ãªã‘ã‚Œã°å¾…æ©Ÿï¼ˆnotify ã¾ãŸã¯ scheduled ã®æ¬¡å›æ™‚åˆ»ã¾ã§ï¼‰
        tokio::select! {
            _ = self.notify.notified() => {},
            _ = tokio::time::sleep_until(wake_time.into()) => {},
        }
    }
}
```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **BinaryHeap ã®æ´»ç”¨**: æœ€å°ãƒ’ãƒ¼ãƒ—ã§æ¬¡å›å®Ÿè¡Œæ™‚åˆ»ã‚’åŠ¹ç‡çš„ã«ç®¡ç†
- **tokio::select!**: è¤‡æ•°ã®éåŒæœŸã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…æ©Ÿ
- **ID ã®ã¿ä¿æŒ**: ã‚­ãƒ¥ãƒ¼æ§‹é€ ã«ã¯ ID ã®ã¿ã€å®Ÿä½“ã¯ HashMap ã§ç®¡ç†

---

### 5. InMemoryLease::fail ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs:208-239`)

ã‚¿ã‚¹ã‚¯å¤±æ•—æ™‚ã®å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ï¼š

1. **ãƒªãƒˆãƒ©ã‚¤å¯å¦ã®åˆ¤å®š**
   - `record.attempts >= record.max_attempts` ã§ãƒªãƒˆãƒ©ã‚¤ä¸Šé™ã‚’ãƒã‚§ãƒƒã‚¯
   - ä¸Šé™åˆ°é” â†’ `mark_dead()` ã§ Dead çŠ¶æ…‹ã«é·ç§»
   - ä¸Šé™æœªé” â†’ ãƒªãƒˆãƒ©ã‚¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

2. **ãƒãƒƒã‚¯ã‚ªãƒ•ä»˜ããƒªãƒˆãƒ©ã‚¤**
   - `retry_policy.next_delay(attempts)` ã§ãƒãƒƒã‚¯ã‚ªãƒ•æ™‚é–“ã‚’è¨ˆç®—
   - `schedule_retry()` ã§ RetryScheduled çŠ¶æ…‹ã«é·ç§»
   - `BinaryHeap` (scheduled queue) ã«æ¬¡å›å®Ÿè¡Œæ™‚åˆ»ã‚’ç™»éŒ²

3. **éåŒæœŸå®‰å…¨æ€§ã®å®Ÿè·µ**
   ```rust
   let should_notify = {
       let mut state = self.queue.lock().await;
       // ... çŠ¶æ…‹æ›´æ–° ...
   }; // â† ãƒ­ãƒƒã‚¯ã‚’ã“ã“ã§è§£æ”¾

   // ãƒ­ãƒƒã‚¯å¤–ã§ notifyï¼ˆãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿ï¼‰
   if should_notify {
       self.notify.notify_one();
   }
   ```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **æ‰€æœ‰æ¨©ã®æ´»ç”¨**: `should_notify` ã‚’ã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«æŒã¡å‡ºã—ã¦ãƒ­ãƒƒã‚¯è§£æ”¾å¾Œã«ä½¿ç”¨
- **çŠ¶æ…‹é·ç§»ã®æ˜ç¢ºåŒ–**: Dead ã¨ RetryScheduled ã‚’æ˜ç¢ºã«åŒºåˆ¥
- **éåŒæœŸã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹**: ãƒ­ãƒƒã‚¯ä¿æŒæ™‚é–“ã‚’æœ€å°åŒ–ã—ã€é€šçŸ¥ã¯å¤–ã§å®Ÿè¡Œ

---

### 6. Clippy è­¦å‘Šã®ä¿®æ­£ï¼ˆå®Œäº†ï¼‰

**è­¦å‘Šå†…å®¹** (`clippy::collapsible_if`)

ãƒã‚¹ãƒˆã—ãŸ if æ–‡ã‚’1ã¤ã«ã¾ã¨ã‚ã‚‰ã‚Œã‚‹ã¨ã„ã†æŒ‡æ‘˜ã€‚

**ä¿®æ­£å‰** (`memory.rs:83-87`)
```rust
if let Some(record) = self.records.get_mut(&entry.task_id) {
    if record.state == TaskState::RetryScheduled {
        record.requeue();
        self.ready.push_back(entry.task_id);
    }
}
```

**ä¿®æ­£å¾Œ**
```rust
if let Some(record) = self.records.get_mut(&entry.task_id)
    && record.state == TaskState::RetryScheduled
{
    record.requeue();
    self.ready.push_back(entry.task_id);
}
```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **let-chain**: Rust 2021 edition ã®æ©Ÿèƒ½ã§ã€`if let` ã¨æ¡ä»¶ã‚’ `&&` ã§é€£çµå¯èƒ½
- **å¯èª­æ€§ã®å‘ä¸Š**: ãƒã‚¹ãƒˆã‚’æ¸›ã‚‰ã—ã€æ¡ä»¶ã®ä¸¦åˆ—æ€§ã‚’æ˜ç¢ºåŒ–
- **çŸ­çµ¡è©•ä¾¡**: å·¦ã‹ã‚‰é †ã«è©•ä¾¡ã•ã‚Œã€false ã«ãªã‚Œã°ä»¥é™ã¯è©•ä¾¡ã•ã‚Œãªã„
- **clippy ã®æ´»ç”¨**: ã‚³ãƒ¼ãƒ‰å“è³ªã‚’ä¿ã¤ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦æ´»ç”¨

---

### 7. ADR ã®ä½œæˆï¼ˆå®Œäº†ï¼‰

Phase 1 å®Ÿè£…ã®ä¸»è¦ãªè¨­è¨ˆåˆ¤æ–­ã‚’ ADR ã¨ã—ã¦æ–‡æ›¸åŒ–ï¼š

**ä½œæˆã—ãŸ ADR:**

1. **ADR-0001**: TaskId ã®ã¿ã‚’ä¿æŒã™ã‚‹3ã¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆ†é›¢
   - `dev/docs/adr/0001-task-id-only-queue-design.md`
   - Single Source of Truth ãƒ‘ã‚¿ãƒ¼ãƒ³
   - æ‰€æœ‰æ¨©ã®æ˜ç¢ºåŒ–ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãƒãƒ©ãƒ³ã‚¹

2. **ADR-0002**: TaskRecord ã¸ã®çŠ¶æ…‹é·ç§»ã®é›†ç´„
   - `dev/docs/adr/0002-state-transitions-in-taskrecord.md`
   - ã‚«ãƒ—ã‚»ãƒ«åŒ–ã¨ä¸å¤‰æ¡ä»¶ã®ä¿è­·
   - çŠ¶æ…‹é·ç§»ã®æ˜ç¤ºåŒ–

3. **ADR-0003**: ãƒ­ãƒƒã‚¯å¤–ã§ã® notify ã«ã‚ˆã‚‹éåŒæœŸå®‰å…¨æ€§
   - `dev/docs/adr/0003-notify-outside-lock.md`
   - ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿ã¨ãƒ­ãƒƒã‚¯æœ€å°åŒ–
   - ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚ˆã‚‹ãƒ­ãƒƒã‚¯åˆ¶å¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³

4. **ADR-0004**: tokio::select! ã«ã‚ˆã‚‹è¤‡æ•°ã‚¤ãƒ™ãƒ³ãƒˆå¾…æ©Ÿ
   - `dev/docs/adr/0004-tokio-select-for-multiple-events.md`
   - åŠ¹ç‡çš„ãªã‚¤ãƒ™ãƒ³ãƒˆå¾…æ©Ÿ
   - ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·æœ€å°åŒ–ã¨ CPU åŠ¹ç‡åŒ–

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **è¨­è¨ˆåˆ¤æ–­ã®è¨˜éŒ²ã®é‡è¦æ€§**: ã€Œãªãœã“ã†ã—ãŸã®ã‹ã€ã‚’æ®‹ã™ã“ã¨ã§ã€å°†æ¥ã®å¤‰æ›´æ™‚ã«åˆ¤æ–­ææ–™ã«ãªã‚‹
- **ä»£æ›¿æ¡ˆã®æ¤œè¨**: æ¡ç”¨ã—ãŸæ¡ˆã ã‘ã§ãªãã€æ¤œè¨ã—ãŸä»–ã®æ¡ˆã‚‚è¨˜éŒ²ã™ã‚‹ã“ã¨ã§æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ãŒå¯è¦–åŒ–ã•ã‚Œã‚‹
- **ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã®æ˜ç¤º**: ã™ã¹ã¦ã®è¨­è¨ˆã«ã¯é•·æ‰€ã¨çŸ­æ‰€ãŒã‚ã‚Šã€ãã‚Œã‚’æ˜ç¢ºã«ã™ã‚‹ã“ã¨ãŒé‡è¦

---

## ğŸ“ å…¨ä½“ã¨ã—ã¦å­¦ã‚“ã ã“ã¨

### Rust ã®æ‰€æœ‰æ¨©ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 
- TaskId ã®ã¿ã‚’ä¿æŒã—ã€TaskRecord ã¸ã®å‚ç…§ã‚’é¿ã‘ã‚‹è¨­è¨ˆ
- Arc/Mutex ã«ã‚ˆã‚‹å…±æœ‰å¯å¤‰çŠ¶æ…‹ã®ç®¡ç†
- ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ´»ç”¨ã—ãŸãƒ­ãƒƒã‚¯è§£æ”¾ã®åˆ¶å¾¡

### éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼ˆTokioï¼‰
- ãƒ­ãƒƒã‚¯ä¿æŒä¸­ã« `.await` ã—ãªã„åŸå‰‡ã®å®Ÿè·µ
- `tokio::select!` ã«ã‚ˆã‚‹è¤‡æ•°ã‚¤ãƒ™ãƒ³ãƒˆå¾…æ©Ÿ
- `Notify` ã‚’ä½¿ã£ãŸåŠ¹ç‡çš„ãªãƒ¯ãƒ¼ã‚«ãƒ¼é€šçŸ¥

### é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°
- enum ã«ã‚ˆã‚‹ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¨ç¶²ç¾…æ€§ãƒã‚§ãƒƒã‚¯
- RetryPolicy ã®ç´”ç²‹é–¢æ•°ã¨ã—ã¦ã®å®Ÿè£…
- å‰¯ä½œç”¨ï¼ˆçŠ¶æ…‹é·ç§»ï¼‰ã¨åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒãƒƒã‚¯ã‚ªãƒ•è¨ˆç®—ï¼‰ã®åˆ†é›¢

### ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®é¸æŠ
- VecDeque: FIFO ã‚­ãƒ¥ãƒ¼ï¼ˆready queueï¼‰
- BinaryHeap: å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ï¼ˆscheduled queueï¼‰
- HashMap: åŠ¹ç‡çš„ãª ID â†’ ãƒ¬ã‚³ãƒ¼ãƒ‰æ¤œç´¢

---

---

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²ï¼ˆ2025-12-29ï¼‰

### 1. TaskRecord ã¸ã® job_id ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/record.rs`)

Task ã¨ Job ã®é€£æºã‚’å®Ÿç¾ï¼š

1. **job_id ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è¿½åŠ **
   ```rust
   pub struct TaskRecord {
       pub envelope: TaskEnvelope,
       pub state: TaskState,
       pub job_id: Option<JobId>,  // â† è¿½åŠ 
       // ...
   }
   ```

2. **å¾Œæ–¹äº’æ›æ€§ã®ä¿æŒ**
   - `new()` ã®ã‚·ã‚°ãƒãƒãƒ£ã¯å¤‰æ›´ã›ãš
   - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ `job_id = None`
   - æ—¢å­˜ã‚³ãƒ¼ãƒ‰ï¼ˆPhase 1ï¼‰ãŒãã®ã¾ã¾å‹•ä½œ

3. **Job ä»˜ãã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®è¿½åŠ **
   ```rust
   pub fn new_with_job(envelope: TaskEnvelope, max_attempts: u32, job_id: JobId) -> Self
   ```
   - `new()` ã‚’å†åˆ©ç”¨ï¼ˆDRY åŸå‰‡ï¼‰
   - job_id ã®ã¿ã‚’è¿½åŠ è¨­å®š

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **Option<T> ã«ã‚ˆã‚‹æ®µéšçš„ç§»è¡Œ**: æ—¢å­˜æ©Ÿèƒ½ã‚’å£Šã•ãšã«æ–°æ©Ÿèƒ½ã‚’è¿½åŠ 
- **ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰é…ç½®ã®åˆ¤æ–­**: state ã®è¿‘ãã«é…ç½®ã—ã€è«–ç†çš„ãªã‚°ãƒ«ãƒ¼ãƒ—åŒ–
- **ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³**: å…±é€šãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨ã—ã€å·®åˆ†ã ã‘ã‚’å®Ÿè£…

---

### 2. JobManager ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs`)

InMemoryQueueState ã« Job ç®¡ç†æ©Ÿèƒ½ã‚’è¿½åŠ ï¼š

1. **ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®è¿½åŠ **
   ```rust
   struct InMemoryQueueState {
       jobs: HashMap<JobId, JobRecord>,      // Job ã® Single Source of Truth
       records: HashMap<TaskId, TaskRecord>, // Task ã® Single Source of Truth
       next_job_id: u64,                     // Job ID ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
       next_task_id: u64,                    // Task ID ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ (renamed)
       // ...
   }
   ```

2. **ID æ¡ç•ªãƒ­ã‚¸ãƒƒã‚¯** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
   ```rust
   fn allocate_job_id(&mut self) -> JobId {
       let id = JobId::new(self.next_job_id);
       self.next_job_id += 1;
       id
   }
   ```
   - Phase 1 ã® `allocate_task_id` ã¨åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³
   - newtype ã«ã‚ˆã‚Šå‹å®‰å…¨æ€§ã‚’ç¢ºä¿

3. **Job ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
   ```rust
   fn create_job(&mut self, spec: JobSpec) -> JobId {
       let id = self.allocate_job_id();
       let job_record = JobRecord::new(id, spec);
       self.jobs.insert(id, job_record);
       id
   }
   ```
   - æ¡ç•ª â†’ ä½œæˆ â†’ æŒ¿å…¥ â†’ è¿”å´ã®æµã‚Œ

4. **Job å–å¾—ãƒ¡ã‚½ãƒƒãƒ‰** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
   ```rust
   fn get_job(&self, job_id: JobId) -> Option<&JobRecord>
   fn get_job_mut(&mut self, job_id: JobId) -> Option<&mut JobRecord>
   ```
   - ã‚·ãƒ³ãƒ—ãƒ«ãª HashMap lookup

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å†åˆ©ç”¨**: Phase 1ï¼ˆTaskï¼‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ Phase 2ï¼ˆJobï¼‰ã«é©ç”¨
- **å¯¾ç§°æ€§**: allocate_job_id ã¨ allocate_task_id ã®æ§‹é€ çš„ãªé¡ä¼¼æ€§
- **ADR-0001 ã®é©ç”¨**: Single Source of Truth ã‚’ Job ã«ã‚‚é©ç”¨
- **å‹å®‰å…¨æ€§**: newtype ã«ã‚ˆã‚Š JobId ã¨ TaskId ã®æ··åŒã‚’é˜²ã

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- ~~Job ã¨ Task ã®é€£æºï¼ˆJob ã‹ã‚‰ Task ã‚’ä½œæˆï¼‰~~ âœ… å®Œäº†
- submit_job API ã®å®Ÿè£…ï¼ˆå¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰

---

### 3. Job ã‹ã‚‰ Task ã‚’ä½œæˆã™ã‚‹æ©Ÿèƒ½ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs:140-160`)

Job ã¨ Task ã®å®Ÿéš›ã®é€£æºã‚’å®Ÿç¾ï¼š

**create_job_with_tasks ãƒ¡ã‚½ãƒƒãƒ‰** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
fn create_job_with_tasks(&mut self, spec: JobSpec) -> JobId {
    let job_id = self.create_job(spec.clone());
    let max_attempts = spec.budget.max_attempts_per_task;
    for task_spec in &spec.tasks {
        let task_id = self.allocate_task_id();
        // TaskSpec â†’ TaskEnvelope å¤‰æ›
        // TaskRecord ä½œæˆï¼ˆnew_with_job ä½¿ç”¨ï¼‰
        // HashMap + ready queue ã«ç™»éŒ²
        // Job ã« task_id ã‚’è¿½åŠ 
    }
    job_id
}
```

**å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ:**
1. **Job ä½œæˆ**: create_job ã§ Job ã‚’å…ˆã«ä½œæˆ
2. **ãƒ«ãƒ¼ãƒ—ã§ Task ä½œæˆ**: å„ TaskSpec ã‚’å‡¦ç†
   - TaskSpec.title â†’ TaskTypeï¼ˆ"generic" ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
   - TaskSpec å…¨ä½“ â†’ payloadï¼ˆJSON å¤‰æ›ï¼‰
   - TaskRecord::new_with_job ã§ job_id ã‚’è¨­å®š
3. **åŒæ–¹å‘é–¢é€£ä»˜ã‘**:
   - TaskRecord ã« job_idï¼ˆnew_with_job ã§è¨­å®šï¼‰
   - JobRecord ã« task_idsï¼ˆadd_task ã§è¿½åŠ ï¼‰
4. **ã‚­ãƒ¥ãƒ¼ã¸ã®ç™»éŒ²**: ready.push_back ã§å³åº§ã«å®Ÿè¡Œå¯èƒ½ã«

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±åˆ**: Phase 1 ã¨ Phase 2 ã®ã™ã¹ã¦ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’1ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§çµ±åˆ
- **ãƒ«ãƒ¼ãƒ—å†…ã§ã®çŠ¶æ…‹æ›´æ–°**: å„åå¾©ã§ Job ã‚’æ›´æ–°ã™ã‚‹è¨­è¨ˆ
- **v1 ã®æŸ”è»Ÿæ€§**: unwrap_or ã§æ¬ æå€¤ã«å¯¾å¿œ
- **åŒæ–¹å‘é–¢é€£ã®å®Ÿè£…**: å‚ç…§æ•´åˆæ€§ã‚’æ‰‹å‹•ã§ç®¡ç†ï¼ˆjob_id â‡„ task_idsï¼‰

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- ~~submit_job API ã®å®Ÿè£…ï¼ˆInMemoryQueue ã« public ãƒ¡ã‚½ãƒƒãƒ‰è¿½åŠ ï¼‰~~ âœ… å®Œäº†
- Job ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆTask å®Œäº†æ™‚ã« Job çŠ¶æ…‹ã‚’æ›´æ–°ï¼‰

---

### 4. submit_job API ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs:240-249`)

å¤–éƒ¨å…¬é–‹ API ã®å®Œæˆï¼š

**submit_job ãƒ¡ã‚½ãƒƒãƒ‰** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
pub async fn submit_job(&self, spec: JobSpec) -> Result<JobId, WeaverError> {
    let job_id = {
        let mut state = self.state.lock().await;
        state.create_job_with_tasks(spec)
    };
    self.notify.notify_one();
    Ok(job_id)
}
```

**å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ:**
1. **ã‚¹ã‚³ãƒ¼ãƒ—ã§ãƒ­ãƒƒã‚¯åˆ¶å¾¡**:
   - ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ãƒ­ãƒƒã‚¯å–å¾—ãƒ»å‡¦ç†
   - ãƒ–ãƒ­ãƒƒã‚¯çµ‚äº†ã§è‡ªå‹•è§£æ”¾
   - drop() ã‚’æ˜ç¤ºçš„ã«æ›¸ã‹ãªãã¦ã‚‚å®‰å…¨

2. **ADR-0003 ã®é©ç”¨**:
   - ãƒ­ãƒƒã‚¯å¤–ã§ notify_one()
   - Worker ã®ä¸¦è¡Œæ€§ã‚’æœ€å¤§åŒ–

3. **ã‚·ãƒ³ãƒ—ãƒ«ã•**:
   - create_job_with_tasks ãŒ ready queue ç™»éŒ²ã¾ã§å‡¦ç†
   - API ã¯è–„ã„ãƒ©ãƒƒãƒ‘ãƒ¼ã«å¾¹ã™ã‚‹

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **Public API ã®è¨­è¨ˆ**: å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«
- **å†…éƒ¨å®Ÿè£…ã®å†åˆ©ç”¨**: create_job_with_tasks ã‚’å‘¼ã¶ã ã‘
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸€è²«æ€§**: enqueue() ã¨åŒã˜æ§‹é€ 
- **ADR-0003 ã®å®Œç’§ãªé©ç”¨**: Phase 1 ã‹ã‚‰ Phase 2 ã¾ã§ä¸€è²«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³

---

## ğŸ‰ Phase 2: Job-level Abstraction å®Œæˆï¼

âœ… **å®Œäº†ã—ãŸæ©Ÿèƒ½:**
1. JobRecord + JobStateï¼ˆçŠ¶æ…‹ç®¡ç†ï¼‰
2. TaskRecord ã¸ã® job_id è¿½åŠ ï¼ˆé€£æºåŸºç›¤ï¼‰
3. JobManagerï¼ˆCRUD æ“ä½œï¼‰
4. create_job_with_tasksï¼ˆJob â‡„ Task å®Œå…¨é€£æºï¼‰
5. **submit_job API**ï¼ˆå¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰

ğŸ“ **Phase 2 ã§å­¦ã‚“ã ã“ã¨:**
- çŠ¶æ…‹é›†ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆè¤‡æ•°çŠ¶æ…‹ â†’ å˜ä¸€çŠ¶æ…‹ï¼‰
- Option<T> ã«ã‚ˆã‚‹æ®µéšçš„ç§»è¡Œ
- Phase 1 ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å†åˆ©ç”¨ã¨æ‹¡å¼µ
- åŒæ–¹å‘é–¢é€£ã®å®Ÿè£…ã¨ç®¡ç†
- ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±åˆï¼ˆID æ¡ç•ªã€CRUDã€ãƒ­ãƒƒã‚¯åˆ¶å¾¡ã€notifyï¼‰
- Public API ã®è¨­è¨ˆåŸå‰‡

**æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºå€™è£œ:**
- Phase 3: Attempt/Decision è¨˜éŒ²ï¼ˆå®Ÿè¡Œå±¥æ­´ï¼‰
- Phase 5: ä¾å­˜é–¢ä¿‚ç®¡ç†
- Phase 6: Budget ã¨ Stuck æ¤œçŸ¥
- Phase 7: æ®‹ã‚Šã® APIï¼ˆget_status, cancel_job, get_resultï¼‰

---

### 8. Phase 2: Job-level Abstraction ã®é–‹å§‹ï¼ˆæ˜¨æ—¥ã‹ã‚‰ç¶™ç¶šï¼‰

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/domain/job.rs`)

Job ã®çŠ¶æ…‹ç®¡ç†æ§‹é€ ã‚’ä½œæˆï¼š

1. **JobState enum ã®å®šç¾©**
   - Running, Completed, Failed, Cancelled ã®4çŠ¶æ…‹
   - Task çŠ¶æ…‹ã®é›†ç´„çµæœã‚’è¡¨ç¾

2. **JobRecord æ§‹é€ ä½“**
   - Job ã® Single Source of Truth
   - task_ids ã§è¤‡æ•° Task ã‚’ç®¡ç†
   - update_state_from_tasks ã§çŠ¶æ…‹é›†ç´„

3. **çŠ¶æ…‹é›†ç´„ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
   ```rust
   pub fn update_state_from_tasks(&mut self, task_states: &[(TaskId, TaskState)]) {
       // è¤‡æ•°ã® Task çŠ¶æ…‹ã‹ã‚‰ Job çŠ¶æ…‹ã‚’å°å‡º
   }
   ```

   **åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯:**
   - ã™ã¹ã¦ Succeeded â†’ Completed
   - ã„ãšã‚Œã‹ Running/Queued/RetryScheduled â†’ Running
   - ã™ã¹ã¦ terminal ã§ Dead å«ã‚€ â†’ Failed
   - ç©ºã®å ´åˆ â†’ Running (åˆæœŸçŠ¶æ…‹)

4. **åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆ** âœ…ï¼ˆ8ã¤ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ï¼‰
   - rstest ã‚’ä½¿ã£ãŸ parameterized ãƒ†ã‚¹ãƒˆ
   - ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆç©ºã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼‰ã‚‚ã‚«ãƒãƒ¼

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **çŠ¶æ…‹é›†ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³**: è¤‡æ•°ã®çŠ¶æ…‹ã‹ã‚‰1ã¤ã®çŠ¶æ…‹ã‚’å°å‡ºã™ã‚‹é«˜ãƒ¬ãƒ™ãƒ«æŠ½è±¡åŒ–
- **Early exit ã®æ´»ç”¨**: `all()`, `any()` ã«ã‚ˆã‚‹åŠ¹ç‡çš„åˆ¤å®š
- **å„ªå…ˆé †ä½ã®æ˜ç¢ºåŒ–**: if-else ãƒã‚§ãƒ¼ãƒ³ã®é †åºãŒé‡è¦
- **Phase 1 ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å†åˆ©ç”¨**: ADR-0001, ADR-0002 ã®åŸå‰‡ã‚’ Job ãƒ¬ãƒ™ãƒ«ã«é©ç”¨

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- JobManager ã®å®Ÿè£…ï¼ˆJob ã® CRUD æ“ä½œï¼‰
- Task ã¨ Job ã®é€£æºï¼ˆTask ã« job_id ã‚’è¿½åŠ ï¼‰
- submit_job API ã®å®Ÿè£…

---

### 5. Phase 3 é–‹å§‹: AttemptRecord ã¨ DecisionRecord ã®å®Ÿè£…ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/domain/attempt.rs`)

å®Ÿè¡Œå±¥æ­´è¨˜éŒ²ã®åŸºç›¤ã¨ãªã‚‹ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆï¼š

**5.1 AttemptRecord::new ã®å®Ÿè£…** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
pub fn new(
    attempt_id: AttemptId,
    task_id: TaskId,
    action: serde_json::Value,
    observation: Vec<Artifact>,
    outcome: Outcome,
) -> Self {
    Self {
        attempt_id,
        task_id,
        action,
        observation,
        outcome,
        started_at: Instant::now(),
        completed_at: Instant::now(),
    }
}
```

**ãƒã‚¤ãƒ³ãƒˆ:**
- æ§‹é€ ä½“åˆæœŸåŒ–ã®çœç•¥è¨˜æ³•ï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å = ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åï¼‰
- v1 ç°¡æ½”åŒ–: started_at ã¨ completed_at ã‚’åŒæ™‚åˆ»ã«è¨­å®š
- ã™ã¹ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç›´æ¥ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒãƒƒãƒ”ãƒ³ã‚°

**5.2 DecisionRecord::new ã®å®Ÿè£…** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
pub fn new(
    task_id: TaskId,
    trigger: serde_json::Value,
    policy: impl Into<String>,
    decision: impl Into<String>,
    context: Option<serde_json::Value>,
) -> Self {
    Self {
        task_id,
        trigger,
        policy: policy.into(),
        decision: decision.into(),
        context,
        decided_at: Instant::now(),
    }
}
```

**ãƒã‚¤ãƒ³ãƒˆ:**
- `impl Into<String>` ã«ã‚ˆã‚‹æŸ”è»Ÿãª API
  - å‘¼ã³å‡ºã—å´: `"retry"` ã¾ãŸã¯ `String::from("retry")` ä¸¡æ–¹ OK
  - `.into()` ã§è‡ªå‹•å¤‰æ›
- Option<T> ã¯ç›´æ¥æ¸¡ã™ï¼ˆã™ã§ã«æ­£ã—ã„å‹ï¼‰

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **æ§‹é€ ä½“åˆæœŸåŒ–ã®çœç•¥è¨˜æ³•**: Rust ã®æ…£ç”¨çš„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã€å†—é•·æ€§ã‚’å‰Šæ¸›
- **Into trait ã®æ´»ç”¨**: API ã®äººé–“å·¥å­¦ï¼ˆergonomicsï¼‰ã‚’å‘ä¸Š
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å†åˆ©ç”¨**: JobRecord, TaskRecord ã¨åŒã˜ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿æ§‹é€ 
- **ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚³ãƒ¼ãƒ‰**: çŠ¶æ…‹é›†ç´„ãªã©ã®è¤‡é›‘ãƒ­ã‚¸ãƒƒã‚¯ãªã—ã€ç´”ç²‹ãªãƒ‡ãƒ¼ã‚¿ä¿æŒ

**Phase 3 ã®æ„ç¾©:**
- ã“ã‚Œã§ã€Œä½•ã‚’ã‚„ã£ãŸã‹ã€ï¼ˆAttemptRecordï¼‰ã¨ã€Œãªãœãã†åˆ¤æ–­ã—ãŸã‹ã€ï¼ˆDecisionRecordï¼‰ã‚’è¨˜éŒ²ã§ãã‚‹åŸºç›¤ãŒæ•´ã£ãŸ
- æ¬¡ã¯ã€å®Ÿéš›ã®å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã§ã“ã‚Œã‚‰ã‚’è¨˜éŒ²ã™ã‚‹æ©Ÿæ§‹ã®å®Ÿè£…

---

### 6. Attempt/Decision è¨˜éŒ²ã®ç®¡ç†æ©Ÿæ§‹ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs`)

InMemoryQueueState ã« Attempt ã¨ Decision ã®è¨˜éŒ²ç®¡ç†ã‚’è¿½åŠ ï¼š

**6.1 ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®è¿½åŠ ** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
struct InMemoryQueueState {
    jobs: HashMap<JobId, JobRecord>,
    records: HashMap<TaskId, TaskRecord>,
    ready: VecDeque<TaskId>,

    // Phase 3: å±¥æ­´è¨˜éŒ²
    attempts: HashMap<AttemptId, AttemptRecord>,  // â† è¿½åŠ 
    decisions: Vec<DecisionRecord>,                // â† è¿½åŠ 

    scheduled: BinaryHeap<ScheduledTask>,
    next_job_id: u64,
    next_task_id: u64,
    next_attempt_id: u64,                          // â† è¿½åŠ 
    retry_policy: RetryPolicy,
}
```

**ãƒã‚¤ãƒ³ãƒˆ:**
- **attempts**: HashMap ã§ Single Source of Truthï¼ˆADR-0001ï¼‰
- **decisions**: Vec ã§æ™‚ç³»åˆ—ç®¡ç†ï¼ˆv1 ç°¡æ½”åŒ–ï¼‰
- **next_attempt_id**: ID ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

**6.2 åˆæœŸåŒ–ã®æ›´æ–°** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
fn new(retry_policy: RetryPolicy) -> Self {
    Self {
        // ...
        attempts: HashMap::new(),
        decisions: Vec::new(),
        // ...
        next_attempt_id: 1,
        // ...
    }
}
```

**6.3 AttemptId æ¡ç•ª** âœ…ï¼ˆè‡ªåˆ†ã§å®Ÿè£…ï¼‰
```rust
fn allocate_attempt_id(&mut self) -> AttemptId {
    let id = AttemptId::new(self.next_attempt_id);
    self.next_attempt_id += 1;
    id
}
```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ**
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸€è²«æ€§**: Phase 1ï¼ˆTaskï¼‰ã€Phase 2ï¼ˆJobï¼‰ã¨å…¨ãåŒã˜æ§‹é€ 
- **ADR-0001 ã®æ‹¡å¼µ**: Single Source of Truth ã‚’ Attempt ã«ã‚‚é©ç”¨
- **æ®µéšçš„å®Ÿè£…**: ã¾ãšåŸºç›¤ã‚’æ•´å‚™ã—ã€ä½¿ç”¨ã¯æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸
- **ã‚³ãƒ¡ãƒ³ãƒˆã®æ´»ç”¨**: Phase 3 ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ˜ç¤ºã—ã¦ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã‚’æ•´ç†

**Serialize/Deserialize å•é¡Œã®è§£æ±º:**
- `Instant` ã¯ Serialize ã§ããªã„ãŸã‚ã€AttemptRecord ã¨ DecisionRecord ã‹ã‚‰å‰Šé™¤
- TaskRecord, JobRecord ã¨åŒæ§˜ã«ã€v1 ã§ã¯å†…éƒ¨è¨˜éŒ²ã®ã¿ï¼ˆæ°¸ç¶šåŒ–ä¸è¦ï¼‰
- å°†æ¥çš„ã«å¿…è¦ãªã‚‰ `#[serde(skip)]` ã‚„å‹å¤‰æ›´ã§å¯¾å¿œ

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- TaskLease ã® ack/fail ã§ AttemptRecord ã‚’è¨˜éŒ²
- ãƒªãƒˆãƒ©ã‚¤åˆ¤æ–­æ™‚ã« DecisionRecord ã‚’è¨˜éŒ²
- å±¥æ­´å–å¾— API ã®å®Ÿè£…ï¼ˆå°†æ¥ï¼‰

---

## ğŸ“š å‚è€ƒè³‡æ–™

- è¦ä»¶: `dev/docs/requirements/2025_12_27_weaver_requirements.md`
- æˆåŠŸæ¡ä»¶: è¦ä»¶ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã€Œ12. v1 ã®æˆåŠŸæ¡ä»¶ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£: `CLAUDE.md`
