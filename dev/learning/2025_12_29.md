# Learning Tasks - 2025/12/29

**前日からの継続**: Phase 2 (Job-level Abstraction) を進めています。

## 📋 タスクリスト

### Phase 1: 基礎実装（既に完了しているもの）

- [x] Domain model (IDs, Specs, Outcomes) の実装
- [x] Error types の定義
- [x] Queue trait + InMemoryQueue の実装
- [x] TaskLease, TaskRecord, TaskState の実装
- [x] RetryPolicy の実装
- [x] HandlerRegistry + Runtime の実装
- [x] Worker/WorkerGroup の実装
- [x] 基本的なタスク実行とリトライ機能

### Phase 2: Job-level Abstraction（学習タスク）

現在は Task 単位での実行のみ。Job（複数タスクの集合）を扱えるようにする。

- [ ] JobRecord の実装（複数 Task を含む）
- [ ] JobId による管理機能
- [ ] Job → Task の関連付け
- [ ] Job 全体のステータス集約

**ゴール**: `submit_job(JobSpec) -> JobId` のような API を実装

### Phase 3: Attempt/Decision の記録（学習タスク）

実行履歴と判断の記録を残す仕組み。

- [ ] Attempt モデルの実装
  - 何をやったか（Action）
  - 何が起きたか（Observation）
  - 結果（Outcome）
- [ ] Decision モデルの実装
  - どの観測を根拠に
  - どの方針（policy）で
  - 何を変更したか
- [ ] 履歴の保存と取得

**ゴール**: 「なぜこの結果になったか」を説明可能にする

### Phase 4: Task 分解（Decomposition）（学習タスク）

抽象的/大きすぎるタスクを実行可能単位に分解する。

- [ ] Decider trait の設計
  - 純粋関数として実装（副作用の分離）
- [ ] 分解ロジックの実装
  - TaskSpec → 複数の TaskSpec への分解
- [ ] 親子関係の管理
- [ ] 子タスク完了時の親タスク処理

**ゴール**: 大きなタスクを自動的に小さな実行単位に分解

### Phase 5: 依存関係管理（学習タスク）

タスク間の「これが終わらないと進めない」関係を表現する。

- [ ] Dependency モデルの実装
- [ ] 依存グラフの管理
- [ ] 依存解決のスケジューリング
- [ ] 循環依存の検出

**ゴール**: タスクが依存関係を持てるようにし、自動的に順序制御

### Phase 6: Budget と Stuck 検知（学習タスク）

実行制約と「進めない状態」の検知。

- [ ] Budget の実装
  - max_attempts（既に RetryPolicy で部分的に実装済み）
  - deadline（期限）
  - max_total_cost（コスト上限）
- [ ] Stuck 検知ロジック
  - RUNNABLE が存在しない状態の検出
  - 依存サイクルの検出
  - Budget 到達の検出
- [ ] 適切な終了処理

**ゴール**: 無限ループを防ぎ、適切なタイミングで終了

### Phase 7: API の実装（学習タスク）

外部から利用可能な API を整備する。

- [ ] `submit_job(JobSpec) -> JobId`
- [ ] `get_status(JobId) -> JobStatus`
- [ ] `cancel_job(JobId) -> CancelAck`
- [ ] `get_result(JobId) -> JobResult`

**ゴール**: ライブラリとして使いやすい API を提供

### Phase 8: Artifact の実装（学習タスク）

実行結果の成果物を記録・参照する。

- [ ] Artifact の保存機構
- [ ] ファイル、URL、stdout/stderr の記録
- [ ] Artifact の取得 API

**ゴール**: 実行結果の成果物を追跡可能に

---

## 📝 学習メモ

### 実装済みの理解

#### Queue と Worker の分離
- Queue: 状態管理（Queued → Running → Succeeded/RetryScheduled/Dead）
- Worker: 副作用の実行（Runtime を通じて Handler を呼び出す）
- TaskLease: Queue と Worker の境界（ack/fail で結果を報告）

#### 非同期の注意点
- ロック保持中に `.await` しない設計
- TaskEnvelope を clone/Arc 化してロック外で実行
- キャンセル安全性を考慮した状態遷移

#### 関数型アプローチ
- Handler は trait として抽象化
- 将来的に Decider も純粋関数として分離予定

---

## 📅 本日の実装記録

### 1. TaskState の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/state.rs`)

タスク状態マシンを enum で定義：

```rust
pub enum TaskState {
    Queued,          // 実行可能
    Running,         // 実行中
    Succeeded,       // 成功
    RetryScheduled,  // リトライ待機
    Dead,            // 永久失敗
}
```

**学んだポイント**
- **代数的データ型**: enum で状態を表現し、`match` で網羅性チェック
- **ヘルパーメソッド**: `is_terminal()`, `is_runnable()` で状態判定を抽象化

---

### 2. TaskRecord の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/record.rs`)

タスクのメタデータと状態遷移ロジック：

- タスクの「単一の真実の源（Single Source of Truth）」
- キューの構造体（ready/scheduled）は TaskId のみを保持
- すべての状態遷移はこのレコード内で実行

**状態遷移メソッド**
- `start_attempt()`: Queued → Running（attempts をインクリメント）
- `mark_succeeded()`: Running → Succeeded
- `mark_dead()`: Running → Dead
- `schedule_retry()`: Running → RetryScheduled
- `requeue()`: RetryScheduled → Queued

**学んだポイント**
- **データの分離**: 長寿命データ（TaskRecord）とキュー構造の分離
- **タイムスタンプ**: `created_at`, `updated_at` で observability を確保
- **状態遷移の明示化**: 各遷移を専用メソッドに分離

---

### 3. RetryPolicy の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/retry.rs:45-56`)

指数バックオフの実装：

```rust
pub fn next_delay(&self, attempts: u32) -> Duration {
    let base_secs = self.base_delay.as_secs_f64();
    let delay_secs = base_secs * self.multiplier.powi((attempts.saturating_sub(1)) as i32);
    Duration::from_secs_f64(delay_secs)
}
```

**バックオフ計算例** (base=2s, multiplier=2.0)
- attempt 1: 2秒
- attempt 2: 4秒
- attempt 3: 8秒
- attempt 4: 16秒
- attempt 5: 32秒

**学んだポイント**
- **純粋関数**: 副作用なし、同じ入力に対して同じ出力
- **オーバーフロー対策**: `saturating_sub(1)` で安全に計算
- **型変換**: Duration ⇄ f64 の変換パターン

---

### 4. InMemoryQueue の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/memory.rs`)

3つのデータ構造を使ったキュー管理：

1. **records** (`HashMap<TaskId, TaskRecord>`): すべてのタスクレコード
2. **ready** (`VecDeque<TaskId>`): 即座に実行可能なタスクID
3. **scheduled** (`BinaryHeap<ScheduledTask>`): リトライ待機中のタスク（時刻順）

**重要な実装ポイント**

#### 4.1 scheduled → ready の自動昇格

```rust
fn promote_scheduled_tasks(&mut self) {
    let now = Instant::now();
    while let Some(entry) = self.scheduled.peek() {
        if entry.next_run_at > now {
            break; // BinaryHeap はソート済み
        }
        // 時刻到達したタスクを ready に移動
    }
}
```

#### 4.2 lease() の待機ロジック

```rust
async fn lease(&self) -> Option<Box<dyn TaskLease>> {
    loop {
        // (1) scheduled タスクを昇格
        // (2) ready から取得できればリース
        // (3) なければ待機（notify または scheduled の次回時刻まで）
        tokio::select! {
            _ = self.notify.notified() => {},
            _ = tokio::time::sleep_until(wake_time.into()) => {},
        }
    }
}
```

**学んだポイント**
- **BinaryHeap の活用**: 最小ヒープで次回実行時刻を効率的に管理
- **tokio::select!**: 複数の非同期イベントを待機
- **ID のみ保持**: キュー構造には ID のみ、実体は HashMap で管理

---

### 5. InMemoryLease::fail の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/memory.rs:208-239`)

タスク失敗時の処理ロジック：

1. **リトライ可否の判定**
   - `record.attempts >= record.max_attempts` でリトライ上限をチェック
   - 上限到達 → `mark_dead()` で Dead 状態に遷移
   - 上限未達 → リトライスケジュール

2. **バックオフ付きリトライ**
   - `retry_policy.next_delay(attempts)` でバックオフ時間を計算
   - `schedule_retry()` で RetryScheduled 状態に遷移
   - `BinaryHeap` (scheduled queue) に次回実行時刻を登録

3. **非同期安全性の実践**
   ```rust
   let should_notify = {
       let mut state = self.queue.lock().await;
       // ... 状態更新 ...
   }; // ← ロックをここで解放

   // ロック外で notify（デッドロック回避）
   if should_notify {
       self.notify.notify_one();
   }
   ```

**学んだポイント**
- **所有権の活用**: `should_notify` をスコープ外に持ち出してロック解放後に使用
- **状態遷移の明確化**: Dead と RetryScheduled を明確に区別
- **非同期のベストプラクティス**: ロック保持時間を最小化し、通知は外で実行

---

### 6. Clippy 警告の修正（完了）

**警告内容** (`clippy::collapsible_if`)

ネストした if 文を1つにまとめられるという指摘。

**修正前** (`memory.rs:83-87`)
```rust
if let Some(record) = self.records.get_mut(&entry.task_id) {
    if record.state == TaskState::RetryScheduled {
        record.requeue();
        self.ready.push_back(entry.task_id);
    }
}
```

**修正後**
```rust
if let Some(record) = self.records.get_mut(&entry.task_id)
    && record.state == TaskState::RetryScheduled
{
    record.requeue();
    self.ready.push_back(entry.task_id);
}
```

**学んだポイント**
- **let-chain**: Rust 2021 edition の機能で、`if let` と条件を `&&` で連結可能
- **可読性の向上**: ネストを減らし、条件の並列性を明確化
- **短絡評価**: 左から順に評価され、false になれば以降は評価されない
- **clippy の活用**: コード品質を保つためのツールとして活用

---

### 7. ADR の作成（完了）

Phase 1 実装の主要な設計判断を ADR として文書化：

**作成した ADR:**

1. **ADR-0001**: TaskId のみを保持する3つのデータ構造分離
   - `dev/docs/adr/0001-task-id-only-queue-design.md`
   - Single Source of Truth パターン
   - 所有権の明確化とパフォーマンスのバランス

2. **ADR-0002**: TaskRecord への状態遷移の集約
   - `dev/docs/adr/0002-state-transitions-in-taskrecord.md`
   - カプセル化と不変条件の保護
   - 状態遷移の明示化

3. **ADR-0003**: ロック外での notify による非同期安全性
   - `dev/docs/adr/0003-notify-outside-lock.md`
   - デッドロック回避とロック最小化
   - スコープによるロック制御パターン

4. **ADR-0004**: tokio::select! による複数イベント待機
   - `dev/docs/adr/0004-tokio-select-for-multiple-events.md`
   - 効率的なイベント待機
   - レイテンシ最小化と CPU 効率化

**学んだポイント**
- **設計判断の記録の重要性**: 「なぜこうしたのか」を残すことで、将来の変更時に判断材料になる
- **代替案の検討**: 採用した案だけでなく、検討した他の案も記録することで思考プロセスが可視化される
- **トレードオフの明示**: すべての設計には長所と短所があり、それを明確にすることが重要

---

## 🎓 全体として学んだこと

### Rust の所有権・ライフタイム
- TaskId のみを保持し、TaskRecord への参照を避ける設計
- Arc/Mutex による共有可変状態の管理
- スコープを活用したロック解放の制御

### 非同期プログラミング（Tokio）
- ロック保持中に `.await` しない原則の実践
- `tokio::select!` による複数イベント待機
- `Notify` を使った効率的なワーカー通知

### 関数型プログラミング
- enum による代数的データ型と網羅性チェック
- RetryPolicy の純粋関数としての実装
- 副作用（状態遷移）と判断ロジック（バックオフ計算）の分離

### データ構造の選択
- VecDeque: FIFO キュー（ready queue）
- BinaryHeap: 優先度付きキュー（scheduled queue）
- HashMap: 効率的な ID → レコード検索

---

---

---

## 📅 本日の実装記録（2025-12-29）

### 1. TaskRecord への job_id フィールド追加（完了） ✅

**実装内容** (`crates/weaver-core/src/queue/record.rs`)

Task と Job の連携を実現：

1. **job_id フィールドの追加**
   ```rust
   pub struct TaskRecord {
       pub envelope: TaskEnvelope,
       pub state: TaskState,
       pub job_id: Option<JobId>,  // ← 追加
       // ...
   }
   ```

2. **後方互換性の保持**
   - `new()` のシグネチャは変更せず
   - デフォルトで `job_id = None`
   - 既存コード（Phase 1）がそのまま動作

3. **Job 付きコンストラクタの追加**
   ```rust
   pub fn new_with_job(envelope: TaskEnvelope, max_attempts: u32, job_id: JobId) -> Self
   ```
   - `new()` を再利用（DRY 原則）
   - job_id のみを追加設定

**学んだポイント**
- **Option<T> による段階的移行**: 既存機能を壊さずに新機能を追加
- **フィールド配置の判断**: state の近くに配置し、論理的なグループ化
- **コンストラクタパターン**: 共通ロジックを再利用し、差分だけを実装

---

### 2. JobManager の実装（完了） ✅

**実装内容** (`crates/weaver-core/src/queue/memory.rs`)

InMemoryQueueState に Job 管理機能を追加：

1. **データ構造の追加**
   ```rust
   struct InMemoryQueueState {
       jobs: HashMap<JobId, JobRecord>,      // Job の Single Source of Truth
       records: HashMap<TaskId, TaskRecord>, // Task の Single Source of Truth
       next_job_id: u64,                     // Job ID カウンター
       next_task_id: u64,                    // Task ID カウンター (renamed)
       // ...
   }
   ```

2. **ID 採番ロジック** ✅（自分で実装）
   ```rust
   fn allocate_job_id(&mut self) -> JobId {
       let id = JobId::new(self.next_job_id);
       self.next_job_id += 1;
       id
   }
   ```
   - Phase 1 の `allocate_task_id` と同じパターン
   - newtype により型安全性を確保

3. **Job 作成メソッド** ✅（自分で実装）
   ```rust
   fn create_job(&mut self, spec: JobSpec) -> JobId {
       let id = self.allocate_job_id();
       let job_record = JobRecord::new(id, spec);
       self.jobs.insert(id, job_record);
       id
   }
   ```
   - 採番 → 作成 → 挿入 → 返却の流れ

4. **Job 取得メソッド** ✅（自分で実装）
   ```rust
   fn get_job(&self, job_id: JobId) -> Option<&JobRecord>
   fn get_job_mut(&mut self, job_id: JobId) -> Option<&mut JobRecord>
   ```
   - シンプルな HashMap lookup

**学んだポイント**
- **パターンの再利用**: Phase 1（Task）のパターンを Phase 2（Job）に適用
- **対称性**: allocate_job_id と allocate_task_id の構造的な類似性
- **ADR-0001 の適用**: Single Source of Truth を Job にも適用
- **型安全性**: newtype により JobId と TaskId の混同を防ぐ

**次のステップ:**
- ~~Job と Task の連携（Job から Task を作成）~~ ✅ 完了
- submit_job API の実装（外部インターフェース）

---

### 3. Job から Task を作成する機能（完了） ✅

**実装内容** (`crates/weaver-core/src/queue/memory.rs:140-160`)

Job と Task の実際の連携を実現：

**create_job_with_tasks メソッド** ✅（自分で実装）
```rust
fn create_job_with_tasks(&mut self, spec: JobSpec) -> JobId {
    let job_id = self.create_job(spec.clone());
    let max_attempts = spec.budget.max_attempts_per_task;
    for task_spec in &spec.tasks {
        let task_id = self.allocate_task_id();
        // TaskSpec → TaskEnvelope 変換
        // TaskRecord 作成（new_with_job 使用）
        // HashMap + ready queue に登録
        // Job に task_id を追加
    }
    job_id
}
```

**実装のポイント:**
1. **Job 作成**: create_job で Job を先に作成
2. **ループで Task 作成**: 各 TaskSpec を処理
   - TaskSpec.title → TaskType（"generic" がデフォルト）
   - TaskSpec 全体 → payload（JSON 変換）
   - TaskRecord::new_with_job で job_id を設定
3. **双方向関連付け**:
   - TaskRecord に job_id（new_with_job で設定）
   - JobRecord に task_ids（add_task で追加）
4. **キューへの登録**: ready.push_back で即座に実行可能に

**学んだポイント**
- **パターンの統合**: Phase 1 と Phase 2 のすべてのパターンを1つのメソッドで統合
- **ループ内での状態更新**: 各反復で Job を更新する設計
- **v1 の柔軟性**: unwrap_or で欠損値に対応
- **双方向関連の実装**: 参照整合性を手動で管理（job_id ⇄ task_ids）

**次のステップ:**
- ~~submit_job API の実装（InMemoryQueue に public メソッド追加）~~ ✅ 完了
- Job のステータス更新ロジック（Task 完了時に Job 状態を更新）

---

### 4. submit_job API の実装（完了） ✅

**実装内容** (`crates/weaver-core/src/queue/memory.rs:240-249`)

外部公開 API の完成：

**submit_job メソッド** ✅（自分で実装）
```rust
pub async fn submit_job(&self, spec: JobSpec) -> Result<JobId, WeaverError> {
    let job_id = {
        let mut state = self.state.lock().await;
        state.create_job_with_tasks(spec)
    };
    self.notify.notify_one();
    Ok(job_id)
}
```

**実装のポイント:**
1. **スコープでロック制御**:
   - ブロック内でロック取得・処理
   - ブロック終了で自動解放
   - drop() を明示的に書かなくても安全

2. **ADR-0003 の適用**:
   - ロック外で notify_one()
   - Worker の並行性を最大化

3. **シンプルさ**:
   - create_job_with_tasks が ready queue 登録まで処理
   - API は薄いラッパーに徹する

**学んだポイント**
- **Public API の設計**: 外部インターフェースはシンプルに
- **内部実装の再利用**: create_job_with_tasks を呼ぶだけ
- **パターンの一貫性**: enqueue() と同じ構造
- **ADR-0003 の完璧な適用**: Phase 1 から Phase 2 まで一貫したパターン

---

## 🎉 Phase 2: Job-level Abstraction 完成！

✅ **完了した機能:**
1. JobRecord + JobState（状態管理）
2. TaskRecord への job_id 追加（連携基盤）
3. JobManager（CRUD 操作）
4. create_job_with_tasks（Job ⇄ Task 完全連携）
5. **submit_job API**（外部インターフェース）

🎓 **Phase 2 で学んだこと:**
- 状態集約パターン（複数状態 → 単一状態）
- Option<T> による段階的移行
- Phase 1 パターンの再利用と拡張
- 双方向関連の実装と管理
- パターンの統合（ID 採番、CRUD、ロック制御、notify）
- Public API の設計原則

**次のフェーズ候補:**
- Phase 3: Attempt/Decision 記録（実行履歴）
- Phase 5: 依存関係管理
- Phase 6: Budget と Stuck 検知
- Phase 7: 残りの API（get_status, cancel_job, get_result）

---

### 8. Phase 2: Job-level Abstraction の開始（昨日から継続）

**実装内容** (`crates/weaver-core/src/domain/job.rs`)

Job の状態管理構造を作成：

1. **JobState enum の定義**
   - Running, Completed, Failed, Cancelled の4状態
   - Task 状態の集約結果を表現

2. **JobRecord 構造体**
   - Job の Single Source of Truth
   - task_ids で複数 Task を管理
   - update_state_from_tasks で状態集約

3. **状態集約ロジックの実装** ✅（自分で実装）
   ```rust
   pub fn update_state_from_tasks(&mut self, task_states: &[(TaskId, TaskState)]) {
       // 複数の Task 状態から Job 状態を導出
   }
   ```

   **判定ロジック:**
   - すべて Succeeded → Completed
   - いずれか Running/Queued/RetryScheduled → Running
   - すべて terminal で Dead 含む → Failed
   - 空の場合 → Running (初期状態)

4. **包括的なテスト** ✅（8つのテストケース）
   - rstest を使った parameterized テスト
   - エッジケース（空のタスクリスト）もカバー

**学んだポイント**
- **状態集約パターン**: 複数の状態から1つの状態を導出する高レベル抽象化
- **Early exit の活用**: `all()`, `any()` による効率的判定
- **優先順位の明確化**: if-else チェーンの順序が重要
- **Phase 1 パターンの再利用**: ADR-0001, ADR-0002 の原則を Job レベルに適用

**次のステップ:**
- JobManager の実装（Job の CRUD 操作）
- Task と Job の連携（Task に job_id を追加）
- submit_job API の実装

---

## 🎯 次回の実装予定

Phase 2（Job-level Abstraction）を継続。

### 推奨実装順序

1. **JobRecord + Job管理**: Job 単位での追跡を可能に
2. **Attempt/Decision**: 履歴記録の基盤を整備
3. **依存関係**: タスクの順序制御を実装
4. **分解**: 複雑なタスクの自動分割
5. **Budget/Stuck**: 終了条件の実装
6. **API**: 外部インターフェースの整備
7. **Artifact**: 成果物の記録

---

## 📚 参考資料

- 要件: `dev/docs/requirements/2025_12_27_weaver_requirements.md`
- 成功条件: 要件ドキュメントの「12. v1 の成功条件」セクション
- アーキテクチャ: `CLAUDE.md`
