# å®Ÿè£…è¨˜éŒ² - 2026/01/02

Phase 4-1 (Handler â†’ Outcome â†’ Decider ãƒ•ãƒ­ãƒ¼çµ±åˆ) ã®æœ€çµ‚ã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

**ã‚¿ã‚¹ã‚¯ä¸€è¦§**: å…¨ä½“ã®ã‚¿ã‚¹ã‚¯ã¨é€²æ—ã¯ `tasks.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ“ Phase 4-1 ã®ç›®æ¨™

Handler â†’ Outcome â†’ Decider â†’ Decision ãƒ•ãƒ­ãƒ¼ã‚’ weaver å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³ã«çµ±åˆã™ã‚‹ã€‚

**Phase 4-1 ã®é€²æ—çŠ¶æ³:**
- âœ… Step 1: TaskLease Interface ã®æ‹¡å¼µ
- âœ… Step 2: Handler Trait ã®å¤‰æ›´
- âœ… Step 3: Decider ã‚’ Worker ã«çµ±åˆ
- âœ… Step 4: Worker Loop Flow
- âœ… Step 5: get_task_record() ã®å®Ÿè£…
- âœ… Step 6: complete() å®Ÿè£…
- âœ… Step 6.5: complete() ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
- ğŸ”œ **Step 7: Handler æ›´æ–°ï¼ˆä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯ï¼‰**
- ğŸ”œ Step 8: çµ±åˆãƒ†ã‚¹ãƒˆ
- ğŸ”œ Step 9: CLI example ã®å‹•ä½œç¢ºèª
- ğŸ”œ Step 10: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²

### Step 7: CLI ã® HelloHandler ã‚’æ–°ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ›´æ–°

**ç›®çš„**: HelloHandler ã‚’ Phase 4-1 ã®æ–°ã—ã„ãƒ•ãƒ­ãƒ¼ï¼ˆ`Result<Outcome, WeaverError>`ï¼‰ã«é©åˆã•ã›ã‚‹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-cli/src/main.rs`

**å¤‰æ›´å†…å®¹:**

1. **imports ã®è¿½åŠ **:
   - `DefaultDecider` ã¨ `Outcome` ã‚’è¿½åŠ 

2. **HelloHandler::handle() ã®æ›´æ–°**:
   - æˆ»ã‚Šå€¤ã‚’ `Result<(), WeaverError>` ã‹ã‚‰ `Result<Outcome, WeaverError>` ã«å¤‰æ›´
   - æˆåŠŸæ™‚: `Ok(Outcome::success())` ã‚’è¿”ã™
   - æ„å›³çš„ãªå¤±æ•—: `Ok(Outcome::failure(reason))` ã‚’è¿”ã™ï¼ˆã‚¨ãƒ©ãƒ¼ã§ã¯ãªããƒ“ã‚¸ãƒã‚¹çµæœï¼‰
   - ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼: `Err(WeaverError)` ã®ã¾ã¾ï¼ˆJSON decode å¤±æ•—ãªã©ï¼‰

3. **main é–¢æ•°ã®æ›´æ–°**:
   - `DefaultDecider` ã‚’ä½œæˆ
   - `WorkerGroup::spawn()` ã« decider ã‚’æ¸¡ã™ï¼ˆ4ã¤ç›®ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰

**è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆ:**

#### ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¨ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ã®åŒºåˆ¥

ã“ã‚Œã¯ Phase 4-1 ã®æ ¸å¿ƒçš„ãªè¨­è¨ˆæ±ºå®šã§ã™:

| çŠ¶æ³ | æˆ»ã‚Šå€¤ | æ„å‘³ |
|------|--------|------|
| JSON decode å¤±æ•— | `Err(WeaverError)` | ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ï¼ˆå®Ÿè¡Œã§ããªã‹ã£ãŸï¼‰ |
| æ„å›³çš„ãªå¤±æ•—ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰ | `Ok(Outcome::failure(reason))` | ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ï¼ˆå®Ÿè¡Œã—ãŸãŒå¤±æ•—ï¼‰ |
| æˆåŠŸ | `Ok(Outcome::success())` | æˆåŠŸï¼ˆå®Ÿè¡Œã—ã¦æˆåŠŸï¼‰ |

**ãªãœã“ã®åŒºåˆ¥ãŒé‡è¦ã‹ï¼Ÿ**

1. **ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥ã®é•ã„**:
   - ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼: Worker ãŒ `Outcome::failure()` ã«å¤‰æ›ã—ã¦ Decider ã¸
   - ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼: ç›´æ¥ Decider ãŒåˆ¤æ–­

2. **è¦³æ¸¬å¯èƒ½æ€§**:
   - Outcome ã«ã¯ `reason`, `artifacts`, `retry_hint` ã‚’å«ã‚ã‚‰ã‚Œã‚‹
   - ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¯ WeaverError ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿

3. **æ‹¡å¼µæ€§**:
   - ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ã«ã¯ä»£æ›¿æ¡ˆï¼ˆ`alternatives`ï¼‰ã‚’ææ¡ˆã§ãã‚‹
   - ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¯å˜ç´”ãªãƒªãƒˆãƒ©ã‚¤ã®ã¿

---

### âœ… Step 7 å®Ÿè£…å®Œäº†

**å®Ÿè£…å†…å®¹:**

1. **HelloHandler::handle()** (line 33-48):
   ```rust
   async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError> {
       let p: HelloPayload = serde_json::from_value(envelope.payload().clone())
           .map_err(|e| WeaverError::Other(format!("json decode: {e}")))?;

       let left = self.remaining_failures.load(Ordering::Relaxed);
       if left > 0 {
           self.remaining_failures.fetch_sub(1, Ordering::Relaxed);
           return Ok(Outcome::failure(format!(
               "intentional failure (left={left})"
           )));
       }

       println!("âœ“ Hello, {}!", p.name);
       Ok(Outcome::success())
   }
   ```

2. **main é–¢æ•°** (line 64-67):
   ```rust
   let default_decider = Arc::new(DefaultDecider::default_v1());
   let workers = WorkerGroup::spawn(1, queue.clone(), runtime.clone(), default_decider);
   ```

**å‹•ä½œç¢ºèª:**

```
$ cargo run -p weaver-cli
=== Weaver CLI Example ===

ğŸ“¤ Enqueued task: task-1
ğŸ“Š State counts: queued=0, running=1, succeeded=0, retry_scheduled=0, dead=0
ğŸ“Š State counts: queued=0, running=0, succeeded=0, retry_scheduled=1, dead=0
[ç´„2ç§’å¾…æ©Ÿ - 1å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤]
[ç´„2ç§’å¾…æ©Ÿ - 2å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤]
âœ“ Hello, Weaver!
ğŸ“Š State counts: queued=0, running=0, succeeded=1, retry_scheduled=0, dead=0

âœ… Task completed!
   Result: SUCCESS
```

**ãƒ•ãƒ­ãƒ¼ã®ç¢ºèª:**
1. âœ… æœ€åˆã®å®Ÿè¡Œ: Outcome::failure â†’ Decider â†’ Decision::Retry â†’ retry_scheduled
2. âœ… 2å›ç›®ã®å®Ÿè¡Œ: Outcome::failure â†’ Decider â†’ Decision::Retry â†’ retry_scheduled
3. âœ… 3å›ç›®ã®å®Ÿè¡Œ: Outcome::success â†’ lease.ack() â†’ succeeded

**é‡è¦ãªå­¦ã³:**
- æ„å›³çš„ãªå¤±æ•—ã‚’ `Ok(Outcome::failure())` ã§è¿”ã™ã“ã¨ã§ã€Handler ãŒå®Ÿè¡Œçµæœã‚’è¦³æ¸¬ãƒ»å ±å‘Šã™ã‚‹è²¬å‹™ã‚’æœãŸã™
- Worker ã¯ Outcome ã‚’å—ã‘å–ã‚Šã€Decider ã‚’å‘¼ã‚“ã§æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ±ºå®š
- ãƒªãƒˆãƒ©ã‚¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã¯ complete() ãŒæ‹…å½“ï¼ˆADR-0003æº–æ‹ ï¼‰

---

## ğŸ“ å­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼ˆå®Œäº†ï¼‰

### TODO(human) ã®å ´æ‰€

1. **HelloHandler::handle()**: `crates/weaver-cli/src/main.rs` ã® 34-52 è¡Œç›®
2. **main é–¢æ•°**: `crates/weaver-cli/src/main.rs` ã® 68-73 è¡Œç›®

### å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆ

#### HelloHandler::handle() ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

```rust
async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError> {
    // Step 1: Payload decode (infrastructure error)
    let p: HelloPayload = serde_json::from_value(envelope.payload().clone())
        .map_err(|e| WeaverError::Other(format!("json decode: {e}")))?;
    // â†‘ ã“ã‚Œã¯ Err(WeaverError) ã‚’è¿”ã™ï¼ˆã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ï¼‰

    // Step 2: Business logic (business error)
    let left = self.remaining_failures.load(Ordering::Relaxed);
    if left > 0 {
        self.remaining_failures.fetch_sub(1, Ordering::Relaxed);
        // ã“ã“ã§ Outcome::failure() ã‚’è¿”ã™ï¼ˆãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ï¼‰
        return Ok(Outcome::failure(format!("intentional failure (left={left})")));
    }

    // Step 3: Success
    println!("âœ“ Hello, {}!", p.name);
    Ok(Outcome::success())
}
```

#### main é–¢æ•°ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

```rust
// Decider ã‚’ä½œæˆ
let decider = Arc::new(DefaultDecider::default_v1());

// WorkerGroup::spawn() ã«æ¸¡ã™
let workers = WorkerGroup::spawn(1, queue.clone(), runtime.clone(), decider);
```

---

## ğŸ”‘ è¨­è¨ˆã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆ

### 1. Handler ã®è²¬å‹™: å®Ÿè¡Œ + è¦³æ¸¬

Handler ã¯2ã¤ã®è²¬å‹™ã‚’æŒã¡ã¾ã™:

1. **å®Ÿè¡Œ**: ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹
2. **è¦³æ¸¬**: å®Ÿè¡Œçµæœã‚’ Outcome ã¨ã—ã¦è¿”ã™

**Outcome ã«å«ã‚ã‚‹ã¹ãæƒ…å ±:**
- `kind`: SUCCESS / FAILURE / BLOCKED
- `reason`: ä½•ãŒèµ·ããŸã‹ï¼ˆå¤±æ•—ç†ç”±ã€æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã©ï¼‰
- `artifacts`: è¦³æ¸¬ã•ã‚ŒãŸæˆæœç‰©ï¼ˆstdout, stderr, ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãªã©ï¼‰
- `retry_hint`: ãƒªãƒˆãƒ©ã‚¤ã®ãƒ’ãƒ³ãƒˆï¼ˆæ¨å¥¨é…å»¶æ™‚é–“ãªã©ï¼‰
- `alternatives`: ä»£æ›¿ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆåˆ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ææ¡ˆï¼‰

### 2. Worker ã®è²¬å‹™: ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

Worker ã¯ä»¥ä¸‹ã®æµã‚Œã‚’åˆ¶å¾¡ã—ã¾ã™:

```
1. Handler ã‚’å®Ÿè¡Œ â†’ Outcome ã‚’å–å¾—
2. Outcome.kind ã‚’ãƒã‚§ãƒƒã‚¯:
   - SUCCESS â†’ lease.ack() (Decider ä¸è¦)
   - FAILURE/BLOCKED â†’ Decider ã‚’å‘¼ã¶
3. Decider ãŒ Decision ã‚’è¿”ã™:
   - Decision::Retry â†’ lease.complete(outcome, decision)
   - Decision::MarkDead â†’ lease.complete(outcome, decision)
```

### 3. Decider ã®è²¬å‹™: åˆ¤æ–­

Decider ã¯ç´”ç²‹é–¢æ•°ã§ã™:

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision
```

**å…¥åŠ›:**
- `task`: ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ï¼ˆattempts, max_attempts ãªã©ï¼‰
- `outcome`: æœ€æ–°ã®å®Ÿè¡Œçµæœ

**å‡ºåŠ›:**
- `Decision::Retry { delay, reason }`: ãƒªãƒˆãƒ©ã‚¤ã™ã‚‹
- `Decision::MarkDead { reason }`: è«¦ã‚ã‚‹

**ç´”ç²‹é–¢æ•°ã®åˆ©ç‚¹:**
- ãƒ†ã‚¹ãƒˆã—ã‚„ã™ã„
- å‰¯ä½œç”¨ãŒãªã„ï¼ˆçŠ¶æ…‹å¤‰æ›´ã¯ Worker/TaskLease ãŒæ‹…å½“ï¼‰
- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã‚„ã™ã„ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç‹¬è‡ªã® Decider ã‚’å®Ÿè£…å¯èƒ½ï¼‰

---

## ğŸ“Š å®Ÿè£…ã®é€²æ—

**Phase 4-1 å…¨ä½“ã®é€²æ—: 70% â†’ 95%**

- âœ… Step 1-7: å®Œäº†
- âœ… Step 9: CLI å‹•ä½œç¢ºèªå®Œäº†ï¼ˆStep 7 ã§å®Ÿæ–½ï¼‰
- â³ Step 8: çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- â³ Step 10: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

**æ¨å®šæ®‹ã‚Šæ™‚é–“: 1 æ™‚é–“**
- Step 10: 1 æ™‚é–“ï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼‰

---

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

Step 7 å®Œäº†å¾Œã®æ®‹ã‚¿ã‚¹ã‚¯:

1. **Step 10: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°** - ADR-0005 ã‚’ "Accepted" ã«æ›´æ–°ã€learning è¨˜éŒ²ã®æœ€çµ‚æ›´æ–°
2. **ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰Step 8: çµ±åˆãƒ†ã‚¹ãƒˆ** - ã‚ˆã‚Šè¤‡é›‘ãªã‚·ãƒŠãƒªã‚ªã®ãƒ†ã‚¹ãƒˆ

---

## ğŸ’¡ ä»Šæ—¥å­¦ã‚“ã ã“ã¨

### 1. ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¨ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ã®åŒºåˆ¥

ã“ã‚ŒãŒ Phase 4-1 ã®æœ€ã‚‚é‡è¦ãªå­¦ã³ã§ã—ãŸ:

- **ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼** (`Err(WeaverError)`): å®Ÿè¡Œã§ããªã‹ã£ãŸï¼ˆJSON ãƒ‘ãƒ¼ã‚¹å¤±æ•—ãªã©ï¼‰
- **ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼** (`Ok(Outcome::failure())`): å®Ÿè¡Œã—ãŸãŒå¤±æ•—ã—ãŸ

æœ€åˆã®å®Ÿè£…ã§ã¯æ„å›³çš„ãªå¤±æ•—ã‚’ `Err(WeaverError)` ã§è¿”ã—ã¦ã„ã¾ã—ãŸãŒã€ã“ã‚Œã‚’ `Ok(Outcome::failure())` ã«ä¿®æ­£ã™ã‚‹ã“ã¨ã§ã€Handler ãŒå®Ÿè¡Œçµæœã‚’è¦³æ¸¬ãƒ»å ±å‘Šã™ã‚‹è²¬å‹™ã‚’æ­£ã—ãæœãŸã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

### 2. Handler â†’ Outcome â†’ Decider â†’ Decision ãƒ•ãƒ­ãƒ¼ã®å®Ÿå‹•ä½œ

CLI ã‚’å®Ÿè¡Œã—ã¦ã€ä»¥ä¸‹ã®ãƒ•ãƒ­ãƒ¼ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã—ãŸ:

1. Handler ãŒ `Outcome::failure()` ã‚’è¿”ã™
2. Worker ãŒ Decider ã‚’å‘¼ã¶
3. Decider ãŒ `Decision::Retry` ã‚’è¿”ã™
4. `complete()` ãŒãƒªãƒˆãƒ©ã‚¤ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
5. 2ç§’å¾Œã«å†å®Ÿè¡Œï¼ˆexponential backoffï¼‰
6. 3å›ç›®ã§æˆåŠŸ

### 3. ç´”ç²‹é–¢æ•°ã¨å‰¯ä½œç”¨ã®åˆ†é›¢ã®å®Ÿè·µ

- **Decider**: ç´”ç²‹é–¢æ•°ï¼ˆçŠ¶æ…‹ã‚’è¦‹ã¦åˆ¤æ–­ã‚’è¿”ã™ã ã‘ï¼‰
- **Worker/TaskLease**: å‰¯ä½œç”¨ï¼ˆåˆ¤æ–­ã‚’å®Ÿè¡Œã—ã¦çŠ¶æ…‹ã‚’å¤‰æ›´ï¼‰

ã“ã®åˆ†é›¢ã«ã‚ˆã‚Šã€åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆã‚„ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ’¡ å‚è€ƒè³‡æ–™

### ADRï¼ˆArchitecture Decision Recordsï¼‰

- **ADR-0005**: Decider ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
  - ãƒ•ã‚¡ã‚¤ãƒ«: `dev/docs/adr/0005-decider-architecture.md`
  - å†…å®¹: Handler ã®æˆ»ã‚Šå€¤ã€Decider ã®è²¬å‹™ã€Worker ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### å®Ÿè£…æ¸ˆã¿ã‚³ãƒ¼ãƒ‰ï¼ˆå‚è€ƒï¼‰

- **Outcome ã® convenience methods**: `crates/weaver-core/src/domain/outcome.rs`
  - `Outcome::success()`: 71-79 è¡Œç›®
  - `Outcome::failure(reason)`: 81-89 è¡Œç›®
  - `Outcome::blocked(reason)`: 91-99 è¡Œç›®

- **DefaultDecider ã®å®Ÿè£…**: `crates/weaver-core/src/domain/decision.rs`
  - `DefaultDecider::default_v1()`: 69-72 è¡Œç›®
  - `decide()` ãƒ­ã‚¸ãƒƒã‚¯: 75-97 è¡Œç›®

- **Worker Loop Flow**: `crates/weaver-core/src/worker.rs`
  - worker_loop() ã®å®Ÿè£…: 96-165 è¡Œç›®ï¼ˆStep 4 ã§å®Ÿè£…ï¼‰

---

## âœ… Step 7 å®Œäº†æ—¥

**å®Œäº†æ—¥**: 2026-01-02
**æ‰€è¦æ™‚é–“**: ç´„1æ™‚é–“
**å®Ÿè£…è€…**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰
**ãƒ¬ãƒ“ãƒ¥ãƒ¼**: Claudeï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ï¼‰

---

## âœ… Step 8 å®Œäº†: çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆClaude å®Ÿè£…ï¼‰

**å®Œäº†æ—¥**: 2026-01-02
**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/worker.rs` (ãƒ†ã‚¹ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ )

**å®Ÿè£…ã—ãŸãƒ†ã‚¹ãƒˆ:**

1. **test_worker_retry_flow_integration**: ãƒªãƒˆãƒ©ã‚¤ãƒ•ãƒ­ãƒ¼å…¨ä½“ã®çµ±åˆãƒ†ã‚¹ãƒˆ
   - Handler ãŒ 2å›å¤±æ•—ã€3å›ç›®ã§æˆåŠŸ
   - Outcome::failure â†’ Decider â†’ Decision::Retry ã®ãƒ•ãƒ­ãƒ¼ã‚’æ¤œè¨¼
   - AttemptRecord ãŒ3ã¤ä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

2. **test_worker_max_attempts_exceeded**: max_attempts è¶…éã®ãƒ†ã‚¹ãƒˆ
   - å¸¸ã«å¤±æ•—ã™ã‚‹ Handler ã§ max_attempts (5å›) è©¦è¡Œå¾Œã« Dead ã«ãªã‚‹ã“ã¨ã‚’æ¤œè¨¼
   - AttemptRecord ãŒ5ã¤ä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

3. **test_worker_immediate_success**: å³åº§ã«æˆåŠŸã™ã‚‹ãƒ†ã‚¹ãƒˆ
   - ãƒªãƒˆãƒ©ã‚¤ãªã—ã§ SUCCESS ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ã‚’æ¤œè¨¼
   - AttemptRecord ãŒ1ã¤ã ã‘ä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

**ãƒ†ã‚¹ãƒˆçµæœ:**
```
test result: ok. 3 passed; 0 failed; 0 ignored
```

**å…¨ãƒ†ã‚¹ãƒˆçµæœ:**
```
test result: ok. 31 passed; 0 failed; 0 ignored
```

---

## âœ… Step 10 å®Œäº†: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆClaude å®Ÿè£…ï¼‰

**å®Œäº†æ—¥**: 2026-01-02
**æ›´æ–°ãƒ•ã‚¡ã‚¤ãƒ«**: `dev/docs/adr/0005-decider-architecture.md`

**æ›´æ–°å†…å®¹:**

1. **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´**: ã€Œææ¡ˆä¸­ (Proposed)ã€â†’ã€Œæ‰¿èªæ¸ˆã¿ (Accepted)ã€
2. **å®Ÿè£…å®Œäº†è¨˜éŒ²**: ææ¡ˆæ—¥ã€å®Ÿè£…é–‹å§‹æ—¥ã€å®Ÿè£…å®Œäº†æ—¥ã€æ‰¿èªæ—¥ã‚’è¿½åŠ 
3. **å®Ÿè£…è¨ˆç”»ã®æ›´æ–°**: Phase 4-1 ã®å…¨ã‚¹ãƒ†ãƒƒãƒ—ã‚’ âœ… ã«æ›´æ–°
4. **å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§**: å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªã‚¹ãƒˆåŒ–
5. **ãƒ†ã‚¹ãƒˆä¸€è¦§**: å®Ÿè£…ã—ãŸãƒ†ã‚¹ãƒˆã‚’è¨˜éŒ²
6. **å®Ÿè£…å±¥æ­´ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: ææ¡ˆã‹ã‚‰å®Ÿè£…å®Œäº†ã¾ã§ã®å±¥æ­´ã‚’è¿½åŠ 
7. **å®Ÿè£…ã§å¾—ã‚‰ã‚ŒãŸçŸ¥è¦‹**: ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¨ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ã®åŒºåˆ¥ã€Send + Sync åˆ¶ç´„ã€ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã®å‘ä¸Šã‚’è¨˜éŒ²

---

## ğŸ¯ Phase 4-1 å®Œäº†ï¼

**å®Œäº†æ—¥**: 2026-01-02
**å…¨ä½“ã®é€²æ—**: 100% å®Œäº† âœ…

**å®Œäº†ã—ãŸã‚¹ãƒ†ãƒƒãƒ—:**
- âœ… Step 1-7: å…¨å®Œäº†ï¼ˆå®Ÿè£…ã¨CLIå‹•ä½œç¢ºèªï¼‰
- âœ… Step 8: çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆClaude å®Ÿè£…ï¼‰
- âœ… Step 9: CLI å‹•ä½œç¢ºèªï¼ˆStep 7 ã§å®Ÿæ–½ï¼‰
- âœ… Step 10: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆClaude å®Ÿè£…ï¼‰

**æˆæœç‰©:**
- Handler â†’ Outcome â†’ Decider â†’ Decision ãƒ•ãƒ­ãƒ¼ã®å®Œå…¨å®Ÿè£…
- ç´”ç²‹é–¢æ•°ï¼ˆDeciderï¼‰ã¨å‰¯ä½œç”¨ï¼ˆWorker/TaskLeaseï¼‰ã®åˆ†é›¢
- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªåˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆDecider traitï¼‰
- å®Œå…¨ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ï¼ˆå˜ä½“ãƒ†ã‚¹ãƒˆ + çµ±åˆãƒ†ã‚¹ãƒˆï¼‰
- ADR-0005 ã®æ‰¿èªã¨è¨˜éŒ²

**æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4-2 ã§ã‚¿ã‚¹ã‚¯åˆ†è§£æ©Ÿèƒ½ï¼ˆDecision::Decomposeï¼‰ã‚’å®Ÿè£…äºˆå®š

---

**Phase 4-1 å®Ÿè£…å®Œäº†è¨˜éŒ²** - 2026-01-02

---
---

# Phase 4: ã‚¿ã‚¹ã‚¯åˆ†è§£ï¼ˆDecompositionï¼‰å®Ÿè£…é–‹å§‹ - 2026-01-02 (åˆå¾Œ)

## ğŸ“ Phase 4 ã®ç›®æ¨™

ã‚¿ã‚¹ã‚¯ãŒæŠ½è±¡çš„/å·¨å¤§ã§ãã®ã¾ã¾å®Ÿè¡Œã§ããªã„å ´åˆã€å®Ÿè¡Œå¯èƒ½å˜ä½ã¸åˆ†è§£ã™ã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

**è¨­è¨ˆæ–¹é‡ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¤æ–­ï¼‰:**
- è¦ªã‚¿ã‚¹ã‚¯ã¯å­ã‚¿ã‚¹ã‚¯ã«ã€Œå¤‰åŒ–ã€ã™ã‚‹ï¼ˆåˆ†è§£æ™‚ç‚¹ã§å½¹å‰²ã‚’çµ‚ãˆã‚‹ï¼‰
- è¦ªã‚¿ã‚¹ã‚¯ã¯ `Decomposed` çŠ¶æ…‹ã«ãªã‚‹ï¼ˆæ–°ã—ã„çµ‚äº†çŠ¶æ…‹ï¼‰
- å­ã‚¿ã‚¹ã‚¯ã®æˆå¦ã¯è¦ªã‚¿ã‚¹ã‚¯ã«å½±éŸ¿ã—ãªã„ï¼ˆç‹¬ç«‹ï¼‰
- Handler ãŒåˆ†è§£ã‚’æ±ºå®šã—ã€Decider ãŒãã®ææ¡ˆã‚’å°Šé‡ã™ã‚‹

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²ï¼ˆPhase 4 å‰åŠï¼‰

### âœ… Step 1: TaskState ã« Decomposed ã‚’è¿½åŠ 

**ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/queue/state.rs`

**å¤‰æ›´å†…å®¹:**
1. `TaskState` enum ã« `Decomposed` variant ã‚’è¿½åŠ 
2. `is_terminal()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›´æ–°ï¼ˆ`Decomposed` ã‚’çµ‚äº†çŠ¶æ…‹ã¨ã—ã¦æ‰±ã†ï¼‰
3. çŠ¶æ…‹é·ç§»å›³ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°

**å®Ÿè£…:**
```rust
pub enum TaskState {
    Queued,
    Running,
    Succeeded,
    RetryScheduled,
    Dead,
    /// Decomposed into child tasks (task completed its role).
    Decomposed,
}

impl TaskState {
    pub fn is_terminal(self) -> bool {
        matches!(
            self,
            TaskState::Succeeded | TaskState::Decomposed | TaskState::Dead
        )
    }
}
```

**å­¦ã³:**
- Rust ã® exhaustive matching ã«ã‚ˆã‚Šã€æ–°ã—ã„ variant ã‚’è¿½åŠ ã™ã‚‹ã¨ã€ã™ã¹ã¦ã® `match` æ–‡ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹
- `QueueCounts` ã«ã‚‚ `decomposed: usize` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ
- `memory.rs` ã® `counts_by_state()` ã§ã‚‚ `Decomposed` ã®ã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ 

---

### âœ… Step 2: Decision enum ã« Decompose variant ã‚’è¿½åŠ 

**ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/domain/decision.rs`

**å¤‰æ›´å†…å®¹:**
1. `TaskSpec` ã® import ã‚’è¿½åŠ 
2. `Decision` enum ã« `Decompose` variant ã‚’è¿½åŠ 
3. `memory.rs` ã® `complete()` ã§ `Decompose` ã®ã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ ï¼ˆ`todo!()` ã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼‰

**å®Ÿè£…:**
```rust
use super::{spec::TaskSpec, Outcome};

pub enum Decision {
    Retry { delay: Duration, reason: String },
    MarkDead { reason: String },
    /// Decompose the task into child tasks.
    Decompose {
        child_tasks: Vec<TaskSpec>,
        reason: String,
    }
}
```

**å­¦ã³:**
- `Decision` ãŒ `#[derive(PartialEq)]` ã‚’ä½¿ã£ã¦ã„ã‚‹ãŸã‚ã€`TaskSpec` ã«ã‚‚ `PartialEq` ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ
- `spec.rs` ã§ `TaskSpec` ã« `#[derive(PartialEq)]` ã‚’è¿½åŠ 

---

### âœ… Step 3: Outcome ã« child_tasks ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 

**ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/domain/outcome.rs`

**å¤‰æ›´å†…å®¹:**
1. `TaskSpec` ã® import ã‚’è¿½åŠ 
2. `Outcome` æ§‹é€ ä½“ã« `child_tasks` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
3. `with_decompose_hint()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
4. convenience ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆ`success()`, `failure()`, `blocked()`ï¼‰ã‚’æ›´æ–°

**å®Ÿè£…:**
```rust
use super::spec::TaskSpec;

pub struct Outcome {
    pub kind: OutcomeKind,
    pub artifacts: Vec<Artifact>,
    pub reason: Option<String>,
    pub retry_hint: Option<serde_json::Value>,
    pub alternatives: Vec<serde_json::Value>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub child_tasks: Option<Vec<TaskSpec>>,
}

impl Outcome {
    pub fn with_decompose_hint(mut self, child_tasks: Vec<TaskSpec>) -> Self {
        self.child_tasks = Some(child_tasks);
        self
    }
}
```

**å­¦ã³:**
- serde ã® `#[serde(default, skip_serializing_if = "Option::is_none")]` ã«ã‚ˆã‚Šã€`None` ã®å ´åˆã¯ JSON ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚Œãªã„
- æ—¢å­˜ã® convenience ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚‚ `child_tasks: None` ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ

---

### âœ… Step 4: TaskRecord ã«è¦ªå­é–¢ä¿‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 

**ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/queue/record.rs`

**å¤‰æ›´å†…å®¹:**
1. `TaskId` ã® import ã‚’è¿½åŠ 
2. `TaskRecord` ã« `parent_task_id` ã¨ `child_task_ids` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
3. `new()` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§åˆæœŸåŒ–
4. `new_child()` ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 

**å®Ÿè£…:**
```rust
use crate::domain::{JobId, TaskEnvelope, TaskId};

pub struct TaskRecord {
    // æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰...

    // Parent and child task relationships.
    pub parent_task_id: Option<TaskId>,
    pub child_task_ids: Vec<TaskId>,
}

impl TaskRecord {
    pub fn new(envelope: TaskEnvelope, max_attempts: u32) -> Self {
        // ...
        Self {
            // ...
            parent_task_id: None,
            child_task_ids: Vec::new(),
        }
    }

    pub fn new_child(
        envelope: TaskEnvelope,
        max_attempts: u32,
        job_id: JobId,
        parent_task_id: TaskId,
    ) -> Self {
        let mut record = Self::new_with_job(envelope, max_attempts, job_id);
        record.parent_task_id = Some(parent_task_id);
        record
    }
}
```

**å­¦ã³:**
- `new_child()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¾Œã§å­ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã™ã‚‹ã¨ãã«ä¾¿åˆ©
- è¦ªå­é–¢ä¿‚ã®åŒæ–¹å‘ãƒªãƒ³ã‚¯ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒãƒƒã‚°ã‚„ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãŒå®¹æ˜“ã«ãªã‚‹

---

## ğŸ“ CLAUDE.md ã®æ›´æ–°

Learning Mode ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æ˜ç¢ºåŒ–ï¼š

**è¿½åŠ å†…å®¹:**
- **Learning Goals ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: Rust ã®å­¦ç¿’ç›®æ¨™ã‚’æ˜ç¢ºåŒ–
  - Async patterns, æ‰€æœ‰æ¨©/ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ , é–¢æ•°å‹ãƒ‘ã‚¿ãƒ¼ãƒ³, Lock ç®¡ç†, ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- **Learning Task Guidelines**: ã‚ˆã‚Šå¤§ããªã‚¿ã‚¹ã‚¯ï¼ˆ10-30 linesï¼‰ã‚’å„ªå…ˆã€è¤‡é›‘ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’å«ã‚ã‚‹
- **Language Preference**: æ—¥æœ¬èªã§å›ç­”ãƒ»è§£èª¬ã™ã‚‹ã“ã¨ã‚’æ˜è¨˜

---

## ğŸ“Š é€²æ—çŠ¶æ³

**Phase 4 å‰åŠï¼ˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æº–å‚™ï¼‰: 40% å®Œäº† âœ…**

- âœ… Step 1: TaskState ã« Decomposed ã‚’è¿½åŠ 
- âœ… Step 2: Decision enum ã« Decompose variant ã‚’è¿½åŠ 
- âœ… Step 3: Outcome ã« child_tasks ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
- âœ… Step 4: TaskRecord ã«è¦ªå­é–¢ä¿‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
- â³ Step 5-6: add_child_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ï¼ˆæ¬¡ã®ã‚¿ã‚¹ã‚¯ï¼‰

**æ®‹ã‚Šã®ã‚¹ãƒ†ãƒƒãƒ—:**
- Step 5-6: å­ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ï¼ˆ20%ï¼‰
- Step 7: Worker loop ã§ã®åˆ†è§£å‡¦ç†ï¼ˆ20%ï¼‰
- Step 8: Decider ã®æ›´æ–°ï¼ˆ10%ï¼‰
- Step 9-10: ãƒ†ã‚¹ãƒˆã¨å‹•ä½œç¢ºèªï¼ˆ10%ï¼‰

---

## ğŸ’¡ ä»Šæ—¥å­¦ã‚“ã ã“ã¨ï¼ˆPhase 4 å‰åŠï¼‰

### 1. è¨­è¨ˆåˆ¤æ–­ã®é‡è¦æ€§

Phase 4 ã®å®Ÿè£…ã‚’å§‹ã‚ã‚‹å‰ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨è¨­è¨ˆã‚’è­°è«–ã—ã¾ã—ãŸï¼š

- **è¦ªã‚¿ã‚¹ã‚¯ã¯åˆ†è§£æ™‚ç‚¹ã§å½¹å‰²ã‚’çµ‚ãˆã‚‹**: è¦ªãŒå­ã®å®Œäº†ã‚’å¾…ã¤å¿…è¦ãŒãªã„ãŸã‚ã€çŠ¶æ…‹ç®¡ç†ãŒã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚‹
- **Decomposed ã¨ã„ã†çµ‚äº†çŠ¶æ…‹**: ã€Œåˆ†è§£ã•ã‚ŒãŸã€ã¨ã„ã†æƒ…å ±ãŒæ˜ç¢ºã«æ®‹ã‚‹
- **Handler ä¸»å°ã®åˆ†è§£**: Handler ãŒå®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒã¤ãŸã‚ã€é©åˆ‡ãªåˆ¤æ–­ã‚’ä¸‹ã›ã‚‹

ã“ã®è¨­è¨ˆåˆ¤æ–­ã«ã‚ˆã‚Šã€å®Ÿè£…ãŒã‚·ãƒ³ãƒ—ãƒ«ã§ç†è§£ã—ã‚„ã™ããªã‚Šã¾ã—ãŸã€‚

### 2. Rust ã® exhaustive matching ã®å¨åŠ›

`TaskState` ã«æ–°ã—ã„ variant ã‚’è¿½åŠ ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒ `match` æ–‡ã§ã‚«ãƒãƒ¼ã•ã‚Œã¦ã„ãªã„ç®‡æ‰€ã‚’å…¨ã¦æ¤œå‡ºã—ã¦ãã‚Œã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šï¼š

- ãƒã‚°ã®é˜²æ­¢: æ–°ã—ã„çŠ¶æ…‹ã‚’å‡¦ç†ã—å¿˜ã‚Œã‚‹ç®‡æ‰€ãŒå®Œå…¨ã«æ’é™¤ã•ã‚Œã‚‹
- ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®‰å…¨æ€§: çŠ¶æ…‹ã‚’è¿½åŠ ãƒ»å¤‰æ›´ã—ã¦ã‚‚ã€å½±éŸ¿ç®‡æ‰€ã‚’æ¼ã‚ŒãªãæŠŠæ¡ã§ãã‚‹
- ä¿å®ˆæ€§ã®å‘ä¸Š: å°†æ¥ã®é–‹ç™ºè€…ãŒçŠ¶æ…‹ã‚’è¿½åŠ ã™ã‚‹ã¨ãã€å¿…è¦ãªå¤‰æ›´ç®‡æ‰€ãŒæ˜ç¢ºã«ãªã‚‹

### 3. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‘½åã®é¸æŠ

`decompose_hint` vs `child_tasks` ã¨ã„ã†å‘½åã‚’æ¤œè¨ã—ã¾ã—ãŸã€‚`child_tasks` ã‚’é¸æŠã—ãŸã®ã¯ï¼š

- å…·ä½“æ€§: "hint" ã‚ˆã‚Šã‚‚ "child_tasks" ã®æ–¹ãŒã€å®Ÿéš›ã®å†…å®¹ã‚’æ˜ç¢ºã«è¡¨ç¾
- å‹ã¨ã®ä¸€è‡´: `Vec<TaskSpec>` ã¨ã„ã†å‹ã¨åå‰ãŒè‡ªç„¶ã«å¯¾å¿œ
- ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§: `outcome.child_tasks` ã¯ç›´æ„Ÿçš„ã«ç†è§£ã—ã‚„ã™ã„

---

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

**Step 5-6: add_child_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ï¼ˆç¾åœ¨é€²è¡Œä¸­ï¼‰**

ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€Phase 4 ã®ä¸­ã§æœ€ã‚‚è¤‡é›‘ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’å«ã¿ã¾ã™ï¼š

- æ‰€æœ‰æ¨©ã¨ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 
- Async/await ãƒ‘ã‚¿ãƒ¼ãƒ³
- Lock ç®¡ç†ï¼ˆADR-0003 æº–æ‹ ï¼‰
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ Aï¼ˆã‚ˆã‚ŠæŒ‘æˆ¦çš„ï¼‰
- è¦ä»¶ã¨ã‚´ãƒ¼ãƒ«ã ã‘ã‚’ä¼ãˆã‚‹
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿè£…æ–¹é‡ã‚’è€ƒãˆã€è³ªå•ãŒã‚ã‚Œã°ç­”ãˆã‚‹
- å®Ÿè£…å¾Œã«ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

---

**Phase 4 å‰åŠå®Œäº†** - 2026-01-02

---
---

## â³ Step 5-6: add_child_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

ã‚¿ã‚¹ã‚¯åˆ†è§£æ©Ÿèƒ½ã®ä¸­æ ¸ã¨ãªã‚‹ `add_child_tasks()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€è¦ªã‚¿ã‚¹ã‚¯ã‚’å­ã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã™ã‚‹ã¨ãã«å‘¼ã°ã‚Œã€Queue ã«å­ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã™ã‚‹å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚

### ğŸ¯ å­¦ç¿’ç›®æ¨™

ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã® Rust ã®æ¦‚å¿µã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ï¼š

1. **æ‰€æœ‰æ¨©ã¨ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ **
   - `Vec<TaskSpec>` ã®æ‰€æœ‰æ¨©ã®ç§»å‹•
   - `Arc<Mutex<T>>` ã‚’ä½¿ã£ãŸå…±æœ‰çŠ¶æ…‹ã®ç®¡ç†
   - Clone ã¨æ‰€æœ‰æ¨©ã®é–¢ä¿‚

2. **Async/await ãƒ‘ã‚¿ãƒ¼ãƒ³**
   - `async fn` ã®å®Ÿè£…
   - `.await` ã®é©åˆ‡ãªé…ç½®
   - éåŒæœŸé–¢æ•°ã®æˆ»ã‚Šå€¤ï¼ˆ`Result<T, E>`ï¼‰

3. **Lock ç®¡ç†ï¼ˆADR-0003 æº–æ‹ ï¼‰**
   - `Mutex::lock().await` ã®ä½¿ã„æ–¹
   - Lock ã®ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†ï¼ˆæ—©æœŸè§£æ”¾ï¼‰
   - Lock ã‚’æŒã£ãŸã¾ã¾ `.await` ã—ãªã„ï¼ˆé‡è¦ï¼ï¼‰

4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**
   - `Result<Vec<TaskId>, WeaverError>` ã®è¿”å´
   - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä½œæˆ
   - `?` æ¼”ç®—å­ã®ä½¿ç”¨

5. **ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æ“ä½œ**
   - `HashMap` ã¸ã®æŒ¿å…¥
   - `VecDeque` ã¸ã®è¿½åŠ 
   - `Vec` ã®æ“ä½œï¼ˆpush, iterationï¼‰

### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**å¤‰æ›´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:**

1. **`crates/weaver-core/src/queue/mod.rs`**
   - TaskLease trait ã« `add_child_tasks()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£ã‚’è¿½åŠ 

2. **`crates/weaver-core/src/queue/memory.rs`**
   - InMemoryLease ã« `add_child_tasks()` ã®å®Ÿè£…ã‚’è¿½åŠ 

### âœ… æ©Ÿèƒ½è¦ä»¶

**ãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£:**
```rust
async fn add_child_tasks(
    &self,
    child_specs: Vec<TaskSpec>
) -> Result<Vec<TaskId>, WeaverError>;
```

**å‡¦ç†å†…å®¹:**
1. å„ `TaskSpec` ã‹ã‚‰ `TaskEnvelope` ã‚’ä½œæˆ
2. å„å­ã‚¿ã‚¹ã‚¯ã® `TaskRecord` ã‚’ä½œæˆï¼ˆ`TaskRecord::new_child()` ã‚’ä½¿ç”¨ï¼‰
3. è¦ªã‚¿ã‚¹ã‚¯ã¨åŒã˜ `job_id` ã‚’å­ã‚¿ã‚¹ã‚¯ã«è¨­å®š
4. å„å­ã‚¿ã‚¹ã‚¯ã« `parent_task_id` ã‚’è¨­å®šï¼ˆã“ã® TaskLease ã® task_idï¼‰
5. å­ã‚¿ã‚¹ã‚¯ã‚’ Queue ã® `records` HashMap ã«è¿½åŠ 
6. å­ã‚¿ã‚¹ã‚¯ã‚’ Queue ã® `ready` VecDeque ã«è¿½åŠ 
7. è¦ªã‚¿ã‚¹ã‚¯ã® `child_task_ids` ã«å­ã‚¿ã‚¹ã‚¯ ID ã‚’è¿½åŠ 
8. ä½œæˆã—ãŸå­ã‚¿ã‚¹ã‚¯ã® ID ãƒªã‚¹ãƒˆï¼ˆ`Vec<TaskId>`ï¼‰ã‚’è¿”ã™

### ğŸš¨ æŠ€è¡“çš„åˆ¶ç´„ï¼ˆéå¸¸ã«é‡è¦ï¼‰

#### ADR-0003: Lock ã‚’æŒã£ãŸã¾ã¾ .await ã—ã¦ã¯ã„ã‘ãªã„

**æ‚ªã„ä¾‹:**
```rust
let mut state = self.queue.lock().await;
// âŒ Lock ã‚’æŒã£ãŸã¾ã¾ä»–ã® async å‡¦ç†
some_async_function().await;
state.records.insert(...);
```

**è‰¯ã„ä¾‹:**
```rust
// Lock å†…ã§å¿…è¦ãªå‡¦ç†ã‚’å®Ÿè¡Œ
let result = {
    let mut state = self.queue.lock().await;
    // åŒæœŸçš„ãªå‡¦ç†ã®ã¿
    state.records.insert(...);
    result_value
}; // Lock ãŒã“ã“ã§è§£æ”¾ã•ã‚Œã‚‹

// Lock ã®å¤–ã§ notify
self.notify.notify_one();
```

#### ãã®ä»–ã®åˆ¶ç´„

- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å«ã‚ã‚‹
- **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§**: è¦ªå­é–¢ä¿‚ã®åŒæ–¹å‘ãƒªãƒ³ã‚¯ã‚’æ­£ã—ãè¨­å®šã™ã‚‹
- **Notify**: å­ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ãŸã‚‰ `notify_one()` ã‚’å‘¼ã¶

### ğŸ“š åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹

#### InMemoryQueueState ã®ä¸»è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

```rust
struct InMemoryQueueState {
    records: HashMap<TaskId, TaskRecord>,  // ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãƒ¬ã‚³ãƒ¼ãƒ‰
    ready: VecDeque<TaskId>,               // å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ã® ID
    next_task_id: u64,                     // æ¬¡ã®ã‚¿ã‚¹ã‚¯ ID
    // ... ãã®ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
}
```

#### InMemoryQueueState ã®ä¸»è¦ãªãƒ¡ã‚½ãƒƒãƒ‰

```rust
fn allocate_task_id(&mut self) -> TaskId;  // æ–°ã—ã„ TaskId ã‚’å‰²ã‚Šå½“ã¦ã‚‹
```

#### TaskRecord ã®ä¸»è¦ãªãƒ¡ã‚½ãƒƒãƒ‰

```rust
pub fn new_child(
    envelope: TaskEnvelope,
    max_attempts: u32,
    job_id: JobId,
    parent_task_id: TaskId,
) -> Self;
```

#### InMemoryLease ã®æ§‹é€ 

```rust
struct InMemoryLease {
    task_id: TaskId,                           // ã“ã® Lease ã®ã‚¿ã‚¹ã‚¯ ID
    envelope: TaskEnvelope,                     // ã‚¿ã‚¹ã‚¯ã® Envelope
    queue: Arc<Mutex<InMemoryQueueState>>,     // Queue ã®å…±æœ‰çŠ¶æ…‹
    retry_policy: RetryPolicy,                  // ãƒªãƒˆãƒ©ã‚¤ãƒãƒªã‚·ãƒ¼
    notify: Arc<Notify>,                        // é€šçŸ¥ç”¨
}
```

### ğŸ’¡ å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆï¼ˆè³ªå•ãŒã‚ã‚Œã°èã„ã¦ãã ã•ã„ï¼‰

ä»¥ä¸‹ã¯ã€è©°ã¾ã£ãŸã¨ãã®ãŸã‚ã®ãƒ’ãƒ³ãƒˆã§ã™ã€‚ã¾ãšã¯è‡ªåˆ†ã§è€ƒãˆã¦ã¿ã¦ãã ã•ã„ï¼š

<details>
<summary>ãƒ’ãƒ³ãƒˆ 1: TaskEnvelope ã®ä½œæˆæ–¹æ³•</summary>

`TaskSpec` ã‹ã‚‰ `TaskEnvelope` ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€`TaskId` ã¨ `TaskType` ãŒå¿…è¦ã§ã™ã€‚
`self.envelope.task_type()` ã‚’ä½¿ã£ã¦è¦ªã‚¿ã‚¹ã‚¯ã® `TaskType` ã‚’å–å¾—ã§ãã¾ã™ã€‚
</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ 2: è¦ªã‚¿ã‚¹ã‚¯ã® job_id ã®å–å¾—æ–¹æ³•</summary>

è¦ªã‚¿ã‚¹ã‚¯ã® `job_id` ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€Queue ã® state ã‹ã‚‰è¦ªã‚¿ã‚¹ã‚¯ã® `TaskRecord` ã‚’å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
`state.records.get(&self.task_id)` ã§å–å¾—ã§ãã¾ã™ã€‚
</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ 3: Lock ã®ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†</summary>

Lock ã‚’æ—©æœŸã«è§£æ”¾ã™ã‚‹ãŸã‚ã«ã€ãƒ–ãƒ­ãƒƒã‚¯ `{}` ã‚’ä½¿ã„ã¾ã™ï¼š
```rust
let child_ids = {
    let mut state = self.queue.lock().await;
    // Lock å†…ã®å‡¦ç†
    created_ids
}; // Lock ãŒã“ã“ã§è§£æ”¾ã•ã‚Œã‚‹
```
</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ 4: è¦ªã‚¿ã‚¹ã‚¯ã® child_task_ids ã®æ›´æ–°</summary>

è¦ªã‚¿ã‚¹ã‚¯ã® `child_task_ids` ã‚’æ›´æ–°ã™ã‚‹ã«ã¯ï¼š
```rust
if let Some(parent_record) = state.records.get_mut(&self.task_id) {
    parent_record.child_task_ids.extend(child_ids.clone());
}
```
</details>

### ğŸ“– å‚è€ƒå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

æ—¢å­˜ã® `complete()` ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆ`memory.rs` ã® 320-400 è¡Œç›®ä»˜è¿‘ï¼‰ãŒå‚è€ƒã«ãªã‚Šã¾ã™ï¼š

- Lock ã®å–å¾—ã¨è§£æ”¾ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
- `state.records` ã¸ã®æŒ¿å…¥
- `state.ready` ã¸ã®è¿½åŠ 
- `self.notify.notify_one()` ã®å‘¼ã³å‡ºã—

### ğŸ” å®Ÿè£…å¾Œã®ç¢ºèªäº‹é …

å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

- [ ] `cargo check` ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‹
- [ ] ADR-0003 ã‚’éµå®ˆã—ã¦ã„ã‚‹ï¼ˆLock ã‚’æŒã£ãŸã¾ã¾ `.await` ã—ã¦ã„ãªã„ï¼‰
- [ ] è¦ªã‚¿ã‚¹ã‚¯ã® `child_task_ids` ãŒæ­£ã—ãæ›´æ–°ã•ã‚Œã¦ã„ã‚‹
- [ ] å­ã‚¿ã‚¹ã‚¯ã® `parent_task_id` ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] å­ã‚¿ã‚¹ã‚¯ãŒ `records` ã¨ `ready` ã®ä¸¡æ–¹ã«è¿½åŠ ã•ã‚Œã¦ã„ã‚‹
- [ ] ä½œæˆã—ãŸå­ã‚¿ã‚¹ã‚¯ã® ID ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¦ã„ã‚‹

---

**å®Ÿè£…é–‹å§‹å‰ã®è¨˜éŒ²** - 2026-01-02

---

## ğŸš€ Phase 4: Task Decompositionï¼ˆæœ¬æ—¥ã®ä¸»è¦å®Ÿè£…ï¼‰

### Phase 4 ã®ç›®æ¨™

Handler ãŒå­ã‚¿ã‚¹ã‚¯ã¸ã®åˆ†è§£ã‚’ææ¡ˆã—ã€è¦ªã‚¿ã‚¹ã‚¯ãŒ Decomposed çŠ¶æ…‹ã«é·ç§»ã™ã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚

**Phase 4 ã®é€²æ—çŠ¶æ³:**
- âœ… Step 1-4: åŸºæœ¬æ§‹é€ ã®è¿½åŠ ï¼ˆTaskState::Decomposed, Decision::Decompose, etc.ï¼‰
- âœ… Step 5: TaskSpec ã« task_type ã¨ payload ã‚’è¿½åŠ ï¼ˆè¨­è¨ˆæ”¹å–„ï¼‰
- âœ… Step 6: add_child_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ã¨ãƒ†ã‚¹ãƒˆ
- âœ… Step 6.5: add_child_tasks() ã® ADR-0003 æ”¹å–„ï¼ˆLock æœ€å°åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- ğŸ”œ **Step 7: Decision::Decompose ã®å‡¦ç†å®Ÿè£…ï¼ˆæ¬¡ã®ã‚¿ã‚¹ã‚¯ï¼‰**
- ğŸ”œ Step 8: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°
- ğŸ”œ Step 9: çµ±åˆãƒ†ã‚¹ãƒˆã¨ CLI ã§ã®å‹•ä½œç¢ºèª

---

### â³ Step 7: Decision::Decompose ã®å‡¦ç†å®Ÿè£…ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

**ç¾åœ¨ã®çŠ¶æ³**: `add_child_tasks()` ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ãŒå®Œäº†ã—ã€ADR-0003 ã«æº–æ‹ ã—ãŸ Lock æœ€å°åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¿’å¾—ã—ã¾ã—ãŸã€‚

#### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

`crates/weaver-core/src/queue/memory.rs` ã® `InMemoryLease::complete()` ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã€`Decision::Decompose` ã®ã‚±ãƒ¼ã‚¹ï¼ˆç¾åœ¨ `todo!()` ã«ãªã£ã¦ã„ã‚‹ï¼‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

#### ğŸ¯ å­¦ç¿’ç›®æ¨™

ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã® Rust ã®æ¦‚å¿µã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ï¼š

1. **ADR-0003 ã®å®Ÿè·µ**: Lock ã‚’æŒã£ãŸã¾ã¾ async é–¢æ•°ã‚’å‘¼ã°ãªã„
2. **Lock ã®æœ€å°åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³**: 3ãƒ•ã‚§ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¿œç”¨
3. **Error Handling**: async é–¢æ•°ã®ã‚¨ãƒ©ãƒ¼ä¼æ’­ï¼ˆ`?` operatorï¼‰
4. **State Transition**: Terminal state ã¸ã®é·ç§»
5. **Decision Recording**: DecisionRecord ã®ä½œæˆã¨è¨˜éŒ²

#### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**å¤‰æ›´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/queue/memory.rs`ï¼ˆ386-399è¡Œç›®ï¼‰

**å‡¦ç†ã®æµã‚Œ:**

```rust
Decision::Decompose { child_tasks, reason } => {
    // 1. Lock ã‚’ä¸€æ—¦ dropï¼ˆADR-0003ï¼‰
    // 2. add_child_tasks() ã‚’ awaitï¼ˆlock å¤–ã§ï¼‰
    // 3. Lock ã‚’å†å–å¾—
    // 4. è¦ªã‚¿ã‚¹ã‚¯ã‚’ Decomposed çŠ¶æ…‹ã«é·ç§»
    // 5. DecisionRecord ã‚’è¨˜éŒ²
    // 6. false ã‚’è¿”ã™ï¼ˆterminal state ãªã®ã§ notify ä¸è¦ï¼‰
}
```

#### âœ… æ©Ÿèƒ½è¦ä»¶

1. **Lock ã‚’ drop ã—ã¦ã‹ã‚‰ async å‡¦ç†**
   - ç¾åœ¨ã€`complete()` ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ `state` ã® mutable lock ã‚’ä¿æŒ
   - `add_child_tasks()` ã¯ async ãªã®ã§ã€lock ã‚’æŒã£ãŸã¾ã¾ `.await` ã—ã¦ã¯ã„ã‘ãªã„ï¼ˆADR-0003ï¼‰
   - Solution: Lock ã‚’ drop â†’ async å‡¦ç† â†’ Lock å†å–å¾—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³

2. **å­ã‚¿ã‚¹ã‚¯ã®ä½œæˆ**
   - `self.add_child_tasks(child_tasks).await?` ã‚’å‘¼ã¶
   - è¿”ã‚Šå€¤ã¯ `Vec<TaskId>`ï¼ˆä½œæˆã•ã‚ŒãŸå­ã‚¿ã‚¹ã‚¯ã® ID ãƒªã‚¹ãƒˆï¼‰

3. **è¦ªã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹é·ç§»**
   - `record.state = TaskState::Decomposed`
   - `child_task_ids` ã¯ `add_child_tasks()` å†…ã§æ—¢ã«è¨­å®šæ¸ˆã¿

4. **DecisionRecord ã®è¨˜éŒ²**
   - `trigger`: åˆ†è§£ã®ãã£ã‹ã‘ï¼ˆreason, child_count ãªã©ï¼‰
   - `context`: åˆ†è§£ã®è©³ç´°ï¼ˆchild_task_ids, reason ãªã©ï¼‰
   - `action`: "decompose"
   - `state.decisions.push(decision_record)`

5. **æˆ»ã‚Šå€¤**
   - `false` ã‚’è¿”ã™ï¼ˆDecomposed ã¯ terminal state ãªã®ã§ã€notify ä¸è¦ï¼‰

#### ğŸš¨ æŠ€è¡“çš„åˆ¶ç´„ï¼ˆéå¸¸ã«é‡è¦ï¼‰

**ADR-0003 é•åã®å±é™º:**

```rust
// âŒ BAD: Lock ã‚’æŒã£ãŸã¾ã¾ .await
Decision::Decompose { child_tasks, reason } => {
    let mut state = self.queue.lock().await;  // Already held!
    let child_ids = self.add_child_tasks(child_tasks).await?;  // DEADLOCK!
    // ...
}

// âœ… GOOD: Lock ã‚’ drop ã—ã¦ã‹ã‚‰ .await
Decision::Decompose { child_tasks, reason } => {
    let task_id = self.task_id;
    drop(state);  // Explicitly drop the lock
    
    let child_ids = self.add_child_tasks(child_tasks).await?;
    
    let mut state = self.queue.lock().await;  // Re-acquire
    // ...
}
```

**é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ:**
- `complete()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ—¢ã« `state` ã® lock ã‚’ä¿æŒã—ã¦ã„ã‚‹
- `add_child_tasks()` ã¯ async ãªã®ã§ `.await` ãŒå¿…è¦
- Lock ã‚’æŒã£ãŸã¾ã¾ `.await` ã™ã‚‹ã¨ deadlock ã®å±é™º
- Solution: `drop(state)` â†’ async å‡¦ç† â†’ å†å–å¾—

#### ğŸ’¡ åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹

**ä»–ã® Decision ã‚±ãƒ¼ã‚¹ã‚’å‚è€ƒã«:**

```rust
// Decision::Retry ã®ã‚±ãƒ¼ã‚¹ï¼ˆmemory.rs:340-370 ã‚ãŸã‚Šï¼‰
Decision::Retry { delay, reason } => {
    // ...
    let trigger = serde_json::json!({ ... });
    let context = serde_json::json!({ ... });
    let decision_record = DecisionRecord::new(
        self.task_id,
        trigger,
        "decider",
        "retry",
        Some(context),
    );
    // ...
}
```

#### ğŸ” å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆï¼ˆè³ªå•ãŒã‚ã‚Œã°èã„ã¦ãã ã•ã„ï¼‰

ä»¥ä¸‹ã¯è©°ã¾ã£ãŸã¨ãã®ãƒ’ãƒ³ãƒˆã§ã™ã€‚ã¾ãšã¯è‡ªåˆ†ã§è€ƒãˆã¦ã¿ã¦ãã ã•ã„ï¼š

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 1: Lock ã®æ‰±ã„æ–¹</summary>

```rust
Decision::Decompose { child_tasks, reason } => {
    // Phase 1: å¿…è¦ãªæƒ…å ±ã‚’å–å¾—
    let task_id = self.task_id;
    
    // Phase 2: Lock ã‚’æ˜ç¤ºçš„ã« drop
    drop(state);
    
    // Phase 3: async å‡¦ç†ï¼ˆlock ãªã—ï¼‰
    let child_ids = self.add_child_tasks(child_tasks).await?;
    
    // Phase 4: Lock ã‚’å†å–å¾—
    let mut state = self.queue.lock().await;
    
    // Phase 5: çŠ¶æ…‹æ›´æ–° + DecisionRecord
    // ...
    
    false  // terminal state
}
```

</details>

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 2: DecisionRecord ã®ä½œã‚Šæ–¹</summary>

```rust
let trigger = serde_json::json!({
    "reason": reason,
    "child_count": child_ids.len(),
});

let context = serde_json::json!({
    "child_task_ids": child_ids.iter().map(|id| id.0).collect::<Vec<_>>(),
    "reason": reason,
});

let decision_record = DecisionRecord::new(
    task_id,
    trigger,
    "decider",
    "decompose",
    Some(context),
);

state.decisions.push(decision_record);
```

</details>

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 3: è¦ªã‚¿ã‚¹ã‚¯ã®æ›´æ–°</summary>

```rust
if let Some(record) = state.records.get_mut(&task_id) {
    record.state = TaskState::Decomposed;
    record.updated_at = Instant::now();
    // child_task_ids ã¯ add_child_tasks() å†…ã§æ—¢ã«è¨­å®šæ¸ˆã¿
}
```

</details>

#### ğŸ“š å‚è€ƒå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

**Lock æœ€å°åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä»Šå­¦ã‚“ã ã°ã‹ã‚Šï¼ï¼‰:**
- `dev/docs/tips/lock_minimization_pattern.md` ã‚’å‚ç…§
- 3ãƒ•ã‚§ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³: æƒ…å ±å–å¾— â†’ å‡¦ç† â†’ æ›´æ–°

**ä»–ã® Decision ã‚±ãƒ¼ã‚¹:**
- `Decision::Retry`: memory.rs:340-370
- `Decision::MarkDead`: memory.rs:360-385

#### ğŸ” å®Ÿè£…å¾Œã®ç¢ºèªäº‹é …

å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

- [ ] `cargo check` ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‹
- [ ] ADR-0003 ã‚’éµå®ˆã—ã¦ã„ã‚‹ï¼ˆLock ã‚’ drop ã—ã¦ã‹ã‚‰ `.await`ï¼‰
- [ ] è¦ªã‚¿ã‚¹ã‚¯ãŒ Decomposed çŠ¶æ…‹ã«é·ç§»ã—ã¦ã„ã‚‹
- [ ] DecisionRecord ãŒæ­£ã—ãè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹
- [ ] `false` ã‚’è¿”ã—ã¦ã„ã‚‹ï¼ˆterminal stateï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡ï¼ˆ`?` operatorï¼‰

---

**æº–å‚™ãŒã§ããŸã‚‰ã€å®Ÿè£…ã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ï¼è³ªå•ãŒã‚ã‚Œã°ã„ã¤ã§ã‚‚ã©ã†ã ğŸš€**


---

## ğŸ“… 2026-01-03: Phase 4 ç¶šã

### â³ Step 8: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

**å‰æ—¥ã®æˆæœ**: Decision::Decompose ã®å‡¦ç†å®Ÿè£…ãŒå®Œäº†ã—ã€å…¨ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚

#### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

`crates/weaver-core/src/domain/decision.rs` ã® `DefaultDecider::decide()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›´æ–°ã—ã¦ã€Handler ãŒææ¡ˆã—ãŸå­ã‚¿ã‚¹ã‚¯ï¼ˆ`outcome.child_tasks`ï¼‰ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

#### ğŸ¯ å­¦ç¿’ç›®æ¨™

ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã® Rust ã®æ¦‚å¿µã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ï¼š

1. **å„ªå…ˆé †ä½ãƒ­ã‚¸ãƒƒã‚¯**: if-let + early return ãƒ‘ã‚¿ãƒ¼ãƒ³
2. **Option å‹ã®æ‰±ã„**: `Option<Vec<T>>` ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
3. **æ‰€æœ‰æ¨©ã®ç§»å‹•**: `clone()` ãŒå¿…è¦ãªç†ç”±
4. **Pure Function**: å‰¯ä½œç”¨ã®ãªã„é–¢æ•°ã®è¨­è¨ˆ
5. **Decision Flow**: Handler â†’ Decider â†’ Worker ã®é€£æº

#### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**å¤‰æ›´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/domain/decision.rs`ï¼ˆ82-102è¡Œç›®ï¼‰

**ç¾åœ¨ã®å•é¡Œ:**
- `_outcome` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ã‚ã‚Œã¦ã„ãªã„ï¼ˆã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ï¼‰
- Handler ãŒ `outcome.child_tasks` ã§å­ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã¦ã‚‚ç„¡è¦–ã•ã‚Œã‚‹
- åˆ†è§£æ©Ÿèƒ½ãŒå‹•ä½œã—ãªã„

**å®Ÿè£…ã™ã¹ããƒ­ã‚¸ãƒƒã‚¯:**

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // å„ªå…ˆé †ä½1: Handler ã®ææ¡ˆã‚’ãƒã‚§ãƒƒã‚¯
    //   â†’ outcome.child_tasks ãŒ Some ãªã‚‰ Decompose ã‚’è¿”ã™
    
    // å„ªå…ˆé †ä½2: Budget ã‚’ãƒã‚§ãƒƒã‚¯
    //   â†’ attempts >= max_attempts ãªã‚‰ MarkDead ã‚’è¿”ã™
    
    // å„ªå…ˆé †ä½3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Retry
    //   â†’ Retry ã‚’è¿”ã™
}
```

#### âœ… æ©Ÿèƒ½è¦ä»¶

1. **Handler ã®ææ¡ˆã‚’æœ€å„ªå…ˆ**
   - `outcome.child_tasks` ãŒ `Some` ã®å ´åˆã€å³åº§ã« `Decision::Decompose` ã‚’è¿”ã™
   - `child_tasks` ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ Decision ã«å«ã‚ã‚‹
   - reason: "Handler proposed decomposition"

2. **Budget ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰**
   - `task.attempts >= task.max_attempts` ã®å ´åˆã€`Decision::MarkDead` ã‚’è¿”ã™
   - reason: "Max attempts reached: X/Y"

3. **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Retryï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰**
   - ä¸Šè¨˜ã®ã©ã¡ã‚‰ã§ã‚‚ãªã„å ´åˆã€`Decision::Retry` ã‚’è¿”ã™
   - delay ã¯ `retry_policy.next_delay(task.attempts)` ã§è¨ˆç®—
   - reason: "Retry attempt X/Y after Ns"

#### ğŸš¨ æŠ€è¡“çš„åˆ¶ç´„

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã®å¤‰æ›´:**
```rust
// âŒ Before: outcome ã‚’ä½¿ã£ã¦ã„ãªã„
fn decide(&self, task: &TaskRecord, _outcome: &Outcome) -> Decision

// âœ… After: outcome ã‚’ä½¿ã†
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision
```

**æ‰€æœ‰æ¨©ã®è€ƒæ…®:**
```rust
// âŒ NG: child_tasks ã¯ &Vec<TaskSpec> ãªã®ã§ç§»å‹•ã§ããªã„
child_tasks: child_tasks,

// âœ… OK: clone() ã—ã¦æ‰€æœ‰æ¨©ã‚’å¾—ã‚‹
child_tasks: child_tasks.clone(),
```

**Early Return ãƒ‘ã‚¿ãƒ¼ãƒ³:**
```rust
// å„ªå…ˆé †ä½ã®é«˜ã„æ¡ä»¶ã‹ã‚‰é †ã« early return
if let Some(child_tasks) = &outcome.child_tasks {
    return Decision::Decompose { ... };
}

if task.attempts >= task.max_attempts {
    return Decision::MarkDead { ... };
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚±ãƒ¼ã‚¹
Decision::Retry { ... }
```

#### ğŸ’¡ å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆ

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 1: if-let + early return ãƒ‘ã‚¿ãƒ¼ãƒ³</summary>

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // æœ€å„ªå…ˆ: Handler ã®ææ¡ˆã‚’ãƒã‚§ãƒƒã‚¯
    if let Some(child_tasks) = &outcome.child_tasks {
        return Decision::Decompose {
            child_tasks: child_tasks.clone(),
            reason: "Handler proposed decomposition".to_string(),
        };
    }
    
    // æ¬¡ã®å„ªå…ˆé †ä½...
    // ...
}
```

**ãƒã‚¤ãƒ³ãƒˆ:**
- `&outcome.child_tasks` ã§å‚ç…§ã‚’å–ã‚‹
- `if let Some(child_tasks) = ...` ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
- `return` ã§æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³

</details>

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 2: å®Œå…¨ãªå®Ÿè£…æ§‹é€ </summary>

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // Priority 1: Handler ã®ææ¡ˆ
    if let Some(child_tasks) = &outcome.child_tasks {
        return Decision::Decompose {
            child_tasks: child_tasks.clone(),
            reason: "Handler proposed decomposition".to_string(),
        };
    }

    // Priority 2: Budget ãƒã‚§ãƒƒã‚¯
    if task.attempts >= task.max_attempts {
        return Decision::MarkDead {
            reason: format!(
                "Max attempts reached: {}/{}",
                task.attempts, task.max_attempts
            ),
        };
    }

    // Priority 3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ Retry
    let delay = self.retry_policy.next_delay(task.attempts);
    Decision::Retry {
        delay,
        reason: format!(
            "Retry attempt {}/{} after {:?}",
            task.attempts + 1,
            task.max_attempts,
            delay
        ),
    }
}
```

</details>

#### ğŸ“š å‚è€ƒ

**Pure Function ã®è¨­è¨ˆ:**
- Decider ã¯ç´”ç²‹é–¢æ•°ï¼ˆå…¥åŠ›ã‹ã‚‰å‡ºåŠ›ã‚’æ±ºå®šã™ã‚‹ã ã‘ã€å‰¯ä½œç”¨ãªã—ï¼‰
- çŠ¶æ…‹ã®æ›´æ–°ã¯ Worker/TaskLease ãŒæ‹…å½“
- ã“ã®åˆ†é›¢ã«ã‚ˆã‚Šã€ãƒ†ã‚¹ãƒˆã—ã‚„ã™ãã€æ¨è«–ã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã«ãªã‚‹

**Option å‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°:**
```rust
// ãƒ‘ã‚¿ãƒ¼ãƒ³1: if let
if let Some(value) = &option {
    // value ã‚’ä½¿ã†
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³2: match
match &option {
    Some(value) => { /* ... */ },
    None => { /* ... */ },
}
```

#### ğŸ” å®Ÿè£…å¾Œã®ç¢ºèªäº‹é …

å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

- [ ] `cargo check` ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‹
- [ ] `_outcome` â†’ `outcome` ã«å¤‰æ›´ã—ãŸ
- [ ] `child_tasks.clone()` ã‚’ä½¿ã£ã¦ã„ã‚‹
- [ ] å„ªå…ˆé †ä½ãŒæ­£ã—ã„ï¼ˆDecompose â†’ MarkDead â†’ Retryï¼‰
- [ ] æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ï¼ˆ`cargo test -p weaver-core --lib`ï¼‰


---

### âœ… Step 7 å®Œäº†: Decision::Decompose ã®å‡¦ç†å®Ÿè£…

**å®Ÿè£…æ—¥**: 2026-01-02

**å®Ÿè£…å†…å®¹:**
- `InMemoryLease::complete()` ãƒ¡ã‚½ãƒƒãƒ‰ã§ `Decision::Decompose` ã®ã‚±ãƒ¼ã‚¹ã‚’å®Ÿè£…
- Lock ãŒæ—¢ã«è§£æ”¾ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã‚’ç†è§£ï¼‰
- `add_child_tasks().await` ã‚’å‘¼ã³å‡ºã—
- è¦ªã‚¿ã‚¹ã‚¯ã‚’ `Decomposed` çŠ¶æ…‹ã«é·ç§»
- `DecisionRecord` ã‚’è¨˜éŒ²
- `false` ã‚’è¿”ã™ï¼ˆterminal stateï¼‰

**å­¦ã‚“ã ã“ã¨:**
1. **æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã‚’èª­ã‚€**: ä»–ã®ã‚±ãƒ¼ã‚¹ï¼ˆRetry, MarkDeadï¼‰ã‹ã‚‰å­¦ã¶
2. **ä»®å®šã‚’ç–‘ã†**: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’éµœå‘‘ã¿ã«ã›ãšã€å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèª
3. **Newtype pattern**: TaskId ã® `as_u64()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
4. **å•é¡Œè§£æ±º**: private field ã®ã‚¢ã‚¯ã‚»ã‚¹æ–¹æ³•ã‚’è¦‹ã¤ã‘ã‚‹

**ãƒ†ã‚¹ãƒˆçµæœ:**
- âœ… `cargo check`: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æˆåŠŸ
- âœ… `cargo test -p weaver-core --lib`: å…¨32ãƒ†ã‚¹ãƒˆæˆåŠŸ

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- Step 8: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°ï¼ˆç¿Œæ—¥ã«å®Ÿæ–½ï¼‰

---

**Phase 4 Day 1 å®Œäº† - 2026-01-02**
