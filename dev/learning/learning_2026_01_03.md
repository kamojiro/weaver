# å®Ÿè£…è¨˜éŒ² - 2026/01/03

Phase 4ï¼ˆTask Decompositionï¼‰ã®ç¶šãã‚’å®Ÿè£…ã—ã€**Phase 4 ã‚’å®Œäº†**ã—ã¾ã—ãŸã€‚ğŸ‰

**å‰æ—¥ã®æˆæœ**: Step 1-7 ã‚’å®Œäº†ã—ã€Decision::Decompose ã®å‡¦ç†å®Ÿè£…ã¾ã§å®Œäº†ã—ã¾ã—ãŸã€‚

**æœ¬æ—¥ã®æˆæœ**: Step 8-9 ã‚’å®Œäº†ã—ã€Phase 4 å…¨ä½“ãŒå‹•ä½œç¢ºèªã•ã‚Œã¾ã—ãŸã€‚

---

## ğŸ“ Phase 4 ã®é€²æ—çŠ¶æ³ï¼ˆå®Œäº†ï¼‰

- âœ… Step 1-4: åŸºæœ¬æ§‹é€ ã®è¿½åŠ ï¼ˆTaskState::Decomposed, Decision::Decompose, etc.ï¼‰
- âœ… Step 5: TaskSpec ã« task_type ã¨ payload ã‚’è¿½åŠ ï¼ˆè¨­è¨ˆæ”¹å–„ï¼‰
- âœ… Step 6: add_child_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ã¨ãƒ†ã‚¹ãƒˆ
- âœ… Step 6.5: add_child_tasks() ã® ADR-0003 æ”¹å–„ï¼ˆLock æœ€å°åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- âœ… Step 7: Decision::Decompose ã®å‡¦ç†å®Ÿè£…
- âœ… **Step 8: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°**
- âœ… **Step 9: çµ±åˆãƒ†ã‚¹ãƒˆã¨ CLI ã§ã®å‹•ä½œç¢ºèª**

**ãƒ†ã‚¹ãƒˆçµæœ**: âœ… å…¨33ãƒ†ã‚¹ãƒˆãƒ‘ã‚¹

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²

### â³ Step 8: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

#### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

`crates/weaver-core/src/domain/decision.rs` ã® `DefaultDecider::decide()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›´æ–°ã—ã¦ã€Handler ãŒææ¡ˆã—ãŸå­ã‚¿ã‚¹ã‚¯ï¼ˆ`outcome.child_tasks`ï¼‰ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

#### ğŸ¯ å­¦ç¿’ç›®æ¨™

ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã® Rust ã®æ¦‚å¿µã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ï¼š

1. **å„ªå…ˆé †ä½ãƒ­ã‚¸ãƒƒã‚¯**: if-let + early return ãƒ‘ã‚¿ãƒ¼ãƒ³
2. **Option å‹ã®æ‰±ã„**: `Option<Vec<T>>` ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
3. **æ‰€æœ‰æ¨©ã®ç§»å‹•**: `clone()` ãŒå¿…è¦ãªç†ç”±
4. **Pure Function**: å‰¯ä½œç”¨ã®ãªã„é–¢æ•°ã®è¨­è¨ˆ
5. **Decision Flow**: Handler â†’ Decider â†’ Worker ã®é€£æº

#### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**å¤‰æ›´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:** `crates/weaver-core/src/domain/decision.rs`ï¼ˆ82-102è¡Œç›®ï¼‰

**ç¾åœ¨ã®å•é¡Œ:**
- `_outcome` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ã‚ã‚Œã¦ã„ãªã„ï¼ˆã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ï¼‰
- Handler ãŒ `outcome.child_tasks` ã§å­ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã¦ã‚‚ç„¡è¦–ã•ã‚Œã‚‹
- åˆ†è§£æ©Ÿèƒ½ãŒå‹•ä½œã—ãªã„

**å®Ÿè£…ã™ã¹ããƒ­ã‚¸ãƒƒã‚¯:**

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // å„ªå…ˆé †ä½1: Handler ã®ææ¡ˆã‚’ãƒã‚§ãƒƒã‚¯
    //   â†’ outcome.child_tasks ãŒ Some ãªã‚‰ Decompose ã‚’è¿”ã™

    // å„ªå…ˆé †ä½2: Budget ã‚’ãƒã‚§ãƒƒã‚¯
    //   â†’ attempts >= max_attempts ãªã‚‰ MarkDead ã‚’è¿”ã™

    // å„ªå…ˆé †ä½3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Retry
    //   â†’ Retry ã‚’è¿”ã™
}
```

#### âœ… æ©Ÿèƒ½è¦ä»¶

1. **Handler ã®ææ¡ˆã‚’æœ€å„ªå…ˆ**
   - `outcome.child_tasks` ãŒ `Some` ã®å ´åˆã€å³åº§ã« `Decision::Decompose` ã‚’è¿”ã™
   - `child_tasks` ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ Decision ã«å«ã‚ã‚‹
   - reason: "Handler proposed decomposition"

2. **Budget ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰**
   - `task.attempts >= task.max_attempts` ã®å ´åˆã€`Decision::MarkDead` ã‚’è¿”ã™
   - reason: "Max attempts reached: X/Y"

3. **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Retryï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰**
   - ä¸Šè¨˜ã®ã©ã¡ã‚‰ã§ã‚‚ãªã„å ´åˆã€`Decision::Retry` ã‚’è¿”ã™
   - delay ã¯ `retry_policy.next_delay(task.attempts)` ã§è¨ˆç®—
   - reason: "Retry attempt X/Y after Ns"

#### ğŸš¨ æŠ€è¡“çš„åˆ¶ç´„

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã®å¤‰æ›´:**
```rust
// âŒ Before: outcome ã‚’ä½¿ã£ã¦ã„ãªã„
fn decide(&self, task: &TaskRecord, _outcome: &Outcome) -> Decision

// âœ… After: outcome ã‚’ä½¿ã†
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision
```

**æ‰€æœ‰æ¨©ã®è€ƒæ…®:**
```rust
// âŒ NG: child_tasks ã¯ &Vec<TaskSpec> ãªã®ã§ç§»å‹•ã§ããªã„
child_tasks: child_tasks,

// âœ… OK: clone() ã—ã¦æ‰€æœ‰æ¨©ã‚’å¾—ã‚‹
child_tasks: child_tasks.clone(),
```

**Early Return ãƒ‘ã‚¿ãƒ¼ãƒ³:**
```rust
// å„ªå…ˆé †ä½ã®é«˜ã„æ¡ä»¶ã‹ã‚‰é †ã« early return
if let Some(child_tasks) = &outcome.child_tasks {
    return Decision::Decompose { ... };
}

if task.attempts >= task.max_attempts {
    return Decision::MarkDead { ... };
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚±ãƒ¼ã‚¹
Decision::Retry { ... }
```

#### ğŸ’¡ å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆ

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 1: if-let + early return ãƒ‘ã‚¿ãƒ¼ãƒ³</summary>

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // æœ€å„ªå…ˆ: Handler ã®ææ¡ˆã‚’ãƒã‚§ãƒƒã‚¯
    if let Some(child_tasks) = &outcome.child_tasks {
        return Decision::Decompose {
            child_tasks: child_tasks.clone(),
            reason: "Handler proposed decomposition".to_string(),
        };
    }

    // æ¬¡ã®å„ªå…ˆé †ä½...
    // ...
}
```

**ãƒã‚¤ãƒ³ãƒˆ:**
- `&outcome.child_tasks` ã§å‚ç…§ã‚’å–ã‚‹
- `if let Some(child_tasks) = ...` ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
- `return` ã§æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³

</details>

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ 2: å®Œå…¨ãªå®Ÿè£…æ§‹é€ </summary>

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision {
    // Priority 1: Handler ã®ææ¡ˆ
    if let Some(child_tasks) = &outcome.child_tasks {
        return Decision::Decompose {
            child_tasks: child_tasks.clone(),
            reason: "Handler proposed decomposition".to_string(),
        };
    }

    // Priority 2: Budget ãƒã‚§ãƒƒã‚¯
    if task.attempts >= task.max_attempts {
        return Decision::MarkDead {
            reason: format!(
                "Max attempts reached: {}/{}",
                task.attempts, task.max_attempts
            ),
        };
    }

    // Priority 3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ Retry
    let delay = self.retry_policy.next_delay(task.attempts);
    Decision::Retry {
        delay,
        reason: format!(
            "Retry attempt {}/{} after {:?}",
            task.attempts + 1,
            task.max_attempts,
            delay
        ),
    }
}
```

</details>

#### ğŸ“š å‚è€ƒ

**Pure Function ã®è¨­è¨ˆ:**
- Decider ã¯ç´”ç²‹é–¢æ•°ï¼ˆå…¥åŠ›ã‹ã‚‰å‡ºåŠ›ã‚’æ±ºå®šã™ã‚‹ã ã‘ã€å‰¯ä½œç”¨ãªã—ï¼‰
- çŠ¶æ…‹ã®æ›´æ–°ã¯ Worker/TaskLease ãŒæ‹…å½“
- ã“ã®åˆ†é›¢ã«ã‚ˆã‚Šã€ãƒ†ã‚¹ãƒˆã—ã‚„ã™ãã€æ¨è«–ã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã«ãªã‚‹

**Option å‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°:**
```rust
// ãƒ‘ã‚¿ãƒ¼ãƒ³1: if let
if let Some(value) = &option {
    // value ã‚’ä½¿ã†
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³2: match
match &option {
    Some(value) => { /* ... */ },
    None => { /* ... */ },
}
```

#### ğŸ” å®Ÿè£…å¾Œã®ç¢ºèªäº‹é …

å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

- [x] `cargo check` ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‹
- [x] `_outcome` â†’ `outcome` ã«å¤‰æ›´ã—ãŸ
- [x] `child_tasks.clone()` ã‚’ä½¿ã£ã¦ã„ã‚‹
- [x] å„ªå…ˆé †ä½ãŒæ­£ã—ã„ï¼ˆDecompose â†’ MarkDead â†’ Retryï¼‰
- [x] æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ï¼ˆ`cargo test -p weaver-core --lib`ï¼‰

---

**æº–å‚™ãŒã§ããŸã‚‰ã€å®Ÿè£…ã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ï¼ğŸš€**

---

### âœ… Step 8 å®Œäº†: Decider ãŒ child_tasks ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†æ›´æ–°

**å®Ÿè£…å†…å®¹:**
- `DefaultDecider::decide()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›´æ–°
- `_outcome` â†’ `outcome` ã«å¤‰æ›´
- `if let Some(child_tasks) = &outcome.child_tasks` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨
- å„ªå…ˆé †ä½: Decompose â†’ MarkDead â†’ Retry

**å­¦ã‚“ã ã“ã¨:**
1. **Option å‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°**: `if let` vs `is_some() + unwrap()`
2. **Rust ã®æ…£ç”¨å¥**: ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã§å¥½ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
3. **æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³**: `return` ã§å„ªå…ˆé †ä½ã‚’æ˜ç¢ºã«

**ãƒ†ã‚¹ãƒˆçµæœ:**
- âœ… `cargo check`: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æˆåŠŸ
- âœ… `cargo test -p weaver-core --lib`: å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ

---

### â³ Step 9: çµ±åˆãƒ†ã‚¹ãƒˆã¨ CLI ã§ã®å‹•ä½œç¢ºèª

#### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

Phase 4ï¼ˆTask Decompositionï¼‰ã®æ©Ÿèƒ½ãŒ End-to-End ã§å‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚

1. **çµ±åˆãƒ†ã‚¹ãƒˆã®ä½œæˆ**: Handler ãŒå­ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã€Worker ãŒæ­£ã—ãå‡¦ç†ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
2. **CLI ã§ã®å‹•ä½œç¢ºèª**: å®Ÿéš›ã® weaver-cli ã§åˆ†è§£æ©Ÿèƒ½ã‚’è©¦ã™

#### ğŸ¯ å­¦ç¿’ç›®æ¨™

1. **çµ±åˆãƒ†ã‚¹ãƒˆã®è¨­è¨ˆ**: è¤‡æ•°ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®é€£æºã‚’ãƒ†ã‚¹ãƒˆ
2. **Handler ã®å®Ÿè£…**: Outcome ã§å­ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ
3. **End-to-End ã®ç†è§£**: Handler â†’ Decider â†’ Worker ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼
4. **ãƒ‡ãƒãƒƒã‚°ã‚¹ã‚­ãƒ«**: å®Ÿéš›ã®å‹•ä½œã‚’è¦³å¯Ÿã—ã¦å•é¡Œã‚’ç™ºè¦‹

#### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**Part 1: çµ±åˆãƒ†ã‚¹ãƒˆã®ä½œæˆ**

`crates/weaver-core/src/worker.rs` ã«ã€åˆ†è§£æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹çµ±åˆãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚

**ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª:**
1. è¦ªã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
2. Handler ãŒå­ã‚¿ã‚¹ã‚¯2ã¤ã‚’ææ¡ˆï¼ˆOutcome::with_decompose_hintï¼‰
3. Decider ãŒ Decision::Decompose ã‚’è¿”ã™
4. Worker ãŒ add_child_tasks() ã‚’å‘¼ã³ã€è¦ªã‚’ Decomposed ã«ã™ã‚‹
5. å­ã‚¿ã‚¹ã‚¯2ã¤ãŒ Ready çŠ¶æ…‹ã§ä½œæˆã•ã‚Œã‚‹
6. å­ã‚¿ã‚¹ã‚¯ãŒé †æ¬¡å®Ÿè¡Œã•ã‚Œã‚‹

**Part 2: CLI ã§ã®å‹•ä½œç¢ºèª**

`crates/weaver-cli/src/main.rs` ã«ã€åˆ†è§£æ©Ÿèƒ½ã‚’ãƒ‡ãƒ¢ã™ã‚‹ Handler ã‚’è¿½åŠ ã—ã¾ã™ã€‚

#### ğŸ’¡ çµ±åˆãƒ†ã‚¹ãƒˆã®å®Ÿè£…ãƒ’ãƒ³ãƒˆ

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ: DecomposingHandler ã®å®Ÿè£…</summary>

```rust
/// Test handler that decomposes on first execution
struct DecomposingHandler {
    decompose_on_first: AtomicBool,
}

impl DecomposingHandler {
    fn new() -> Self {
        Self {
            decompose_on_first: AtomicBool::new(true),
        }
    }
}

#[async_trait]
impl TaskHandler for DecomposingHandler {
    async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError> {
        // First call: decompose
        if self.decompose_on_first.swap(false, Ordering::Relaxed) {
            let child_specs = vec![
                TaskSpec::new(
                    "child 1",
                    TaskType::new("decomposing_task"),
                    serde_json::json!({"child_index": 1}),
                ),
                TaskSpec::new(
                    "child 2",
                    TaskType::new("decomposing_task"),
                    serde_json::json!({"child_index": 2}),
                ),
            ];
            return Ok(Outcome::success().with_decompose_hint(child_specs));
        }
        
        // Subsequent calls: succeed immediately
        Ok(Outcome::success())
    }
}
```

</details>

<details>
<summary>ğŸ’¡ ãƒ’ãƒ³ãƒˆ: çµ±åˆãƒ†ã‚¹ãƒˆã®æ§‹é€ </summary>

```rust
#[tokio::test]
async fn test_task_decomposition_integration() {
    // Setup
    let queue = Arc::new(InMemoryQueue::new(RetryPolicy::default_v1()));
    let mut registry = HandlerRegistry::new();
    registry.register(
        TaskType::new("decomposing_task"),
        Arc::new(DecomposingHandler::new()),
    ).unwrap();
    let runtime = Arc::new(Runtime::new(Arc::new(registry)));
    let decider = Arc::new(DefaultDecider::default_v1());
    
    // Submit a job with one parent task
    let job_spec = JobSpec::new(vec![
        TaskSpec::new(
            "parent task",
            TaskType::new("decomposing_task"),
            serde_json::json!({}),
        ),
    ]);
    queue.submit_job(job_spec).await.unwrap();
    
    // Start workers
    let workers = WorkerGroup::spawn(1, queue.clone(), runtime, decider);
    
    // Wait for completion
    // ...
    
    // Verify:
    // - Parent is Decomposed
    // - 2 children are Succeeded
    // - Total 3 tasks (1 parent + 2 children)
}
```

</details>

#### ğŸ” ç¢ºèªäº‹é …

- [x] çµ±åˆãƒ†ã‚¹ãƒˆãŒä½œæˆã•ã‚Œã€ãƒ‘ã‚¹ã™ã‚‹
- [x] è¦ªã‚¿ã‚¹ã‚¯ãŒ Decomposed çŠ¶æ…‹ã«ãªã‚‹
- [x] å­ã‚¿ã‚¹ã‚¯2ã¤ãŒä½œæˆã•ã‚Œã€å®Ÿè¡Œã•ã‚Œã‚‹
- [x] DecisionRecord ãŒè¨˜éŒ²ã•ã‚Œã‚‹
- [ ] CLI ã§ãƒ‡ãƒ¢ãŒå‹•ä½œã™ã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€æœªå®Ÿæ–½ï¼‰

---

**æº–å‚™ãŒã§ããŸã‚‰ã€çµ±åˆãƒ†ã‚¹ãƒˆã®å®Ÿè£…ã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ï¼ğŸš€**

---

### âœ… Step 9 å®Œäº†: çµ±åˆãƒ†ã‚¹ãƒˆã¨å‹•ä½œç¢ºèª

**å®Ÿè£…å†…å®¹:**

1. **çµ±åˆãƒ†ã‚¹ãƒˆã®ä½œæˆ** (`worker.rs`)
   - `DecomposingHandler`: åˆå›å®Ÿè¡Œæ™‚ã«å­ã‚¿ã‚¹ã‚¯2ã¤ã‚’ææ¡ˆã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
   - `test_task_decomposition_integration`: End-to-End ãƒ†ã‚¹ãƒˆ
   - AtomicBool ã§çŠ¶æ…‹ç®¡ç†ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ï¼‰

2. **ãƒã‚°ä¿®æ­£ã¨ã‚³ãƒ¼ãƒ‰æ”¹å–„:**
   - **Bug #1**: `submit_job()` ãŒ `task_spec.title` ã‚’ `task_type` ã¨ã—ã¦ä½¿ç”¨ã—ã¦ã„ãŸ
     - ä¿®æ­£: `task_spec.task_type` ã¨ `task_spec.payload` ã‚’ç›´æ¥ä½¿ç”¨
   - **Bug #2**: Worker ãŒ Success æ™‚ã« `child_tasks` ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ãªã‹ã£ãŸ
     - ä¿®æ­£: Success ã§ã‚‚ `child_tasks` ãŒã‚ã‚Œã° Decider ãƒ•ãƒ­ãƒ¼ã«é€²ã‚€
   - **Bug #3**: ãƒ†ã‚¹ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¤–ã«ã‚³ãƒ¼ãƒ‰ãŒé…ç½®ã•ã‚Œã¦ã„ãŸ
     - ä¿®æ­£: ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨æ§‹é€ ã‚’æ•´ç†

**ãƒ†ã‚¹ãƒˆçµæœ:**
```
âœ“ Decomposition test passed:
  - Parent: Decomposed (1)
  - Children: Succeeded (2)
  - Total tasks: 3

test result: ok. 33 passed; 0 failed; 0 ignored
```

**å­¦ã‚“ã ã“ã¨:**

1. **End-to-End ãƒ†ã‚¹ãƒˆã®é‡è¦æ€§**
   - å˜ä½“ãƒ†ã‚¹ãƒˆã§ã¯è¦‹ã¤ã‹ã‚‰ãªã„ãƒã‚°ã‚’ç™ºè¦‹ï¼ˆWorker ã® Success ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼‰
   - ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã®é€£æºã‚’æ¤œè¨¼ã§ãã‚‹

2. **ãƒ‡ãƒãƒƒã‚°ãƒ—ãƒ­ã‚»ã‚¹**
   - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¸å¯§ã«èª­ã‚€ï¼ˆ"handler not found for task_type=parent task"ï¼‰
   - å•é¡Œã®æ ¹æœ¬åŸå› ã‚’è¿½è·¡ã™ã‚‹ï¼ˆsubmit_job â†’ worker â†’ complete ã®æµã‚Œï¼‰
   - ä¸€ã¤ãšã¤ä¿®æ­£ã—ã¦ãƒ†ã‚¹ãƒˆã™ã‚‹

3. **AtomicBool ã®æ´»ç”¨**
   - ãƒ†ã‚¹ãƒˆç”¨ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã§çŠ¶æ…‹ç®¡ç†
   - è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å®‰å…¨ã«ã‚¢ã‚¯ã‚»ã‚¹
   - `swap()` ã§ CAS (Compare-And-Swap) æ“ä½œ

**Worker ã® Success ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ”¹å–„:**

```rust
OutcomeKind::Success => {
    // Check if Handler proposed decomposition
    if outcome.child_tasks.is_some() {
        // Go through Decider flow
        let task_record = lease.get_task_record().await.unwrap_or_else(...);
        let decision = decider.decide(&task_record, &outcome);
        lease.complete(outcome, decision).await.unwrap_or_else(...);
    } else {
        // Simple success, just ack
        lease.ack().await.unwrap_or_else(...);
    }
}
```

**Phase 4 å®Œäº†ï¼ğŸ‰**

Task Decomposition æ©Ÿèƒ½ãŒå®Œå…¨ã«å®Ÿè£…ã•ã‚Œã€å…¨ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸã€‚

