# 実装記録 - 2026/01/02

Phase 4-1 (Handler → Outcome → Decider フロー統合) の最終ステップを実装します。

**タスク一覧**: 全体のタスクと進捗は `tasks.md` を参照してください。

---

## 📝 Phase 4-1 の目標

Handler → Outcome → Decider → Decision フローを weaver 実行エンジンに統合する。

**Phase 4-1 の進捗状況:**
- ✅ Step 1: TaskLease Interface の拡張
- ✅ Step 2: Handler Trait の変更
- ✅ Step 3: Decider を Worker に統合
- ✅ Step 4: Worker Loop Flow
- ✅ Step 5: get_task_record() の実装
- ✅ Step 6: complete() 実装
- ✅ Step 6.5: complete() の単体テスト
- 🔜 **Step 7: Handler 更新（今日のタスク）**
- 🔜 Step 8: 統合テスト
- 🔜 Step 9: CLI example の動作確認
- 🔜 Step 10: ドキュメント更新

---

## 📅 本日の実装記録

### Step 7: CLI の HelloHandler を新しいパターンに更新

**目的**: HelloHandler を Phase 4-1 の新しいフロー（`Result<Outcome, WeaverError>`）に適合させる

**ファイル**: `crates/weaver-cli/src/main.rs`

**変更内容:**

1. **imports の追加**:
   - `DefaultDecider` と `Outcome` を追加

2. **HelloHandler::handle() の更新**:
   - 戻り値を `Result<(), WeaverError>` から `Result<Outcome, WeaverError>` に変更
   - 成功時: `Ok(Outcome::success())` を返す
   - 意図的な失敗: `Ok(Outcome::failure(reason))` を返す（エラーではなくビジネス結果）
   - インフラエラー: `Err(WeaverError)` のまま（JSON decode 失敗など）

3. **main 関数の更新**:
   - `DefaultDecider` を作成
   - `WorkerGroup::spawn()` に decider を渡す（4つ目のパラメータ）

**設計のポイント:**

#### インフラエラーとビジネスエラーの区別

これは Phase 4-1 の核心的な設計決定です:

| 状況 | 戻り値 | 意味 |
|------|--------|------|
| JSON decode 失敗 | `Err(WeaverError)` | インフラエラー（実行できなかった） |
| 意図的な失敗（テスト用） | `Ok(Outcome::failure(reason))` | ビジネスエラー（実行したが失敗） |
| 成功 | `Ok(Outcome::success())` | 成功（実行して成功） |

**なぜこの区別が重要か？**

1. **リトライ戦略の違い**:
   - インフラエラー: Worker が `Outcome::failure()` に変換して Decider へ
   - ビジネスエラー: 直接 Decider が判断

2. **観測可能性**:
   - Outcome には `reason`, `artifacts`, `retry_hint` を含められる
   - インフラエラーは WeaverError のメッセージのみ

3. **拡張性**:
   - ビジネスエラーには代替案（`alternatives`）を提案できる
   - インフラエラーは単純なリトライのみ

---

### ✅ Step 7 実装完了

**実装内容:**

1. **HelloHandler::handle()** (line 33-48):
   ```rust
   async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError> {
       let p: HelloPayload = serde_json::from_value(envelope.payload().clone())
           .map_err(|e| WeaverError::Other(format!("json decode: {e}")))?;

       let left = self.remaining_failures.load(Ordering::Relaxed);
       if left > 0 {
           self.remaining_failures.fetch_sub(1, Ordering::Relaxed);
           return Ok(Outcome::failure(format!(
               "intentional failure (left={left})"
           )));
       }

       println!("✓ Hello, {}!", p.name);
       Ok(Outcome::success())
   }
   ```

2. **main 関数** (line 64-67):
   ```rust
   let default_decider = Arc::new(DefaultDecider::default_v1());
   let workers = WorkerGroup::spawn(1, queue.clone(), runtime.clone(), default_decider);
   ```

**動作確認:**

```
$ cargo run -p weaver-cli
=== Weaver CLI Example ===

📤 Enqueued task: task-1
📊 State counts: queued=0, running=1, succeeded=0, retry_scheduled=0, dead=0
📊 State counts: queued=0, running=0, succeeded=0, retry_scheduled=1, dead=0
[約2秒待機 - 1回目のリトライ]
[約2秒待機 - 2回目のリトライ]
✓ Hello, Weaver!
📊 State counts: queued=0, running=0, succeeded=1, retry_scheduled=0, dead=0

✅ Task completed!
   Result: SUCCESS
```

**フローの確認:**
1. ✅ 最初の実行: Outcome::failure → Decider → Decision::Retry → retry_scheduled
2. ✅ 2回目の実行: Outcome::failure → Decider → Decision::Retry → retry_scheduled
3. ✅ 3回目の実行: Outcome::success → lease.ack() → succeeded

**重要な学び:**
- 意図的な失敗を `Ok(Outcome::failure())` で返すことで、Handler が実行結果を観測・報告する責務を果たす
- Worker は Outcome を受け取り、Decider を呼んで次のアクションを決定
- リトライスケジューリングは complete() が担当（ADR-0003準拠）

---

## 🎓 学習タスク（完了）

### TODO(human) の場所

1. **HelloHandler::handle()**: `crates/weaver-cli/src/main.rs` の 34-52 行目
2. **main 関数**: `crates/weaver-cli/src/main.rs` の 68-73 行目

### 実装のヒント

#### HelloHandler::handle() の実装パターン

```rust
async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError> {
    // Step 1: Payload decode (infrastructure error)
    let p: HelloPayload = serde_json::from_value(envelope.payload().clone())
        .map_err(|e| WeaverError::Other(format!("json decode: {e}")))?;
    // ↑ これは Err(WeaverError) を返す（インフラエラー）

    // Step 2: Business logic (business error)
    let left = self.remaining_failures.load(Ordering::Relaxed);
    if left > 0 {
        self.remaining_failures.fetch_sub(1, Ordering::Relaxed);
        // ここで Outcome::failure() を返す（ビジネスエラー）
        return Ok(Outcome::failure(format!("intentional failure (left={left})")));
    }

    // Step 3: Success
    println!("✓ Hello, {}!", p.name);
    Ok(Outcome::success())
}
```

#### main 関数の実装パターン

```rust
// Decider を作成
let decider = Arc::new(DefaultDecider::default_v1());

// WorkerGroup::spawn() に渡す
let workers = WorkerGroup::spawn(1, queue.clone(), runtime.clone(), decider);
```

---

## 🔑 設計のキーポイント

### 1. Handler の責務: 実行 + 観測

Handler は2つの責務を持ちます:

1. **実行**: タスクを実行する
2. **観測**: 実行結果を Outcome として返す

**Outcome に含めるべき情報:**
- `kind`: SUCCESS / FAILURE / BLOCKED
- `reason`: 何が起きたか（失敗理由、成功メッセージなど）
- `artifacts`: 観測された成果物（stdout, stderr, ファイルパスなど）
- `retry_hint`: リトライのヒント（推奨遅延時間など）
- `alternatives`: 代替アクション（別のアプローチの提案）

### 2. Worker の責務: オーケストレーション

Worker は以下の流れを制御します:

```
1. Handler を実行 → Outcome を取得
2. Outcome.kind をチェック:
   - SUCCESS → lease.ack() (Decider 不要)
   - FAILURE/BLOCKED → Decider を呼ぶ
3. Decider が Decision を返す:
   - Decision::Retry → lease.complete(outcome, decision)
   - Decision::MarkDead → lease.complete(outcome, decision)
```

### 3. Decider の責務: 判断

Decider は純粋関数です:

```rust
fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision
```

**入力:**
- `task`: タスクの状態（attempts, max_attempts など）
- `outcome`: 最新の実行結果

**出力:**
- `Decision::Retry { delay, reason }`: リトライする
- `Decision::MarkDead { reason }`: 諦める

**純粋関数の利点:**
- テストしやすい
- 副作用がない（状態変更は Worker/TaskLease が担当）
- カスタマイズしやすい（ユーザーが独自の Decider を実装可能）

---

## 📊 実装の進捗

**Phase 4-1 全体の進捗: 70% → 95%**

- ✅ Step 1-7: 完了
- ✅ Step 9: CLI 動作確認完了（Step 7 で実施）
- ⏳ Step 8: 統合テスト（オプション）
- ⏳ Step 10: ドキュメント更新

**推定残り時間: 1 時間**
- Step 10: 1 時間（ドキュメント更新）

---

## 🎯 次のステップ

Step 7 完了後の残タスク:

1. **Step 10: ドキュメント更新** - ADR-0005 を "Accepted" に更新、learning 記録の最終更新
2. **（オプション）Step 8: 統合テスト** - より複雑なシナリオのテスト

---

## 💡 今日学んだこと

### 1. インフラエラーとビジネスエラーの区別

これが Phase 4-1 の最も重要な学びでした:

- **インフラエラー** (`Err(WeaverError)`): 実行できなかった（JSON パース失敗など）
- **ビジネスエラー** (`Ok(Outcome::failure())`): 実行したが失敗した

最初の実装では意図的な失敗を `Err(WeaverError)` で返していましたが、これを `Ok(Outcome::failure())` に修正することで、Handler が実行結果を観測・報告する責務を正しく果たせるようになりました。

### 2. Handler → Outcome → Decider → Decision フローの実動作

CLI を実行して、以下のフローが正しく動作することを確認できました:

1. Handler が `Outcome::failure()` を返す
2. Worker が Decider を呼ぶ
3. Decider が `Decision::Retry` を返す
4. `complete()` がリトライをスケジュール
5. 2秒後に再実行（exponential backoff）
6. 3回目で成功

### 3. 純粋関数と副作用の分離の実践

- **Decider**: 純粋関数（状態を見て判断を返すだけ）
- **Worker/TaskLease**: 副作用（判断を実行して状態を変更）

この分離により、判断ロジックのテストやカスタマイズが容易になります。

---

## 💡 参考資料

### ADR（Architecture Decision Records）

- **ADR-0005**: Decider アーキテクチャ
  - ファイル: `dev/docs/adr/0005-decider-architecture.md`
  - 内容: Handler の戻り値、Decider の責務、Worker のオーケストレーション

### 実装済みコード（参考）

- **Outcome の convenience methods**: `crates/weaver-core/src/domain/outcome.rs`
  - `Outcome::success()`: 71-79 行目
  - `Outcome::failure(reason)`: 81-89 行目
  - `Outcome::blocked(reason)`: 91-99 行目

- **DefaultDecider の実装**: `crates/weaver-core/src/domain/decision.rs`
  - `DefaultDecider::default_v1()`: 69-72 行目
  - `decide()` ロジック: 75-97 行目

- **Worker Loop Flow**: `crates/weaver-core/src/worker.rs`
  - worker_loop() の実装: 96-165 行目（Step 4 で実装）

---

## ✅ Step 7 完了日

**完了日**: 2026-01-02
**所要時間**: 約1時間
**実装者**: ユーザー（学習タスク）
**レビュー**: Claude（学習モード）

---

## ✅ Step 8 完了: 統合テスト（Claude 実装）

**完了日**: 2026-01-02
**ファイル**: `crates/weaver-core/src/worker.rs` (テストセクション追加)

**実装したテスト:**

1. **test_worker_retry_flow_integration**: リトライフロー全体の統合テスト
   - Handler が 2回失敗、3回目で成功
   - Outcome::failure → Decider → Decision::Retry のフローを検証
   - AttemptRecord が3つ作成されることを確認

2. **test_worker_max_attempts_exceeded**: max_attempts 超過のテスト
   - 常に失敗する Handler で max_attempts (5回) 試行後に Dead になることを検証
   - AttemptRecord が5つ作成されることを確認

3. **test_worker_immediate_success**: 即座に成功するテスト
   - リトライなしで SUCCESS になるケースを検証
   - AttemptRecord が1つだけ作成されることを確認

**テスト結果:**
```
test result: ok. 3 passed; 0 failed; 0 ignored
```

**全テスト結果:**
```
test result: ok. 31 passed; 0 failed; 0 ignored
```

---

## ✅ Step 10 完了: ドキュメント更新（Claude 実装）

**完了日**: 2026-01-02
**更新ファイル**: `dev/docs/adr/0005-decider-architecture.md`

**更新内容:**

1. **ステータス変更**: 「提案中 (Proposed)」→「承認済み (Accepted)」
2. **実装完了記録**: 提案日、実装開始日、実装完了日、承認日を追加
3. **実装計画の更新**: Phase 4-1 の全ステップを ✅ に更新
4. **実装ファイル一覧**: 変更されたファイルをリスト化
5. **テスト一覧**: 実装したテストを記録
6. **実装履歴セクション**: 提案から実装完了までの履歴を追加
7. **実装で得られた知見**: インフラエラーとビジネスエラーの区別、Send + Sync 制約、テスタビリティの向上を記録

---

## 🎯 Phase 4-1 完了！

**完了日**: 2026-01-02
**全体の進捗**: 100% 完了 ✅

**完了したステップ:**
- ✅ Step 1-7: 全完了（実装とCLI動作確認）
- ✅ Step 8: 統合テスト（Claude 実装）
- ✅ Step 9: CLI 動作確認（Step 7 で実施）
- ✅ Step 10: ドキュメント更新（Claude 実装）

**成果物:**
- Handler → Outcome → Decider → Decision フローの完全実装
- 純粋関数（Decider）と副作用（Worker/TaskLease）の分離
- カスタマイズ可能な判断ロジック（Decider trait）
- 完全なテストカバレッジ（単体テスト + 統合テスト）
- ADR-0005 の承認と記録

**次のフェーズ**: Phase 4-2 でタスク分解機能（Decision::Decompose）を実装予定

---

**Phase 4-1 実装完了記録** - 2026-01-02
