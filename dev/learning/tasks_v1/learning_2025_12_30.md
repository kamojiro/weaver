# å®Ÿè£…è¨˜éŒ² - 2025/12/30

Phase 3 (Attempt/Decision è¨˜éŒ²) ã®å®Ÿè£…éƒ¨åˆ†ã‚’å®Œäº†ã—ã¾ã—ãŸã€‚

**ã‚¿ã‚¹ã‚¯ä¸€è¦§**: å…¨ä½“ã®ã‚¿ã‚¹ã‚¯ã¨é€²æ—ã¯ `tasks.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ“ å­¦ç¿’ãƒ¡ãƒ¢

### Phase 3 ã®ç›®æ¨™

å®Ÿè¡Œå±¥æ­´ã¨åˆ¤æ–­ã®è¨˜éŒ²ã‚’æ®‹ã™ä»•çµ„ã¿ã‚’å®Ÿè£…ã—ã€ã€Œãªãœã“ã®çµæœã«ãªã£ãŸã‹ã€ã‚’èª¬æ˜å¯èƒ½ã«ã™ã‚‹ã€‚

### å‰å›ã¾ã§ã®å®Ÿè£…çŠ¶æ³

- âœ… AttemptRecord / DecisionRecord ã®å‹å®šç¾©
- âœ… InMemoryQueueState ã¸ã®çµ±åˆï¼ˆattempts HashMap, decisions Vec, allocate_attempt_idï¼‰
- â³ TaskLease ã§ã®å®Ÿéš›ã®è¨˜éŒ²ï¼ˆä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯ï¼‰

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²

### 1. TaskLease::ack() ã§ã® AttemptRecord è¨˜éŒ²ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs:287-307`)

ã‚¿ã‚¹ã‚¯æˆåŠŸæ™‚ã®å®Ÿè¡Œå±¥æ­´ã‚’è¨˜éŒ²ï¼š

```rust
async fn ack(self: Box<Self>) -> Result<(), WeaverError> {
    let mut state = self.queue.lock().await;

    // First, do all state operations (allocate, insert)
    let attempt_id = state.allocate_attempt_id();
    let attempt_record = AttemptRecord::new(
        attempt_id,
        self.task_id,
        self.envelope.payload().clone(),
        vec![],
        Outcome::success(),
    );
    state.attempts.insert(attempt_id, attempt_record);

    // Then, get mutable reference to record and update
    if let Some(record) = state.records.get_mut(&self.task_id) {
        record.mark_succeeded();
    }

    Ok(())
}
```

**å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ:**
1. **ID æ¡ç•ª â†’ ä½œæˆ â†’ æŒ¿å…¥**: Phase 1-2 ã§å­¦ã‚“ã ãƒ‘ã‚¿ãƒ¼ãƒ³ã®é©ç”¨
2. **action ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰**: `self.envelope.payload().clone()` ã§å®Ÿè¡Œå†…å®¹ã‚’è¨˜éŒ²
3. **observation**: v1 ç°¡æ½”åŒ–ã®ãŸã‚ç©ºã® Vec
4. **outcome**: `Outcome::success()` ã§æˆåŠŸã‚’è¡¨ç¾

**é­é‡ã—ãŸå•é¡Œã¨è§£æ±º:**

**å•é¡Œ1: payload ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ private**
- ã‚¨ãƒ©ãƒ¼: `field 'payload' of 'TaskEnvelope' is private`
- è§£æ±º: ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ `payload()` ã‚’ä½¿ç”¨ â†’ `self.envelope.payload().clone()`
- å­¦ã³: Rust ã®ã‚«ãƒ—ã‚»ãƒ«åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆprivate ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ + public ã‚²ãƒƒã‚¿ãƒ¼ï¼‰

**å•é¡Œ2: å‘½åè¦å‰‡**
- ã‚¨ãƒ©ãƒ¼: `no variant or associated item named 'stdout' found`
- åŸå› : `Artifact::stdout` ã¨å°æ–‡å­—ã§æ›¸ã„ã¦ã—ã¾ã£ãŸ
- è§£æ±º: enum ãƒãƒªã‚¢ãƒ³ãƒˆã¯ PascalCase â†’ `Artifact::Stdout`
- å­¦ã³: Rust ã®å‘½åè¦å‰‡ï¼ˆãƒãƒªã‚¢ãƒ³ãƒˆ: PascalCase, ãƒ¡ã‚½ãƒƒãƒ‰: snake_caseï¼‰

**å•é¡Œ3: å€Ÿç”¨è¦å‰‡ã®ç«¶åˆï¼ˆæœ€åˆã®è©¦ã¿ï¼‰**
```rust
// âŒ ã‚¨ãƒ©ãƒ¼: åŒæ™‚ã«è¤‡æ•°ã®å¯å¤‰å€Ÿç”¨
if let Some(record) = state.records.get_mut(&self.task_id) {
    let attempt_id = state.allocate_attempt_id(); // ERROR!
    // record ãŒç”Ÿãã¦ã„ã‚‹é–“ã€state å…¨ä½“ãŒå€Ÿç”¨ä¸­
}
```

- åŸå› : `get_mut()` ã§ `record` ã‚’å–å¾—ã™ã‚‹ã¨ã€`state` å…¨ä½“ã¸ã®å¯å¤‰å€Ÿç”¨ãŒç¶šã
- è§£æ±º: **å‡¦ç†é †åºã‚’å¤‰æ›´**
  1. `state` ã¸ã®æ“ä½œï¼ˆallocate, insertï¼‰ã‚’å…ˆã«å®Ÿè¡Œ
  2. ãã®å¾Œã€`record` ã‚’å–å¾—ã—ã¦æ›´æ–°
- å­¦ã³: å€Ÿç”¨ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨å‡¦ç†é †åºã«ã‚ˆã‚‹è§£æ±º

---

### 2. TaskLease::fail() ã§ã® AttemptRecord ã¨ DecisionRecord è¨˜éŒ²ï¼ˆå®Œäº†ï¼‰ âœ…

**å®Ÿè£…å†…å®¹** (`crates/weaver-core/src/queue/memory.rs:310-377`)

ã‚¿ã‚¹ã‚¯å¤±æ•—æ™‚ã®å®Ÿè¡Œå±¥æ­´ã¨åˆ¤æ–­å±¥æ­´ã‚’è¨˜éŒ²ï¼š

**2.1 AttemptRecord ã®è¨˜éŒ²**ï¼ˆ313-321è¡Œç›®ï¼‰
```rust
let attempt_id = state.allocate_attempt_id();
let attempt_record = AttemptRecord::new(
    attempt_id,
    self.task_id,
    self.envelope.payload().clone(),
    vec![Artifact::Stdout(error.clone())],  // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ observation ã«
    Outcome::failure(error.clone()),
);
state.attempts.insert(attempt_id, attempt_record);
```

**2.2 DecisionRecord ã®è¨˜éŒ²ï¼ˆ2ã¤ã®ãƒ‘ã‚¹ï¼‰**

**ãƒ‘ã‚¹1: ãƒªãƒˆãƒ©ã‚¤ä¸Šé™åˆ°é” â†’ mark_dead**ï¼ˆ327-337è¡Œç›®ï¼‰
```rust
if record.attempts >= record.max_attempts {
    let trigger = serde_json::json!({
        "error": error,
        "attempts": record.attempts,
        "max_attempts": record.max_attempts,
    });
    let decision = DecisionRecord::new(
        self.task_id,
        trigger,
        "retry_policy",
        "mark_dead",
        None,
    );
    record.mark_dead(error);
    state.decisions.push(decision);
    false
}
```

**ãƒ‘ã‚¹2: ãƒªãƒˆãƒ©ã‚¤å®Ÿè¡Œ â†’ schedule_retry**ï¼ˆ338-367è¡Œç›®ï¼‰
```rust
else {
    let delay = self.retry_policy.next_delay(record.attempts);
    let next_run_at = Instant::now() + delay;

    let trigger = serde_json::json!({
        "error": error,
        "attempts": record.attempts,
        "max_attempts": record.max_attempts,
    });
    let context = Some(serde_json::json!({
        "delay_secs": delay.as_secs(),
        "next_run_at": format!("{:?}", next_run_at),
    }));

    let decision = DecisionRecord::new(
        self.task_id,
        trigger,
        "retry_policy",
        "schedule_retry",
        context,
    );
    record.schedule_retry(next_run_at, error);
    state.decisions.push(decision);
    state.scheduled.push(ScheduledTask {
        next_run_at,
        task_id: self.task_id,
    });
    true
}
```

**å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ:**
1. **AttemptRecord ã‚’ä¸¡ãƒ‘ã‚¹ã§å…±é€šåŒ–**: if æ–‡ã®å‰ã§ä½œæˆãƒ»æŒ¿å…¥
2. **DecisionRecord ã¯å„ãƒ‘ã‚¹ã§å€‹åˆ¥ã«è¨˜éŒ²**: åˆ¤æ–­å†…å®¹ãŒç•°ãªã‚‹ãŸã‚
3. **context ã®ä½¿ã„åˆ†ã‘**:
   - mark_dead: `None`ï¼ˆtrigger ã«ååˆ†ãªæƒ…å ±ï¼‰
   - schedule_retry: `Some(delay_secs, next_run_at)`ï¼ˆè¿½åŠ æƒ…å ±ã‚’è¨˜éŒ²ï¼‰
4. **å‡¦ç†é †åºã®å·¥å¤«**: `record` ä½¿ç”¨å¾Œã« `state.decisions.push(decision)`

**å€Ÿç”¨å•é¡Œã®è§£æ±ºï¼ˆç‹¬è‡ªã®è§£æ±ºç­–ï¼‰:**

æœ€åˆã®è©¦ã¿:
```rust
// âŒ ã‚¨ãƒ©ãƒ¼: record ã¸ã®å€Ÿç”¨ä¸­ã« state ã«ã‚¢ã‚¯ã‚»ã‚¹
let Some(record) = state.records.get_mut(&self.task_id) else { ... };
let attempt_id = state.allocate_attempt_id(); // ERROR!
state.decisions.push(decision); // ERROR!
```

è§£æ±ºç­–ï¼ˆè‡ªåˆ†ã§ç™ºè¦‹ï¼‰:
1. AttemptRecord: `record` å–å¾—å‰ã«ä½œæˆãƒ»æŒ¿å…¥
2. DecisionRecord: `record` ä½¿ç”¨**å¾Œ**ã«æŒ¿å…¥

```rust
// âœ… æ­£ã—ã„é †åº
let attempt_id = state.allocate_attempt_id();
state.attempts.insert(attempt_id, attempt_record);

let Some(record) = state.records.get_mut(&self.task_id) else { ... };
// record ã‚’ä½¿ã£ã¦ DecisionRecord ã‚’ä½œæˆ
record.mark_dead(error);
state.decisions.push(decision); // record ä½¿ç”¨å¾Œãªã®ã§ OK!
```

**å­¦ã‚“ã ãƒã‚¤ãƒ³ãƒˆ:**
- Claude ã®ææ¡ˆï¼ˆDecisionRecord ã‚’ä½œæˆãƒ»æŒ¿å…¥ã—ã¦ã‹ã‚‰ record å–å¾—ï¼‰ã¨ã¯åˆ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ç™ºè¦‹
- è‡ªåˆ†ã®è§£æ±ºç­–ã®åˆ©ç‚¹: `record.attempts` ã‚’ç›´æ¥ä½¿ãˆã‚‹ã®ã§å€¤ã®ã‚³ãƒ”ãƒ¼ä¸è¦
- å€Ÿç”¨è¦å‰‡ã«ã¯è¤‡æ•°ã®è§£æ±ºç­–ãŒã‚ã‚Šã€çŠ¶æ³ã«å¿œã˜ãŸæœ€é©è§£ã‚’é¸ã¹ã‚‹

---

### 3. è¨­è¨ˆä¸Šã®ç–‘å•ã¨è­°è«–

å®Ÿè£…ä¸­ã«æ¹§ã„ãŸé‡è¦ãªç–‘å•ã¨ã€ãã‚Œã«å¯¾ã™ã‚‹ç†è§£ï¼š

#### 3.1 InMemoryLease ãŒ queue ã‚’æŒã¤ç†ç”±

**ç–‘å•**: ãªãœ InMemoryLease ã« `Arc<Mutex<InMemoryQueueState>>` ã‚’æŒãŸã›ã‚‹ã®ã‹ï¼Ÿ

**ç†è§£**:
- TaskLease ã¯ Queue ã‹ã‚‰åˆ‡ã‚Šé›¢ã•ã‚Œã¦ Worker ã«æ¸¡ã•ã‚Œã‚‹
- `ack()/fail()` å‘¼ã³å‡ºã—æ™‚ã« Queue ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
- Arc ã«ã‚ˆã‚‹å…±æœ‰æ‰€æœ‰æ¨©ã§ã€Queue æœ¬ä½“ã¨ Lease ãŒåŒã˜çŠ¶æ…‹ã‚’å‚ç…§
- Mutex ã«ã‚ˆã‚Šã€è¤‡æ•° Worker ãŒä¸¦è¡Œã—ã¦ ack/fail ã‚’å‘¼ã‚“ã§ã‚‚å®‰å…¨

**ãƒ‘ã‚¿ãƒ¼ãƒ³**: ã€Œæ‰€æœ‰æ¨©ã®åˆ†æ•£ã€ - Queue æœ¬ä½“ã¨è¤‡æ•°ã® Lease ãŒåŒã˜çŠ¶æ…‹ã‚’å…±æœ‰æ‰€æœ‰

---

#### 3.2 DecisionRecord ã® policy/decision ãŒ String ã§è‰¯ã„ã®ã‹

**ç–‘å•**: å‹å®‰å…¨æ€§ã®ãŸã‚ enum ã«ã™ã¹ãã§ã¯ï¼Ÿ

**ç†è§£**:
- v1 ã®è¨­è¨ˆåˆ¤æ–­: æŸ”è»Ÿæ€§ã‚’å„ªå…ˆ
- Phase 4-5 ã§æ–°ã—ã„ decision ã‚¿ã‚¤ãƒ—ãŒç™»å ´ã™ã‚‹å¯èƒ½æ€§
- ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå›ºã¾ã£ã¦ã‹ã‚‰ enum ã«ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- v1 ã®å“²å­¦: æ—©æœŸã®éå‰°è¨­è¨ˆã‚’é¿ã‘ã‚‹

**ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•**:
- String: æŸ”è»Ÿæ€§é«˜ã€å‹å®‰å…¨æ€§ä½ã€æ‹¡å¼µå®¹æ˜“
- enum: å‹å®‰å…¨æ€§é«˜ã€ç¶²ç¾…æ€§ãƒã‚§ãƒƒã‚¯ã€æ‹¡å¼µæ™‚ã«å‹å®šç¾©å¤‰æ›´å¿…è¦

**ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: ã€Œå®Ÿãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å­¦ã¶ã€ - v1 ã§ String å®Ÿè£…ã€Phase å®Œäº†å¾Œã« enum æ¤œè¨

---

#### 3.3 should_notify ãƒ–ãƒ­ãƒƒã‚¯å†…ã§å¤šãã®å‡¦ç†ã‚’ã—ã¦ã„ã‚‹

**ç–‘å•**: ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ã‚„ã‚Šã™ãã§ã¯ï¼Ÿ

**ç†è§£**:
- æ„å›³çš„ãªè¨­è¨ˆåˆ¤æ–­: **1ã¤ã®ãƒ­ãƒƒã‚¯ã§å…¨å‡¦ç†ã‚’å®Œçµ**
- AttemptRecord + DecisionRecord + TaskRecord ã®æ›´æ–°ã‚’ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å®Ÿè¡Œ
- ãƒ­ãƒƒã‚¯å›æ•°ã®æœ€å°åŒ–ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼‰
- ADR-0003 éµå®ˆ: ãƒ­ãƒƒã‚¯å¤–ã§ notify

**ä»£æ›¿æ¡ˆã¨ã®æ¯”è¼ƒ**:
- è¤‡æ•°ã®å°ã•ãªãƒ­ãƒƒã‚¯: ä¸€è²«æ€§ã®å•é¡Œã€ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰
- ç¾åœ¨ã®è¨­è¨ˆ: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¸€è²«æ€§ã‚’å„ªå…ˆ

**å¤‰æ•°åã®å•é¡Œ**: `should_notify` ã¯èª¤è§£ã‚’æ‹›ãï¼ˆå®Ÿéš›ã¯ã€Œå…¨çŠ¶æ…‹æ›´æ–°ã‚’å®Ÿè¡Œã—ã€å‰¯ä½œç”¨ã¨ã—ã¦ notify ã®è¦å¦ã‚’è¿”ã™ã€ï¼‰

---

#### 3.4 å‡¦ç†é †åºã®å¤‰æ›´ã¯å•é¡Œãªã„ã‹

**ç–‘å•**: DecisionRecord ã®è¨˜éŒ²ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å¤‰ãˆã¦è‰¯ã‹ã£ãŸã®ã‹ï¼Ÿ

**ç†è§£**:
- v1 ã§ã¯å•é¡Œãªã„ç†ç”±:
  1. ã‚¢ãƒˆãƒŸãƒƒã‚¯æ€§: ã™ã¹ã¦åŒã˜ãƒ­ãƒƒã‚¯å†…ã§å®Ÿè¡Œ
  2. å¤±æ•—ã—ãªã„æ“ä½œ: `mark_dead()` ã¨ `schedule_retry()` ã¯å†…éƒ¨çŠ¶æ…‹å¤‰æ›´ã®ã¿
  3. AttemptRecord ãŒå…ˆ: ã€Œä½•ã‚’å®Ÿè¡Œã—ãŸã‹ã€ã¯æ—¢ã«è¨˜éŒ²æ¸ˆã¿

**ç†æƒ³çš„ãªè¨­è¨ˆï¼ˆå°†æ¥çš„ï¼‰**:
- ã‚‚ã— TaskRecord æ›´æ–°ãŒå¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Œã°:
  - åˆ¤æ–­å¾Œã«è¨˜éŒ²: ã€Œå®Ÿè¡Œã•ã‚Œãªã‹ã£ãŸåˆ¤æ–­ã€ã‚’è¨˜éŒ²ã™ã‚‹ãƒªã‚¹ã‚¯
  - å®Ÿè¡Œå¾Œã«è¨˜éŒ²: ã€Œå®Ÿè¡Œã•ã‚ŒãŸåˆ¤æ–­ã®ã¿ã€ã‚’è¨˜éŒ²ï¼ˆç¾åœ¨ã®å®Ÿè£…ï¼‰

**å­¦ã³**: å®Ÿè¡Œã®å‰¯ä½œç”¨ã¨è¨˜éŒ²ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¯ã€åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã‚„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã§é‡è¦ãªæ¦‚å¿µ

---

## ğŸ“ å…¨ä½“ã¨ã—ã¦å­¦ã‚“ã ã“ã¨

### Rust ã®å€Ÿç”¨è¦å‰‡ã®å®Ÿè·µ

**å•é¡Œ**: `state.records.get_mut()` ã§ `record` ã‚’å–å¾—ã™ã‚‹ã¨ã€`state` å…¨ä½“ã¸ã®å¯å¤‰å€Ÿç”¨ãŒç¶šã

**è§£æ±ºç­–ã®ç™ºè¦‹ãƒ—ãƒ­ã‚»ã‚¹**:
1. ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª­ã‚€
2. ã©ã“ã§å€Ÿç”¨ãŒç™ºç”Ÿã—ã€ã©ã“ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ã‚’ç‰¹å®š
3. å‡¦ç†é †åºã‚’å¤‰æ›´ã—ã¦å€Ÿç”¨ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
4. ç‹¬è‡ªã®è§£æ±ºç­–ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆClaude ã®ææ¡ˆã¨ã¯åˆ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰

**é‡è¦ãªå­¦ã³**: Rust ã®å€Ÿç”¨è¦å‰‡ã«ã¯è¤‡æ•°ã®è§£æ±ºç­–ãŒã‚ã‚Šã€çŠ¶æ³ã«å¿œã˜ãŸæœ€é©è§£ã‚’é¸ã¹ã‚‹

---

### ã‚«ãƒ—ã‚»ãƒ«åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³

- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ private ã«ã—ã¦ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã‚’é˜²ã
- public ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã§èª­ã¿å–ã‚Šå°‚ç”¨ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›
- å‘¼ã³å‡ºã—å´ãŒæ‰€æœ‰æ¨©ã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆã¯ `.clone()` ã‚’ä½¿ç”¨
- åˆ©ç‚¹: å†…éƒ¨æ§‹é€ ã‚’å¤‰æ›´ã—ã¦ã‚‚ public API ã‚’ä¿ã¦ã°æ—¢å­˜ã‚³ãƒ¼ãƒ‰ãŒå£Šã‚Œãªã„

---

### å‘½åè¦å‰‡ã®é‡è¦æ€§

- **enum ãƒãƒªã‚¢ãƒ³ãƒˆ**: PascalCase (`Artifact::Stdout`, `OutcomeKind::Success`)
- **ãƒ¡ã‚½ãƒƒãƒ‰ãƒ»é–¢æ•°**: snake_case (`allocate_attempt_id`, `mark_succeeded`)
- **å‹ãƒ»æ§‹é€ ä½“**: PascalCase (`AttemptRecord`, `TaskEnvelope`)
- **å®šæ•°**: SCREAMING_SNAKE_CASE

ãƒãƒªã‚¢ãƒ³ãƒˆã¯å‹ã®ã‚ˆã†ãªã‚‚ã®ï¼ˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼‰ãªã®ã§ PascalCase

---

### è¨­è¨ˆã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•

**String vs enum**:
- v1 ã§ã¯æŸ”è»Ÿæ€§ã‚’å„ªå…ˆï¼ˆStringï¼‰
- ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå›ºã¾ã£ãŸã‚‰å‹å®‰å…¨æ€§ã‚’å„ªå…ˆï¼ˆenumï¼‰
- å®Ÿãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å­¦ã¶ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

**ãƒ­ãƒƒã‚¯ã®ç²’åº¦**:
- 1ã¤ã®å¤§ããªãƒ­ãƒƒã‚¯: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€ä¸€è²«æ€§
- è¤‡æ•°ã®å°ã•ãªãƒ­ãƒƒã‚¯: æŸ”è»Ÿæ€§ã€è¤‡é›‘æ€§

**å‡¦ç†é †åº**:
- å®Ÿè¡Œå‰ã«è¨˜éŒ²: åˆ¤æ–­ã®æ„å›³ã‚’è¨˜éŒ²
- å®Ÿè¡Œå¾Œã«è¨˜éŒ²: å®Ÿéš›ã«è¡Œã‚ã‚ŒãŸã“ã¨ã®ã¿ã‚’è¨˜éŒ²

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±åˆã¨å¿œç”¨

Phase 1-3 ã®ã™ã¹ã¦ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒçµ±åˆã•ã‚ŒãŸå®Ÿè£…:

1. **ID æ¡ç•ª**: `allocate_attempt_id()` - Phase 1 ã®ãƒ‘ã‚¿ãƒ¼ãƒ³å†åˆ©ç”¨
2. **HashMap ç®¡ç†**: Single Source of Truth (ADR-0001)
3. **ãƒ­ãƒƒã‚¯åˆ¶å¾¡**: ãƒ­ãƒƒã‚¯å¤–ã§ã® notify (ADR-0003)
4. **çŠ¶æ…‹é·ç§»**: `mark_succeeded`, `mark_dead`, `schedule_retry` (ADR-0002)
5. **å±¥æ­´è¨˜éŒ²**: AttemptRecord, DecisionRecord ã®è¿½åŠ ï¼ˆPhase 3ï¼‰

ç‰¹ã«ã€fail() ã§ AttemptRecord ã‚’ if æ–‡ã®å¤–ã«å‡ºã—ã¦å…±é€šåŒ–ã—ãŸåˆ¤æ–­ãŒå„ªã‚Œã¦ã„ã‚‹:
- ã€Œå¤±æ•—ã—ãŸäº‹å®Ÿã€ã®è¨˜éŒ²ã¨ã€Œã©ã†åˆ¤æ–­ã—ãŸã‹ã€ã®è¨˜éŒ²ã‚’æ˜ç¢ºã«åˆ†é›¢

---

## ğŸ‰ Phase 3 å®Ÿè£…éƒ¨åˆ†å®Œäº†ï¼

**å®Œäº†ã—ãŸæ©Ÿèƒ½:**
1. âœ… AttemptRecord / DecisionRecord ã®å‹å®šç¾©
2. âœ… InMemoryQueueState ã¸ã®çµ±åˆ
3. âœ… TaskLease::ack() ã§ã® AttemptRecord è¨˜éŒ²
4. âœ… TaskLease::fail() ã§ã® AttemptRecord / DecisionRecord è¨˜éŒ²

**æ®‹ã‚Šã®ã‚¿ã‚¹ã‚¯ï¼ˆå°†æ¥ï¼‰:**
- å±¥æ­´å–å¾— APIï¼ˆPhase 7 ã§å®Ÿè£…äºˆå®šï¼‰
- Job ãƒ¬ãƒ™ãƒ«ã§ã®å±¥æ­´é›†ç´„ï¼ˆPhase 7 ã§å®Ÿè£…äºˆå®šï¼‰

**ãƒ†ã‚¹ãƒˆçµæœ:**
```
running 22 tests
test result: ok. 22 passed; 0 failed; 0 ignored
```

å…¨ãƒ†ã‚¹ãƒˆãŒé€šã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚‚æˆåŠŸã€‚Phase 3 ã®å®Ÿè£…éƒ¨åˆ†ãŒå®Œäº†ã—ã¾ã—ãŸï¼

---

## ğŸ“š å‚è€ƒè³‡æ–™

- è¦ä»¶: `dev/docs/requirements/2025_12_27_weaver_requirements.md`
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£: `CLAUDE.md`
- ADR-0001: TaskId ã®ã¿ã‚’ä¿æŒã™ã‚‹3ã¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆ†é›¢
- ADR-0002: TaskRecord ã¸ã®çŠ¶æ…‹é·ç§»ã®é›†ç´„
- ADR-0003: ãƒ­ãƒƒã‚¯å¤–ã§ã® notify ã«ã‚ˆã‚‹éåŒæœŸå®‰å…¨æ€§

---

## ğŸ”œ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

Phase 3 ã®å®Ÿè£…éƒ¨åˆ†ãŒå®Œäº†ã—ãŸã®ã§ã€æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºå€™è£œ:

- **Phase 4**: Task åˆ†è§£ï¼ˆDecompositionï¼‰ - Decider trait ã®è¨­è¨ˆã¨å®Ÿè£…
- **Phase 5**: ä¾å­˜é–¢ä¿‚ç®¡ç† - ã‚¿ã‚¹ã‚¯é–“ã®é †åºåˆ¶å¾¡
- **Phase 6**: Budget ã¨ Stuck æ¤œçŸ¥ - ç„¡é™ãƒ«ãƒ¼ãƒ—ã®é˜²æ­¢
- **Phase 7**: API ã®å®Ÿè£… - get_status, cancel_job, get_result

Phase 4 ãŒæ¬¡ã®è‡ªç„¶ãªã‚¹ãƒ†ãƒƒãƒ—ã¨æ€ã‚ã‚Œã¾ã™ã€‚

---

---

## ğŸ“… Phase 4 è¨­è¨ˆè­°è«–ï¼ˆ2025-12-30 ç¶šãï¼‰

Phase 3 å®Œäº†å¾Œã€Phase 4ï¼ˆTask åˆ†è§£ï¼‰ã®è¨­è¨ˆã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚å®Ÿè£…å‰ã«è¨­è¨ˆã‚’æ·±ãç†è§£ã™ã‚‹æ™‚é–“ã‚’å–ã‚Šã€é‡è¦ãªè¨­è¨ˆåˆ¤æ–­ã‚’è¡Œã„ã¾ã—ãŸã€‚

### Phase 4 ã®ç›®æ¨™

- Decider trait ã®è¨­è¨ˆï¼ˆç´”ç²‹é–¢æ•°ã¨ã—ã¦å®Ÿè£…ï¼‰
- åˆ†è§£ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆTaskSpec â†’ è¤‡æ•°ã® TaskSpecï¼‰
- è¦ªå­é–¢ä¿‚ã®ç®¡ç†
- å­ã‚¿ã‚¹ã‚¯å®Œäº†æ™‚ã®è¦ªã‚¿ã‚¹ã‚¯å‡¦ç†

### è¨­è¨ˆè­°è«–ã®æµã‚Œ

#### 1. åˆ†è§£ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼ˆã„ã¤åˆ†è§£ã™ã‚‹ã‹ï¼Ÿï¼‰

**3ã¤ã®é¸æŠè‚¢ã‚’æ¤œè¨:**
- Option A: ã‚¿ã‚¹ã‚¯ä½œæˆæ™‚ã«åˆ†è§£å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
- Option B: å®Ÿè¡Œæ™‚ï¼ˆHandler ãŒ "åˆ†è§£ãŒå¿…è¦" ã‚’è¿”ã™ï¼‰
- Option C: å®Ÿè¡Œå¤±æ•—æ™‚ã«åˆ†è§£ã‚’è©¦ã¿ã‚‹

**è­°è«–ã®çµæœ:**
- **Option C ã‚’æ¡ç”¨**ï¼ˆLLM ã«ã‚ˆã‚‹å®Ÿè¡Œã‚’æƒ³å®šã—ã€æƒ…å ±ä¸è¶³ã‚„ã‚¿ã‚¹ã‚¯å˜ä½ãŒå¤§ãã™ãã¦å¤±æ•—ã™ã‚‹å ´åˆã‚’è€ƒæ…®ï¼‰
- ãŸã ã—ã€**Option B ã‚‚å¿…è¦**ã¨æ°—ã¥ãï¼ˆHandler ãŒå®Ÿè¡Œå‰ã«ã€Œå¤§ãã™ãã‚‹ã€ã¨åˆ¤æ–­ã™ã‚‹ã‚±ãƒ¼ã‚¹ã‚‚ã‚ã‚‹ï¼‰

**é‡è¦ãªæ´å¯Ÿ:**
> ã€ŒHandler ãŒã§ããªã„ã£ã¦è¿”ã™ã®ã¨å¤±æ•—ã£ã¦è¿”ã™ã®ã£ã¦çµå±€ã©ã¡ã‚‰ã‚‚å—ã‘å–ã‚‹ã¨ã“ã‚ãŒä¸€ç·’ã®ã‚ˆã†ã«æ„Ÿã˜ã‚‹ã€

**çµè«–:**
- Option B ã¨ C ã®é•ã„ã¯ Handler ã®**å†…éƒ¨å®Ÿè£…ã®è©³ç´°**
- **å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯åŒã˜**ï¼ˆã©ã¡ã‚‰ã‚‚ Outcome ã‚’è¿”ã™ï¼‰
- Handler ã¯å¸¸ã« Outcome ã‚’è¿”ã—ã€Decider ãŒæ¬¡ã®æ‰‹ã‚’åˆ¤æ–­ã™ã‚‹

---

#### 2. Decider ã®è²¬å‹™ç¯„å›²ï¼ˆä½•ã‚’åˆ¤æ–­ã™ã‚‹ã‹ï¼Ÿï¼‰

**åˆ¤æ–­ã®ç¨®é¡ã‚’æ•´ç†:**
1. Attempt ãƒ™ãƒ¼ã‚¹ã®åˆ¤æ–­ï¼ˆè©¦è¡Œå›æ•°ã€ãƒªãƒˆãƒ©ã‚¤ã€ãƒãƒƒã‚¯ã‚ªãƒ•ï¼‰
2. æˆåŠŸçµæœã®æ¤œè¨¼ï¼ˆOutcome::Success ã ãŒæœ¬å½“ã«æˆåŠŸã‹ï¼Ÿï¼‰
3. å¤±æ•—æ™‚ã®æˆ¦ç•¥é¸æŠï¼ˆãƒªãƒˆãƒ©ã‚¤/åˆ†è§£/è«¦ã‚ã‚‹ï¼‰
4. BLOCKED æ™‚ã®å¯¾å‡¦ï¼ˆä¾å­˜è¿½åŠ /åˆ†è§£/ä»‹å…¥å¾…ã¡ï¼‰

**3ã¤ã®è²¬å‹™ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ¤œè¨:**
- **ç‹­ã„ã‚¹ã‚³ãƒ¼ãƒ—**: Decider = æ¬¡ã«ä½•ã‚’ã™ã¹ãã‹ã®åˆ¤æ–­ã®ã¿
- **åºƒã„ã‚¹ã‚³ãƒ¼ãƒ—**: Decider = Outcome ã®è§£é‡ˆ + æ¬¡ã®æ‰‹ã®åˆ¤æ–­
- **ä¸­é–“ã‚¹ã‚³ãƒ¼ãƒ—**: Decider = Outcome ã®æ¤œè¨¼ + æ¬¡ã®æ‰‹ã®åˆ¤æ–­

**è­°è«–ã®çµæœ:**
> ã€ŒæˆåŠŸçµæœã®æ¤œè¨¼ã¯ future work ã«ã—ã¡ã‚ƒã£ã¦ã„ã„æ°—ãŒã—ã¾ã™ã€‚ã—ã°ã‚‰ãã¯ Handler ã® Outcome ã‚’ä¿¡ã˜ã¦ã€å¤±æ•—æ™‚ã®ã¿åˆ¤æ–­ã‚’ã•ã›ã‚‹ã®ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ã€

> ã€Œattempt ãƒ™ãƒ¼ã‚¹ã®åˆ¤æ–­ã¯ Decider ã®ä»•äº‹ã˜ã‚ƒãªã„ã‚“ã§ã—ãŸã£ã‘ï¼Ÿweaver-core ã®æ©Ÿèƒ½ã¨ã—ã¦ã® attempt ãªã©ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸæ¬¡ã®æ“ä½œã®åˆ¤æ–­ã¨ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚«ã‚¹ã‚¿ãƒ é–¢æ•°ã¨ã—ã¦ã€æ¬¡ã«å®Ÿè¡Œã™ã‚‹å†…å®¹ã‚’æ±ºã‚ã‚‹ AI Agent ã‚’è¨­å®šã§ãã‚‹ã¨ã„ã„ã‹ã¨æ€ã£ã¦ã„ã¾ã™ã€

**é‡è¦ãªè¨­è¨ˆåˆ¤æ–­: 2å±¤ã® Decider ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**

1. **weaver-core ã® Deciderï¼ˆPhase 4-1ï¼‰:**
   - attempt ãƒ™ãƒ¼ã‚¹ã®åˆ¤æ–­ï¼ˆretry å›æ•°ã€ãƒãƒƒã‚¯ã‚ªãƒ•ï¼‰
   - budget ãƒ™ãƒ¼ã‚¹ã®åˆ¤æ–­ï¼ˆdeadlineã€cost è¶…éï¼‰
   - ã‚·ãƒ³ãƒ—ãƒ«ã§æ±ç”¨çš„ãªåˆ¤æ–­

2. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚«ã‚¹ã‚¿ãƒ  Deciderï¼ˆå°†æ¥ï¼‰:**
   - AI Agent ã«ã‚ˆã‚‹é«˜åº¦ãªåˆ¤æ–­ï¼ˆã‚¿ã‚¹ã‚¯åˆ†è§£ã€ä»£æ›¿æˆ¦ç•¥ï¼‰
   - ãƒ‰ãƒ¡ã‚¤ãƒ³å›ºæœ‰ã®ãƒ­ã‚¸ãƒƒã‚¯
   - **weaver-core ã®ã‚¹ã‚³ãƒ¼ãƒ—å¤–**

**è²¬å‹™åˆ†æ‹…ï¼ˆç¢ºå®šï¼‰:**
- **Handler**: å®Ÿè¡Œã—ã¦ Outcome ã‚’è¿”ã™ï¼ˆSUCCESS/FAILURE/BLOCKED ã‚’åˆ¤æ–­ï¼‰
- **weaver-core Decider**: Outcome + attempt æƒ…å ± â†’ retry/stop åˆ¤æ–­
- **ã‚«ã‚¹ã‚¿ãƒ  Decider**: Outcome + ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ â†’ é«˜åº¦ãªåˆ¤æ–­ï¼ˆåˆ†è§£ãªã©ï¼‰

**æˆåŠŸçµæœã®æ¤œè¨¼**: Future workï¼ˆä»Šã¯ Handler ã®åˆ¤æ–­ã‚’ä¿¡ã˜ã‚‹ï¼‰

---

#### 3. Handler ãŒ Outcome ã‚’è¿”ã™ã¹ãã‹ï¼Ÿ

**2ã¤ã®é¸æŠè‚¢ã‚’æ¤œè¨:**

**é¸æŠè‚¢ 1: TaskLease::complete(outcome) ã‚’è¿½åŠ **
- é•·æ‰€: æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’å£Šã•ãªã„ã€å¾Œæ–¹äº’æ›æ€§
- çŸ­æ‰€: API ãŒè¤‡é›‘ï¼ˆack/fail/completeï¼‰ã€Worker ã®å®Ÿè£…ãŒè¤‡é›‘

**é¸æŠè‚¢ 2: Handler ãŒ Outcome ã‚’è¿”ã™**
- é•·æ‰€: è¨­è¨ˆãŒæ˜ç¢ºã€è¦ä»¶ã¨ã®æ•´åˆæ€§ã€æ‹¡å¼µæ€§
- çŸ­æ‰€: æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ãŒå¿…è¦

**è­°è«–ã®çµæœ:**
> ã€Œ2ã®ã‚ˆã†ãªæ°—ãŒã™ã‚‹ã€‚ã—ã‹ã—ã€çµ¶å¯¾ã¨ã¯è¨€ã„åˆ‡ã‚Œãªã„æ°—æŒã¡ã‚‚ã‚ã‚‹ã€ï¼ˆè¨­è¨ˆã®ä¸ç¢ºå®Ÿæ€§ï¼‰

**æœ€çµ‚æ±ºå®š:**
> ã€Œå¾Œæ–¹äº’æ›æ€§ã‚„ç§»è¡Œã‚³ã‚¹ãƒˆã¯è€ƒãˆãªãã¦ã„ã„ã§ã™ã€‚è¨­è¨ˆã®ä¸ç¢ºå®Ÿæ€§ã®æ–¹ã§ã™ã­ã€‚2ã§ã„ãã¾ã—ã‚‡ã†ã€

**é¸æŠè‚¢ 2 ã‚’æ¡ç”¨** - Handler ãŒ Outcome ã‚’è¿”ã™è¨­è¨ˆ

**è¦ä»¶ã¨ã®æ•´åˆæ€§:**
- è¦ä»¶: "å…¥åŠ›: ç¾åœ¨çŠ¶æ…‹ + **è¦³æ¸¬/çµæœ**ã€å‡ºåŠ›: æ¬¡ã®æ“ä½œ"
- å®Ÿè£…: Handler ãŒ Outcomeï¼ˆè¦³æ¸¬/çµæœï¼‰ã‚’è¿”ã—ã€Decider ãŒ Decisionï¼ˆæ¬¡ã®æ“ä½œï¼‰ã‚’è¿”ã™

---

#### 4. Decision enum ã¨ Decider trait ã®è¨­è¨ˆ

**Phase 4-1 ã® Decision enum:**
```rust
pub enum Decision {
    Retry { delay: Duration, reason: String },
    MarkDead { reason: String },
}
```

**è¨­è¨ˆåˆ¤æ–­:**
- `reason` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å¿…è¦ï¼ˆãƒ­ã‚°ã¨ DecisionRecord è¨˜éŒ²ã«æœ‰ç”¨ï¼‰
- Retry ã«ä»–ã®æƒ…å ±ã¯**ã¨ã‚Šã‚ãˆãšã„ã‚‰ãªã„**
- `Stop` ã‚ˆã‚Š `MarkDead` ã®æ–¹ãŒæ˜ç¢ºï¼ˆTaskRecord ã® `mark_dead` ã¨å¯¾å¿œï¼‰

**Decider trait:**
```rust
pub trait Decider {
    fn decide(&self, task: &TaskRecord, outcome: &Outcome) -> Decision;
}
```

**è¨­è¨ˆåˆ¤æ–­:**
- Success ã®å ´åˆã¯ Decider ã‚’å‘¼ã°ãªã„ï¼ˆack() ã—ã¦çµ‚äº†ï¼‰
- Decider ã¯ FAILURE/BLOCKED ã®å ´åˆã®ã¿å‘¼ã¶
- å…¥åŠ›: `&TaskRecord` + `&Outcome` ã§ååˆ†

**Chain of Responsibility ãƒ‘ã‚¿ãƒ¼ãƒ³:**
- è¤‡æ•°ã® Decider ã‚’çµ„ã¿åˆã‚ã›ã‚‹ä»•çµ„ã¿
- **Future work**ï¼ˆPhase 4-1 ã§ã¯å®Ÿè£…ã—ãªã„ï¼‰

---

### Phase 4-1 ã¨ Phase 4-2 ã®åˆ†å‰²

**Phase 4-1: æœ€å°é™ã® Deciderï¼ˆretry ã®ã¿ï¼‰**
- Decision enumï¼ˆRetry/MarkDead ã®ã¿ï¼‰
- Decider trait ã®å®šç¾©
- DefaultDecider ã®å®Ÿè£…ï¼ˆæ—¢å­˜ã® RetryPolicy ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç§»è¡Œï¼‰
- Handler â†’ Outcome â†’ Decider â†’ Decision ã®ãƒ•ãƒ­ãƒ¼ç¢ºç«‹

**Phase 4-2: åˆ†è§£æ©Ÿèƒ½ã®è¿½åŠ **
- Decision::Decompose ã‚’è¿½åŠ 
- è¦ªå­é–¢ä¿‚ã®å®Ÿè£…
- åˆ†è§£å¾Œã®å‡¦ç†

**åˆ†å‰²ã®ç†ç”±:**
> ã€Œæ®µéšçš„ã«æ±ºã‚ã¾ã—ã‚‡ã†ã€ - ä¸€åº¦ã«å…¨éƒ¨æ±ºã‚ã‚‹ã®ã§ã¯ãªãã€å®Ÿè£…ã—ãªãŒã‚‰å­¦ã¶ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

---

### å®Ÿè£…é–‹å§‹ï¼ˆPhase 4-1ï¼‰

**å®Œäº†ã—ãŸå®Ÿè£…:**
1. âœ… `domain/decision.rs` ã®ä½œæˆ
2. âœ… Decision enum ã®å®šç¾©ï¼ˆRetry/MarkDeadï¼‰
3. âœ… Decider trait ã®å®šç¾©

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
- DefaultDecider ã®å®Ÿè£…ï¼ˆRetryPolicy ãƒ­ã‚¸ãƒƒã‚¯ã®ç§»è¡Œï¼‰
- TaskHandler trait ã®å¤‰æ›´ï¼ˆOutcome ã‚’è¿”ã™ï¼‰
- TaskLease ã®å¤‰æ›´ï¼ˆcomplete ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- Worker ã®å¤‰æ›´ï¼ˆæ–°ã—ã„ãƒ•ãƒ­ãƒ¼ï¼‰

---

## ğŸ“ Phase 4 è¨­è¨ˆã§å­¦ã‚“ã ã“ã¨

### è¨­è¨ˆã®ä¸ç¢ºå®Ÿæ€§ã¨ã®å‘ãåˆã„æ–¹

> ã€Œçµ¶å¯¾ã¨ã¯è¨€ã„åˆ‡ã‚Œãªã„æ°—æŒã¡ã‚‚ã‚ã‚‹ã€

è¨­è¨ˆåˆ¤æ–­ã«ãŠã„ã¦ä¸ç¢ºå®Ÿæ€§ã‚’èªè­˜ã—ã€ãã‚Œã§ã‚‚æ±ºæ–­ã‚’ä¸‹ã™ã€‚v1 ã§ã¯æ­£ã—ã„è¨­è¨ˆã‚’è¿½æ±‚ã—ã€å®Ÿè£…ã—ãªãŒã‚‰å­¦ã¶ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã€‚

### è²¬å‹™åˆ†æ‹…ã®é‡è¦æ€§

Handlerã€Deciderã€weaver-coreã€ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…ã®è²¬å‹™ã‚’æ˜ç¢ºã«åˆ†é›¢ï¼š
- **Handler**: å®Ÿè¡Œ + è¦³æ¸¬ï¼ˆOutcomeï¼‰
- **Decider**: åˆ¤æ–­ï¼ˆç´”ç²‹é–¢æ•°ï¼‰
- **weaver-core**: åŸºæœ¬çš„ãª retry/budget åˆ¤æ–­
- **ã‚«ã‚¹ã‚¿ãƒ **: AI Agent ãªã©ã®é«˜åº¦ãªåˆ¤æ–­

### æ®µéšçš„ãªè¨­è¨ˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

Phase 4 ã‚’ Phase 4-1ï¼ˆretry ã®ã¿ï¼‰ã¨ Phase 4-2ï¼ˆåˆ†è§£ï¼‰ã«åˆ†å‰²ã€‚è¤‡é›‘ãªæ©Ÿèƒ½ã‚’æ®µéšçš„ã«å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€å­¦ç¿’ã—ãªãŒã‚‰é€²ã‚ã‚‰ã‚Œã‚‹ã€‚

### è¦ä»¶ã¨ã®æ•´åˆæ€§ã®ç¢ºèª

è¨­è¨ˆåˆ¤æ–­æ™‚ã«è¦ä»¶ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ç«‹ã¡è¿”ã‚Šã€ã€Œè¦³æ¸¬/çµæœ â†’ æ¬¡ã®æ“ä½œã€ã¨ã„ã†è¦ä»¶ãŒ Handler â†’ Outcome â†’ Decider â†’ Decision ã®è¨­è¨ˆã«å¯¾å¿œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã€‚

### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®çµ±ä¸€

Option B ã¨ Cï¼ˆåˆ†è§£ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼‰ã®é•ã„ã¯å®Ÿè£…ã®è©³ç´°ã§ã‚ã‚Šã€å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆOutcome ã‚’è¿”ã™ï¼‰ã¯çµ±ä¸€ã§ãã‚‹ã“ã¨ã«æ°—ã¥ã„ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šè¨­è¨ˆãŒã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚‹ã€‚

---

## ğŸ“š å‚è€ƒè³‡æ–™ï¼ˆPhase 4ï¼‰

- è¦ä»¶: `dev/docs/requirements/2025_12_27_weaver_requirements.md` (ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 6.2, 11)
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£: `CLAUDE.md`
- ADR-0005: Decider ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆææ¡ˆä¸­ï¼‰ â† ã“ã‚Œã‹ã‚‰ä½œæˆ
