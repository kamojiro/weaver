# Weaver v2 å­¦ç¿’è¨˜éŒ² - 2026-01-06

## ğŸ“… ä»Šæ—¥ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³

**é–‹å§‹æ—¥æ™‚:** 2026-01-06
**ãƒ•ã‚§ãƒ¼ã‚º:** Week 1 - éª¨æ ¼ã¨ Typed APIï¼ˆæ­£ã—ã•ã®åœŸå°ï¼‰
**ã‚¿ã‚¹ã‚¯:** PR-3: Typed Task API

---

## ğŸ¯ ä»Šæ—¥ã®ç›®æ¨™

- [ ] å‹ä»˜ã Task API ã®è¨­è¨ˆã‚’ç†è§£ã™ã‚‹
- [ ] Task / Handler / TypedRegistry / DynHandler ã‚’å®Ÿè£…ã™ã‚‹
- [ ] èµ·å‹•æ™‚æ¤œè¨¼ï¼ˆexpect_tasksï¼‰ã‚’å®Ÿè£…ã™ã‚‹
- [ ] ãƒ†ã‚¹ãƒˆã§å‹å®‰å…¨æ€§ã‚’ç¢ºèªã™ã‚‹
- [ ] PR-3: Typed Task APIï¼ˆå®Œäº†ï¼‰

---

## â³ PR-3: Typed Task APIï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

### ğŸ“‹ ã‚¿ã‚¹ã‚¯ã®æ¦‚è¦

task_type ã® typo ã‚’å‹ã§æ’é™¤ã—ã€Handler ã¨ã®å¯¾å¿œä»˜ã‘ã‚’é™çš„ã«ä¿è¨¼ã™ã‚‹å‹ä»˜ã Task API ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
å†…éƒ¨è¡¨ç¾ã¯ `task_type: String` ã‚’ç¶­æŒã—ã¤ã¤ã€åˆ©ç”¨è€…å‘ã‘ã«ã¯å‹å®‰å…¨ãª API ã‚’æä¾›ã™ã‚‹ã€ŒäºŒå±¤æ§‹é€ ã€ãŒç‰¹å¾´ã§ã™ã€‚

### ğŸ¯ å­¦ç¿’ç›®æ¨™

ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã® Rust ã®æ¦‚å¿µã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ï¼š

1. **Associated Constants** - `const TYPE: &'static str` ã«ã‚ˆã‚‹å‹ã¨ãƒªãƒ†ãƒ©ãƒ«ã®çµã³ã¤ã‘
2. **Trait Object ã¨ Object Safety** - `dyn Trait` ãŒå¯èƒ½ãªæ¡ä»¶ã¨åˆ¶ç´„
3. **Type Erasure ãƒ‘ã‚¿ãƒ¼ãƒ³** - ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ â†’ trait object ã¸ã®å¤‰æ›
4. **Phantom Type ã¨ Generic Bounds** - `Handler<T: Task>` ã«ã‚ˆã‚‹å‹ãƒ¬ãƒ™ãƒ«ã®å¯¾å¿œä»˜ã‘

### ğŸ“Š è¨­è¨ˆã®å…¨ä½“åƒ

#### äºŒå±¤æ§‹é€ ã®ã­ã‚‰ã„

```
åˆ©ç”¨è€…å´ï¼ˆå‹ä»˜ãï¼‰              å†…éƒ¨ï¼ˆå‹æ¶ˆå»ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Task trait                    â†’ DynHandler trait
Handler<T: Task>              â†’ Box<dyn DynHandler>
TypedRegistry::register<T>()  â†’ HashMap<String, Arc<dyn DynHandler>>
enqueue_typed<T>(task)        â†’ TaskEnvelope { task_type: String, ... }
```

**ãªãœäºŒå±¤æ§‹é€ ãŒå¿…è¦ã‹ï¼Ÿ**
- åˆ©ç”¨è€…å´: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« task_type ã¨ Handler ã®å¯¾å¿œã‚’ä¿è¨¼ï¼ˆtypo æ’é™¤ï¼‰
- å†…éƒ¨å´: å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã§è¤‡æ•°ã® Handler ã‚’æ‰±ãˆã‚‹ï¼ˆHashMap ã«æ ¼ç´ï¼‰

### ğŸ“ å®Ÿè£…ã™ã¹ãå†…å®¹

**å¤‰æ›´ãƒ»è¿½åŠ ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:**
1. `crates/weaver-core/src/typed/task.rs` - Task trait
2. `crates/weaver-core/src/typed/handler.rs` - Handler trait + DynHandler trait
3. `crates/weaver-core/src/typed/registry.rs` - TypedRegistry
4. `crates/weaver-core/src/typed/codec.rs` - PayloadCodecï¼ˆSerialize/Deserializeï¼‰
5. `crates/weaver-core/src/typed/mod.rs` - ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆ
6. `crates/weaver-core/src/app/builder.rs` - expect_tasks() ãƒ¡ã‚½ãƒƒãƒ‰è¿½åŠ 

### âœ… æ©Ÿèƒ½è¦ä»¶

#### 1. Task traitï¼ˆtyped/task.rsï¼‰

```rust
/// Task ã¯å®Ÿè¡Œå¯èƒ½ãªä½œæ¥­å˜ä½ã‚’è¡¨ã™ trait
///
/// task_type ã‚’å‹ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã™ã‚‹ã“ã¨ã§ã€Handler ã¨ã®å¯¾å¿œä»˜ã‘ã‚’
/// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä¿è¨¼ã—ã¾ã™ã€‚
pub trait Task: Serialize + DeserializeOwned + Send + Sync + 'static {
    /// ã“ã® Task ã® task_type è­˜åˆ¥å­ï¼ˆä¾‹: "my_app.process.v1"ï¼‰
    const TYPE: &'static str;
}
```

**å®Ÿè£…ã™ã¹ãå†…å®¹:**
- [ ] Task trait ã®å®šç¾©ï¼ˆä¸Šè¨˜ï¼‰
- [ ] `#[async_trait]` ã¯ä¸è¦ï¼ˆãƒ¡ã‚½ãƒƒãƒ‰ãªã—ï¼‰
- [ ] ãƒ†ã‚¹ãƒˆç”¨ã®å…·ä½“çš„ãª Task å‹ã‚’ 2-3 å€‹å®šç¾©ï¼ˆä¾‹: TestTask, AnotherTaskï¼‰

#### 2. Handler trait + DynHandler traitï¼ˆtyped/handler.rsï¼‰

**Handler traitï¼ˆå‹ä»˜ãå´ï¼‰:**
```rust
/// Handler ã¯ Task ã‚’å—ã‘å–ã£ã¦ Outcome ã‚’è¿”ã™å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
///
/// ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã«ã‚ˆã‚Šã€Handler<TestTask> ã¯ TestTask ã—ã‹å—ã‘å–ã‚Œãªã„
/// ã¨ã„ã†å‹å®‰å…¨æ€§ã‚’æä¾›ã—ã¾ã™ã€‚
#[async_trait]
pub trait Handler<T: Task>: Send + Sync {
    async fn handle(&self, task: T) -> Result<Outcome, WeaverError>;
}
```

**DynHandler traitï¼ˆå‹æ¶ˆå»å´ï¼‰:**
```rust
/// DynHandler ã¯ object-safe ãª trait ã§ã€HashMap ã«æ ¼ç´å¯èƒ½
///
/// deserialize + handle ã‚’ä¸€ä½“åŒ–ã™ã‚‹ã“ã¨ã§ã€
/// serde_json::Value ã‹ã‚‰ã®å¾©å…ƒã¨å®Ÿè¡Œã‚’ä¸€æ‹¬ã§è¡Œãˆã¾ã™ã€‚
#[async_trait]
pub trait DynHandler: Send + Sync {
    /// payloadï¼ˆJSONï¼‰ã‹ã‚‰ Task ã‚’ deserialize ã—ã¦ handle ã‚’å®Ÿè¡Œ
    async fn handle_dyn(&self, payload: serde_json::Value) -> Result<Outcome, WeaverError>;

    /// ã“ã® Handler ãŒæ‰±ã† task_type ã‚’è¿”ã™
    fn task_type(&self) -> &str;
}
```

**TypedHandler<T> â†’ DynHandler adapter:**
```rust
/// TypedHandler<T> ã¯ Handler<T> ã‚’ DynHandler ã«å¤‰æ›ã™ã‚‹ adapter
///
/// ã“ã‚Œã«ã‚ˆã‚Šã€å‹ä»˜ã Handler ã‚’ HashMap<String, Arc<dyn DynHandler>> ã«
/// æ ¼ç´ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
struct TypedHandler<T, H> {
    handler: H,
    _marker: PhantomData<T>,
}

#[async_trait]
impl<T: Task, H: Handler<T>> DynHandler for TypedHandler<T, H> {
    async fn handle_dyn(&self, payload: serde_json::Value) -> Result<Outcome, WeaverError> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // 1. payload ã‚’ T ã« deserialize
        // 2. self.handler.handle(task) ã‚’å‘¼ã¶
        // 3. Result ã‚’è¿”ã™
        todo!()
    }

    fn task_type(&self) -> &str {
        T::TYPE
    }
}
```

**å®Ÿè£…ã™ã¹ãå†…å®¹:**
- [ ] Handler<T> trait ã®å®šç¾©
- [ ] DynHandler trait ã®å®šç¾©
- [ ] TypedHandler<T, H> struct ã®å®šç¾©
- [ ] TypedHandler ã® DynHandler å®Ÿè£…ï¼ˆhandle_dyn ã®å®Ÿè£…ï¼‰
- [ ] ãƒ†ã‚¹ãƒˆç”¨ã®å…·ä½“çš„ãª Handler ã‚’ 2-3 å€‹å®šç¾©

#### 3. TypedRegistryï¼ˆtyped/registry.rsï¼‰

```rust
/// TypedRegistry ã¯ Task ã¨ Handler ã‚’ç™»éŒ²ãƒ»ç®¡ç†ã™ã‚‹
///
/// å†…éƒ¨çš„ã«ã¯ HashMap<String, Arc<dyn DynHandler>> ã§ç®¡ç†ã—ã€
/// register<T>() ã§å‹å®‰å…¨ã«ç™»éŒ²ã§ãã¾ã™ã€‚
pub struct TypedRegistry {
    handlers: HashMap<String, Arc<dyn DynHandler>>,
}

impl TypedRegistry {
    pub fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }

    /// å‹ä»˜ã Handler ã‚’ç™»éŒ²
    ///
    /// # Type Safety
    /// - Handler<T> ã® T::TYPE ãŒè‡ªå‹•çš„ã«ä½¿ã‚ã‚Œã‚‹
    /// - åŒã˜ task_type ã‚’äºŒé‡ç™»éŒ²ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼
    pub fn register<T: Task, H: Handler<T> + 'static>(
        &mut self,
        handler: H,
    ) -> Result<(), RegistryError> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // 1. T::TYPE ã‚’å–å¾—
        // 2. ã™ã§ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
        // 3. TypedHandler::new(handler) ã‚’ä½œæˆ
        // 4. Arc::new() ã§ãƒ©ãƒƒãƒ—ã—ã¦ HashMap ã«æŒ¿å…¥
        todo!()
    }

    /// task_type ã«å¯¾å¿œã™ã‚‹ DynHandler ã‚’å–å¾—
    pub fn get(&self, task_type: &str) -> Option<Arc<dyn DynHandler>> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        todo!()
    }

    /// ç™»éŒ²æ¸ˆã¿ã® task_type ä¸€è¦§ã‚’å–å¾—
    pub fn registered_types(&self) -> Vec<String> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        todo!()
    }
}
```

**å®Ÿè£…ã™ã¹ãå†…å®¹:**
- [ ] TypedRegistry struct ã®å®šç¾©
- [ ] register<T, H>() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] get() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] registered_types() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] RegistryError å‹ã®å®šç¾©ï¼ˆä¾‹: AlreadyRegistered, NotFoundï¼‰
- [ ] ãƒ†ã‚¹ãƒˆä½œæˆï¼ˆç™»éŒ²ãƒ»å–å¾—ãƒ»äºŒé‡ç™»éŒ²ã‚¨ãƒ©ãƒ¼ï¼‰

#### 4. PayloadCodecï¼ˆtyped/codec.rsï¼‰

```rust
/// PayloadCodec ã¯ Task ã¨ serde_json::Value é–“ã®å¤‰æ›ã‚’æ‹…å½“
pub struct PayloadCodec;

impl PayloadCodec {
    /// Task ã‚’ serde_json::Value ã« serialize
    pub fn encode<T: Task>(task: &T) -> Result<serde_json::Value, CodecError> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // serde_json::to_value() ã‚’ä½¿ã†
        todo!()
    }

    /// serde_json::Value ã‹ã‚‰ Task ã‚’ deserialize
    pub fn decode<T: Task>(payload: serde_json::Value) -> Result<T, CodecError> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // serde_json::from_value() ã‚’ä½¿ã†
        todo!()
    }
}
```

**å®Ÿè£…ã™ã¹ãå†…å®¹:**
- [ ] PayloadCodec struct ã®å®šç¾©
- [ ] encode<T>() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] decode<T>() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] CodecError å‹ã®å®šç¾©
- [ ] ãƒ†ã‚¹ãƒˆä½œæˆï¼ˆencode/decode ã®ãƒ©ã‚¦ãƒ³ãƒ‰ãƒˆãƒªãƒƒãƒ—ï¼‰

#### 5. èµ·å‹•æ™‚æ¤œè¨¼ï¼ˆapp/builder.rsï¼‰

```rust
/// AppBuilder ã« expect_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
impl AppBuilder {
    /// æœŸå¾…ã•ã‚Œã‚‹ task_type ã®ãƒªã‚¹ãƒˆã‚’è¨­å®š
    ///
    /// build() æ™‚ã«ã€æœŸå¾…é›†åˆ âŠ† ç™»éŒ²æ¸ˆã¿é›†åˆ ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€
    /// ä¸è¶³ãŒã‚ã‚Œã° panic ã¾ãŸã¯ Error ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn expect_tasks(mut self, expected: &[&str]) -> Self {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // self ã« expected_tasks ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã—ã¦ä¿å­˜
        todo!()
    }

    pub fn build(self) -> Result<App, BuildError> {
        // TODO(human): å®Ÿè£…ã™ã‚‹
        // 1. expected_tasks ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°æ¤œè¨¼
        // 2. expected âŠ† registered ã‚’ãƒã‚§ãƒƒã‚¯
        // 3. ä¸è¶³ãŒã‚ã‚Œã° BuildError::MissingTasks(Vec<String>) ã‚’è¿”ã™
        todo!()
    }
}
```

**å®Ÿè£…ã™ã¹ãå†…å®¹:**
- [ ] AppBuilder ã« expected_tasks ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
- [ ] expect_tasks() ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…
- [ ] build() ã§ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
- [ ] BuildError::MissingTasks variant ã®è¿½åŠ 
- [ ] ãƒ†ã‚¹ãƒˆä½œæˆï¼ˆæ¤œè¨¼æˆåŠŸãƒ»å¤±æ•—ï¼‰

### ğŸš¨ æŠ€è¡“çš„åˆ¶ç´„ï¼ˆéå¸¸ã«é‡è¦ï¼‰

#### 1. Object Safetyï¼ˆé‡è¦ï¼‰

DynHandler ã¯ `dyn DynHandler` ã¨ã—ã¦ä½¿ãˆãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã€ä»¥ä¸‹ã®åˆ¶ç´„ãŒã‚ã‚Šã¾ã™ï¼š

```rust
// âŒ ã“ã‚Œã¯ object-safe ã§ã¯ãªã„ï¼ˆã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
trait NotObjectSafe {
    fn handle<T: Task>(&self, task: T) -> Outcome;  // NG: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯
}

// âœ… ã“ã‚Œã¯ object-safeï¼ˆå…·ä½“çš„ãªå‹ã®ã¿ï¼‰
trait ObjectSafe {
    fn handle_dyn(&self, payload: serde_json::Value) -> Outcome;  // OK
}
```

**å¯¾ç­–:**
- DynHandler ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’ä½¿ã‚ãªã„
- ä»£ã‚ã‚Šã« `serde_json::Value` ã‚„ `&str` ãªã©å…·ä½“çš„ãªå‹ã‚’ä½¿ã†

#### 2. Type Erasure ãƒ‘ã‚¿ãƒ¼ãƒ³

```rust
// å‹ä»˜ãå´ï¼ˆåˆ©ç”¨è€…ãŒä½¿ã†ï¼‰
let handler: MyHandler = ...;
registry.register::<MyTask, _>(handler);

// å†…éƒ¨ã§ã¯å‹æ¶ˆå»ï¼ˆHashMap ã«æ ¼ç´ï¼‰
HashMap<String, Arc<dyn DynHandler>>
```

ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å‹å®‰å…¨æ€§ã¨ã€å®Ÿè¡Œæ™‚ã®å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã‚’ä¸¡ç«‹ã§ãã¾ã™ã€‚

#### 3. Lifetime ã¨ 'static

```rust
pub trait Task: Serialize + DeserializeOwned + Send + Sync + 'static {
    // 'static ã¯å¿…é ˆï¼ˆHashMap ã« Arc ã§æ ¼ç´ã™ã‚‹ãŸã‚ï¼‰
}
```

**ãªãœ 'static ãŒå¿…è¦ã‹ï¼Ÿ**
- Arc<dyn DynHandler> ã‚’ HashMap ã«æ ¼ç´ã™ã‚‹ãŸã‚
- 'static ã¯ã€Œå‚ç…§ã‚’æŒãŸãªã„ã€ã¨ã„ã†æ„å‘³ï¼ˆæ‰€æœ‰å‹ãªã‚‰è‡ªå‹•çš„ã«æº€ãŸã™ï¼‰

#### 4. serde_json::Value ã®æ‰±ã„

```rust
// Task â†’ Value
let value = serde_json::to_value(&task)?;

// Value â†’ Task
let task: MyTask = serde_json::from_value(value)?;
```

**æ³¨æ„ç‚¹:**
- `DeserializeOwned` trait ãŒå¿…è¦ï¼ˆ`Deserialize<'de>` ã§ã¯ãªãï¼‰
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯ `CodecError` ã«ãƒ©ãƒƒãƒ—ã™ã‚‹

### ğŸ’¡ å®Ÿè£…ã®ãƒ’ãƒ³ãƒˆï¼ˆè³ªå•ãŒã‚ã‚Œã°èã„ã¦ãã ã•ã„ï¼‰

<details>
<summary>ãƒ’ãƒ³ãƒˆ1: DynHandler ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³</summary>

```rust
#[async_trait]
impl<T: Task, H: Handler<T>> DynHandler for TypedHandler<T, H> {
    async fn handle_dyn(&self, payload: serde_json::Value) -> Result<Outcome, WeaverError> {
        // 1. deserialize
        let task: T = serde_json::from_value(payload)
            .map_err(|e| WeaverError::DecodeFailed(e.to_string()))?;

        // 2. handle
        self.handler.handle(task).await
    }

    fn task_type(&self) -> &str {
        T::TYPE
    }
}
```

</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ2: TypedRegistry::register ã®å®Ÿè£…</summary>

```rust
pub fn register<T: Task, H: Handler<T> + 'static>(
    &mut self,
    handler: H,
) -> Result<(), RegistryError> {
    let task_type = T::TYPE;

    // äºŒé‡ç™»éŒ²ãƒã‚§ãƒƒã‚¯
    if self.handlers.contains_key(task_type) {
        return Err(RegistryError::AlreadyRegistered(task_type.to_string()));
    }

    // TypedHandler ã§ãƒ©ãƒƒãƒ—ã—ã¦ DynHandler ã«å¤‰æ›
    let typed_handler = TypedHandler {
        handler,
        _marker: PhantomData::<T>,
    };

    // Arc ã§ãƒ©ãƒƒãƒ—ã—ã¦ HashMap ã«æŒ¿å…¥
    self.handlers.insert(task_type.to_string(), Arc::new(typed_handler));

    Ok(())
}
```

</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ3: èµ·å‹•æ™‚æ¤œè¨¼ã®ãƒ­ã‚¸ãƒƒã‚¯</summary>

```rust
pub fn build(self) -> Result<App, BuildError> {
    // expected_tasks ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°æ¤œè¨¼
    if let Some(expected) = &self.expected_tasks {
        let registered = self.registry.registered_types();
        let registered_set: HashSet<_> = registered.iter().collect();

        let mut missing = Vec::new();
        for task_type in expected {
            if !registered_set.contains(task_type) {
                missing.push(task_type.to_string());
            }
        }

        if !missing.is_empty() {
            return Err(BuildError::MissingTasks(missing));
        }
    }

    // App ã‚’æ§‹ç¯‰
    Ok(App { ... })
}
```

</details>

<details>
<summary>ãƒ’ãƒ³ãƒˆ4: ãƒ†ã‚¹ãƒˆç”¨ã® Task / Handler ã®å®šç¾©</summary>

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TestTask {
    value: i32,
}

impl Task for TestTask {
    const TYPE: &'static str = "test.task.v1";
}

struct TestHandler;

#[async_trait]
impl Handler<TestTask> for TestHandler {
    async fn handle(&self, task: TestTask) -> Result<Outcome, WeaverError> {
        // ãƒ†ã‚¹ãƒˆç”¨ã®ç°¡å˜ãªå®Ÿè£…
        Ok(Outcome::success(format!("Processed: {}", task.value)))
    }
}
```

</details>

### ğŸ” å®Ÿè£…å¾Œã®ç¢ºèªäº‹é …

- [ ] `cargo check` ãŒæˆåŠŸã™ã‚‹
- [ ] `cargo test -p weaver-core` ãŒæˆåŠŸã™ã‚‹
- [ ] `cargo clippy` ã§é‡å¤§ãªè­¦å‘ŠãŒãªã„
- [ ] å‹å®‰å…¨æ€§ã®ãƒ†ã‚¹ãƒˆï¼ˆç•°ãªã‚‹ Task å‹ã¯æ··åŒã§ããªã„ã“ã¨ã‚’ç¢ºèªï¼‰
- [ ] èµ·å‹•æ™‚æ¤œè¨¼ã®ãƒ†ã‚¹ãƒˆï¼ˆç™»éŒ²æ¼ã‚Œã‚’æ¤œå‡ºã§ãã‚‹ã“ã¨ã‚’ç¢ºèªï¼‰
- [ ] TypedRegistry ã®ãƒ†ã‚¹ãƒˆï¼ˆregister/get/äºŒé‡ç™»éŒ²ã‚¨ãƒ©ãƒ¼ï¼‰
- [ ] PayloadCodec ã®ãƒ†ã‚¹ãƒˆï¼ˆencode/decode ãƒ©ã‚¦ãƒ³ãƒ‰ãƒˆãƒªãƒƒãƒ—ï¼‰

---

## ğŸ“ å®Ÿè£…ãƒ¡ãƒ¢

### é–‹å§‹æ™‚åˆ»
2026-01-06ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ï¼‰

### å®Ÿè£…ä¸­ã®æ°—ã¥ã

#### CLAUDE.md ã®æ”¹å–„ï¼ˆé‡è¦ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®æŒ‡æ‘˜ï¼šã€Œã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ä¸­ã«ç­”ãˆã‚’æ›¸ã‹ãªã„ã§ã»ã—ã„ã€
- TODO ã‚³ãƒ¡ãƒ³ãƒˆã«ã¯**ãƒ’ãƒ³ãƒˆã®ã¿**ã‚’æ›¸ãã€å®Œå…¨ãªå®Ÿè£…ä¾‹ã¯ learning/ ã«è¨˜è¼‰ã™ã‚‹æ–¹é‡ã«å¤‰æ›´
- Learning Mode ã®æ”¹å–„ã¨ã—ã¦ CLAUDE.md ã«æ˜è¨˜

#### task.rs ã®å®Ÿè£…
- TestTask ã¨ AnotherTestTask ã‚’å®šç¾©
- HashMap ã‚’å«ã‚€ Task å‹ã§ã‚‚å•é¡Œãªãå‹•ä½œ
- ãƒ†ã‚¹ãƒˆç”¨ã®å‹ãªã®ã§ã€å°†æ¥çš„ã« #[cfg(test)] ã§æ•´ç†ã™ã‚‹äºˆå®š

#### handler.rs ã®å®Ÿè£…
- Handler<T> trait ã¨ DynHandler trait ã®å®šç¾©
- TypedHandler<T, H> adapter ã®å®Ÿè£…ï¼ˆType Erasure ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- `#[async_trait]` ã®è¿½åŠ å¿˜ã‚Œã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ â†’ ä¿®æ­£
- TestTaskHandler ã®å®Ÿè£…

#### errors.rs ã®ç°¡æ˜“å®Ÿè£…
- å½“åˆ `unwrap()` ã‚’ä½¿ãŠã†ã¨ã—ãŸãŒã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œã‚¨ãƒ©ãƒ¼ã‚’è¿”ã•ãªãã¦ã„ã„ã®ï¼Ÿã€ã¨ç–‘å•ã‚’æŒã¤
- **ç´ æ™´ã‚‰ã—ã„åˆ¤æ–­**ï¼šæœ¬ç•ªã‚³ãƒ¼ãƒ‰ã§ã¯ panic ã§ã¯ãªã Result ã§ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã¹ã
- WeaverError ã«ç°¡æ˜“çš„ãª `new(message: String)` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ 
- kind, message, source ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ï¼ˆv2æœ€å°å®Ÿè£…ï¼‰

#### ã¾ã å®Ÿè£…ãŒå¿…è¦ãªã‚‚ã®
- [ ] registry.rs - TypedRegistry ã®å®Ÿè£…
- [ ] codec.rs - PayloadCodec ã®å®Ÿè£…
- [ ] ãƒ†ã‚¹ãƒˆã®è¿½åŠ ï¼ˆå„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
- [ ] app/builder.rs - expect_tasks() ã®å®Ÿè£…

### çµ‚äº†æ™‚åˆ»
2026-01-06ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†ï¼‰

### å­¦ã‚“ã ã“ã¨

#### Type Erasure ãƒ‘ã‚¿ãƒ¼ãƒ³
- Generic å‹ï¼ˆHandler<T>ï¼‰â†’ Trait Objectï¼ˆdyn DynHandlerï¼‰ã¸ã®å¤‰æ›
- PhantomData<T> ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å‹æƒ…å ±ã‚’ä¿æŒã—ã¤ã¤ã€å®Ÿè¡Œæ™‚ã¯ã‚¼ãƒ­ã‚³ã‚¹ãƒˆ
- `#[async_trait]` ã¯ trait å®šç¾©ã¨ impl ä¸¡æ–¹ã«å¿…è¦

#### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®åˆ¤æ–­
- `unwrap()` ã¯ panic ã™ã‚‹ãŸã‚ã€æœ¬ç•ªã‚³ãƒ¼ãƒ‰ã§ã¯é¿ã‘ã‚‹ã¹ã
- ã‚¨ãƒ©ãƒ¼ã¯ Result ã§è¿”ã—ã¦ã€å‘¼ã³å‡ºã—å´ã§é©åˆ‡ã«å‡¦ç†ã™ã‚‹
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å…·ä½“çš„ã«ï¼ˆä½•ãŒå¤±æ•—ã—ãŸã‹ã‚’æ˜è¨˜ï¼‰

#### Learning Mode ã®å®Ÿè·µ
- TODO ã‚³ãƒ¡ãƒ³ãƒˆã«å®Œå…¨ãªå®Ÿè£…ã‚’æ›¸ãã¨ã€å­¦ç¿’ã®æ©Ÿä¼šã‚’å¥ªã£ã¦ã—ã¾ã†
- ãƒ’ãƒ³ãƒˆï¼ˆç›®çš„ãƒ»åˆ¶ç´„ãƒ»ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰ã®ã¿ã‚’æ›¸ãã€è©³ç´°ã¯ learning/ ã«è¨˜è¼‰
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªåˆ†ã§è€ƒãˆã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ç†è§£ãŒæ·±ã¾ã‚‹

---

## ğŸ”— å‚è€ƒè³‡æ–™

- **v2 è¦ä»¶ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: `dev/docs/requirements/2026_01_03_weaver_requirements.md` 5ç« 
- **ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ**: `dev/learning/tasks.md` PR-3
- **CLAUDE.md**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦ã¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

---

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

PR-3 å®Œäº†å¾Œ:
- PR-4: DispatchStrategyï¼ˆtraitï¼‰+ DirectDispatch â³ é–‹å§‹
- PR-5: èµ·å‹•æ™‚æ¤œè¨¼ï¼ˆexpect_tasksï¼‰â€» PR-3 ã§å®Ÿè£…æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
- PR-6: InMemoryDeliveryQueueï¼ˆé–‹ç™ºç”¨ï¼‰
