# Learning Tasks - 2025/12/28

## 📋 タスクリスト

### Phase 1: 基礎実装（既に完了しているもの）

- [x] Domain model (IDs, Specs, Outcomes) の実装
- [x] Error types の定義
- [x] Queue trait + InMemoryQueue の実装
- [x] TaskLease, TaskRecord, TaskState の実装
- [x] RetryPolicy の実装
- [x] HandlerRegistry + Runtime の実装
- [x] Worker/WorkerGroup の実装
- [x] 基本的なタスク実行とリトライ機能

### Phase 2: Job-level Abstraction（学習タスク）

現在は Task 単位での実行のみ。Job（複数タスクの集合）を扱えるようにする。

- [ ] JobRecord の実装（複数 Task を含む）
- [ ] JobId による管理機能
- [ ] Job → Task の関連付け
- [ ] Job 全体のステータス集約

**ゴール**: `submit_job(JobSpec) -> JobId` のような API を実装

### Phase 3: Attempt/Decision の記録（学習タスク）

実行履歴と判断の記録を残す仕組み。

- [ ] Attempt モデルの実装
  - 何をやったか（Action）
  - 何が起きたか（Observation）
  - 結果（Outcome）
- [ ] Decision モデルの実装
  - どの観測を根拠に
  - どの方針（policy）で
  - 何を変更したか
- [ ] 履歴の保存と取得

**ゴール**: 「なぜこの結果になったか」を説明可能にする

### Phase 4: Task 分解（Decomposition）（学習タスク）

抽象的/大きすぎるタスクを実行可能単位に分解する。

- [ ] Decider trait の設計
  - 純粋関数として実装（副作用の分離）
- [ ] 分解ロジックの実装
  - TaskSpec → 複数の TaskSpec への分解
- [ ] 親子関係の管理
- [ ] 子タスク完了時の親タスク処理

**ゴール**: 大きなタスクを自動的に小さな実行単位に分解

### Phase 5: 依存関係管理（学習タスク）

タスク間の「これが終わらないと進めない」関係を表現する。

- [ ] Dependency モデルの実装
- [ ] 依存グラフの管理
- [ ] 依存解決のスケジューリング
- [ ] 循環依存の検出

**ゴール**: タスクが依存関係を持てるようにし、自動的に順序制御

### Phase 6: Budget と Stuck 検知（学習タスク）

実行制約と「進めない状態」の検知。

- [ ] Budget の実装
  - max_attempts（既に RetryPolicy で部分的に実装済み）
  - deadline（期限）
  - max_total_cost（コスト上限）
- [ ] Stuck 検知ロジック
  - RUNNABLE が存在しない状態の検出
  - 依存サイクルの検出
  - Budget 到達の検出
- [ ] 適切な終了処理

**ゴール**: 無限ループを防ぎ、適切なタイミングで終了

### Phase 7: API の実装（学習タスク）

外部から利用可能な API を整備する。

- [ ] `submit_job(JobSpec) -> JobId`
- [ ] `get_status(JobId) -> JobStatus`
- [ ] `cancel_job(JobId) -> CancelAck`
- [ ] `get_result(JobId) -> JobResult`

**ゴール**: ライブラリとして使いやすい API を提供

### Phase 8: Artifact の実装（学習タスク）

実行結果の成果物を記録・参照する。

- [ ] Artifact の保存機構
- [ ] ファイル、URL、stdout/stderr の記録
- [ ] Artifact の取得 API

**ゴール**: 実行結果の成果物を追跡可能に

---

## 📝 学習メモ

### 実装済みの理解

#### Queue と Worker の分離
- Queue: 状態管理（Queued → Running → Succeeded/RetryScheduled/Dead）
- Worker: 副作用の実行（Runtime を通じて Handler を呼び出す）
- TaskLease: Queue と Worker の境界（ack/fail で結果を報告）

#### 非同期の注意点
- ロック保持中に `.await` しない設計
- TaskEnvelope を clone/Arc 化してロック外で実行
- キャンセル安全性を考慮した状態遷移

#### 関数型アプローチ
- Handler は trait として抽象化
- 将来的に Decider も純粋関数として分離予定

---

## 📅 本日の実装記録

### 1. TaskState の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/state.rs`)

タスク状態マシンを enum で定義：

```rust
pub enum TaskState {
    Queued,          // 実行可能
    Running,         // 実行中
    Succeeded,       // 成功
    RetryScheduled,  // リトライ待機
    Dead,            // 永久失敗
}
```

**学んだポイント**
- **代数的データ型**: enum で状態を表現し、`match` で網羅性チェック
- **ヘルパーメソッド**: `is_terminal()`, `is_runnable()` で状態判定を抽象化

---

### 2. TaskRecord の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/record.rs`)

タスクのメタデータと状態遷移ロジック：

- タスクの「単一の真実の源（Single Source of Truth）」
- キューの構造体（ready/scheduled）は TaskId のみを保持
- すべての状態遷移はこのレコード内で実行

**状態遷移メソッド**
- `start_attempt()`: Queued → Running（attempts をインクリメント）
- `mark_succeeded()`: Running → Succeeded
- `mark_dead()`: Running → Dead
- `schedule_retry()`: Running → RetryScheduled
- `requeue()`: RetryScheduled → Queued

**学んだポイント**
- **データの分離**: 長寿命データ（TaskRecord）とキュー構造の分離
- **タイムスタンプ**: `created_at`, `updated_at` で observability を確保
- **状態遷移の明示化**: 各遷移を専用メソッドに分離

---

### 3. RetryPolicy の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/retry.rs:45-56`)

指数バックオフの実装：

```rust
pub fn next_delay(&self, attempts: u32) -> Duration {
    let base_secs = self.base_delay.as_secs_f64();
    let delay_secs = base_secs * self.multiplier.powi((attempts.saturating_sub(1)) as i32);
    Duration::from_secs_f64(delay_secs)
}
```

**バックオフ計算例** (base=2s, multiplier=2.0)
- attempt 1: 2秒
- attempt 2: 4秒
- attempt 3: 8秒
- attempt 4: 16秒
- attempt 5: 32秒

**学んだポイント**
- **純粋関数**: 副作用なし、同じ入力に対して同じ出力
- **オーバーフロー対策**: `saturating_sub(1)` で安全に計算
- **型変換**: Duration ⇄ f64 の変換パターン

---

### 4. InMemoryQueue の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/memory.rs`)

3つのデータ構造を使ったキュー管理：

1. **records** (`HashMap<TaskId, TaskRecord>`): すべてのタスクレコード
2. **ready** (`VecDeque<TaskId>`): 即座に実行可能なタスクID
3. **scheduled** (`BinaryHeap<ScheduledTask>`): リトライ待機中のタスク（時刻順）

**重要な実装ポイント**

#### 4.1 scheduled → ready の自動昇格

```rust
fn promote_scheduled_tasks(&mut self) {
    let now = Instant::now();
    while let Some(entry) = self.scheduled.peek() {
        if entry.next_run_at > now {
            break; // BinaryHeap はソート済み
        }
        // 時刻到達したタスクを ready に移動
    }
}
```

#### 4.2 lease() の待機ロジック

```rust
async fn lease(&self) -> Option<Box<dyn TaskLease>> {
    loop {
        // (1) scheduled タスクを昇格
        // (2) ready から取得できればリース
        // (3) なければ待機（notify または scheduled の次回時刻まで）
        tokio::select! {
            _ = self.notify.notified() => {},
            _ = tokio::time::sleep_until(wake_time.into()) => {},
        }
    }
}
```

**学んだポイント**
- **BinaryHeap の活用**: 最小ヒープで次回実行時刻を効率的に管理
- **tokio::select!**: 複数の非同期イベントを待機
- **ID のみ保持**: キュー構造には ID のみ、実体は HashMap で管理

---

### 5. InMemoryLease::fail の実装（完了）

**実装内容** (`crates/weaver-core/src/queue/memory.rs:208-239`)

タスク失敗時の処理ロジック：

1. **リトライ可否の判定**
   - `record.attempts >= record.max_attempts` でリトライ上限をチェック
   - 上限到達 → `mark_dead()` で Dead 状態に遷移
   - 上限未達 → リトライスケジュール

2. **バックオフ付きリトライ**
   - `retry_policy.next_delay(attempts)` でバックオフ時間を計算
   - `schedule_retry()` で RetryScheduled 状態に遷移
   - `BinaryHeap` (scheduled queue) に次回実行時刻を登録

3. **非同期安全性の実践**
   ```rust
   let should_notify = {
       let mut state = self.queue.lock().await;
       // ... 状態更新 ...
   }; // ← ロックをここで解放

   // ロック外で notify（デッドロック回避）
   if should_notify {
       self.notify.notify_one();
   }
   ```

**学んだポイント**
- **所有権の活用**: `should_notify` をスコープ外に持ち出してロック解放後に使用
- **状態遷移の明確化**: Dead と RetryScheduled を明確に区別
- **非同期のベストプラクティス**: ロック保持時間を最小化し、通知は外で実行

---

### 6. Clippy 警告の修正（完了）

**警告内容** (`clippy::collapsible_if`)

ネストした if 文を1つにまとめられるという指摘。

**修正前** (`memory.rs:83-87`)
```rust
if let Some(record) = self.records.get_mut(&entry.task_id) {
    if record.state == TaskState::RetryScheduled {
        record.requeue();
        self.ready.push_back(entry.task_id);
    }
}
```

**修正後**
```rust
if let Some(record) = self.records.get_mut(&entry.task_id)
    && record.state == TaskState::RetryScheduled
{
    record.requeue();
    self.ready.push_back(entry.task_id);
}
```

**学んだポイント**
- **let-chain**: Rust 2021 edition の機能で、`if let` と条件を `&&` で連結可能
- **可読性の向上**: ネストを減らし、条件の並列性を明確化
- **短絡評価**: 左から順に評価され、false になれば以降は評価されない
- **clippy の活用**: コード品質を保つためのツールとして活用

---

### 7. ADR の作成（完了）

Phase 1 実装の主要な設計判断を ADR として文書化：

**作成した ADR:**

1. **ADR-0001**: TaskId のみを保持する3つのデータ構造分離
   - `dev/docs/adr/0001-task-id-only-queue-design.md`
   - Single Source of Truth パターン
   - 所有権の明確化とパフォーマンスのバランス

2. **ADR-0002**: TaskRecord への状態遷移の集約
   - `dev/docs/adr/0002-state-transitions-in-taskrecord.md`
   - カプセル化と不変条件の保護
   - 状態遷移の明示化

3. **ADR-0003**: ロック外での notify による非同期安全性
   - `dev/docs/adr/0003-notify-outside-lock.md`
   - デッドロック回避とロック最小化
   - スコープによるロック制御パターン

4. **ADR-0004**: tokio::select! による複数イベント待機
   - `dev/docs/adr/0004-tokio-select-for-multiple-events.md`
   - 効率的なイベント待機
   - レイテンシ最小化と CPU 効率化

**学んだポイント**
- **設計判断の記録の重要性**: 「なぜこうしたのか」を残すことで、将来の変更時に判断材料になる
- **代替案の検討**: 採用した案だけでなく、検討した他の案も記録することで思考プロセスが可視化される
- **トレードオフの明示**: すべての設計には長所と短所があり、それを明確にすることが重要

---

## 🎓 全体として学んだこと

### Rust の所有権・ライフタイム
- TaskId のみを保持し、TaskRecord への参照を避ける設計
- Arc/Mutex による共有可変状態の管理
- スコープを活用したロック解放の制御

### 非同期プログラミング（Tokio）
- ロック保持中に `.await` しない原則の実践
- `tokio::select!` による複数イベント待機
- `Notify` を使った効率的なワーカー通知

### 関数型プログラミング
- enum による代数的データ型と網羅性チェック
- RetryPolicy の純粋関数としての実装
- 副作用（状態遷移）と判断ロジック（バックオフ計算）の分離

### データ構造の選択
- VecDeque: FIFO キュー（ready queue）
- BinaryHeap: 優先度付きキュー（scheduled queue）
- HashMap: 効率的な ID → レコード検索

---

## 🎯 次回の実装予定

Phase 2（Job-level Abstraction）から開始予定。

### 推奨実装順序

1. **JobRecord + Job管理**: Job 単位での追跡を可能に
2. **Attempt/Decision**: 履歴記録の基盤を整備
3. **依存関係**: タスクの順序制御を実装
4. **分解**: 複雑なタスクの自動分割
5. **Budget/Stuck**: 終了条件の実装
6. **API**: 外部インターフェースの整備
7. **Artifact**: 成果物の記録

---

## 📚 参考資料

- 要件: `dev/docs/requirements/2025_12_27_weaver_requirements.md`
- 成功条件: 要件ドキュメントの「12. v1 の成功条件」セクション
- アーキテクチャ: `CLAUDE.md`
