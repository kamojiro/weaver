# å®Ÿè£…è¨˜éŒ² - 2026/01/01

Phase 4-1 (Handler â†’ Outcome â†’ Decider ãƒ•ãƒ­ãƒ¼çµ±åˆ) ã®å®Ÿè£…ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚

**ã‚¿ã‚¹ã‚¯ä¸€è¦§**: å…¨ä½“ã®ã‚¿ã‚¹ã‚¯ã¨é€²æ—ã¯ `tasks.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ“ Phase 4-1 ã®ç›®æ¨™

Handler â†’ Outcome â†’ Decider â†’ Decision ãƒ•ãƒ­ãƒ¼ã‚’ weaver å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³ã«çµ±åˆã™ã‚‹ã€‚

**ç¾åœ¨ã®ãƒ•ãƒ­ãƒ¼ï¼ˆPhase 3ã¾ã§ï¼‰:**
```
Handler â†’ Result<(), WeaverError> â†’ ack()/fail()
```

**ç›®æ¨™ã®ãƒ•ãƒ­ãƒ¼ï¼ˆPhase 4-1ï¼‰:**
```
Handler â†’ Outcome â†’ Decider â†’ Decision â†’ TaskRecordæ›´æ–°
```

### ãªãœã“ã®å¤‰æ›´ãŒå¿…è¦ã‹ï¼Ÿ

1. **ç´”ç²‹é–¢æ•°ã¨å‰¯ä½œç”¨ã®åˆ†é›¢**: åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆDeciderï¼‰ã¨å®Ÿè¡Œï¼ˆWorker/TaskLeaseï¼‰ã‚’åˆ†é›¢
2. **æ‹¡å¼µæ€§**: æ–°ã—ã„Decisionï¼ˆDecompose, AddDependencyç­‰ï¼‰ã‚’è¿½åŠ ã—ã‚„ã™ã„
3. **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ€§**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç‹¬è‡ªã®Deciderï¼ˆAI Agentç­‰ï¼‰ã‚’å®Ÿè£…å¯èƒ½
4. **è¦ä»¶ã¨ã®æ•´åˆæ€§**: ADR-0005ã§å®šç¾©ã•ã‚ŒãŸã€Œè¦³æ¸¬/çµæœ â†’ æ¬¡ã®æ“ä½œã€ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè£…

---

## ğŸ“… æœ¬æ—¥ã®å®Ÿè£…è¨˜éŒ²

### å®Œäº†ã—ãŸã‚¹ãƒ†ãƒƒãƒ—ï¼ˆSteps 1-3, 5ï¼‰

#### Step 1: TaskLease Interface ã®æ‹¡å¼µ âœ…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/queue/mod.rs`

æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ TaskLease trait ã«è¿½åŠ ï¼š

```rust
#[async_trait]
pub trait TaskLease: Send {
    fn envelope(&self) -> &TaskEnvelope;

    // æ–°è¦è¿½åŠ ï¼ˆPhase 4-1ï¼‰
    async fn get_task_record(&self) -> Result<TaskRecord, WeaverError>;
    async fn complete(
        self: Box<Self>,
        outcome: Outcome,
        decision: Decision
    ) -> Result<(), WeaverError>;

    // æ—¢å­˜ï¼ˆå¼•ãç¶šãä½¿ç”¨ï¼‰
    async fn ack(self: Box<Self>) -> Result<(), WeaverError>;

    // æ—¢å­˜ï¼ˆdeprecatedï¼‰
    #[deprecated(note = "Use complete() with Decider instead")]
    async fn fail(self: Box<Self>, error: String) -> Result<(), WeaverError>;
}
```

**å¤‰æ›´ã®ãƒã‚¤ãƒ³ãƒˆ:**
- `get_task_record()`: Worker ãŒ Decider ã‚’å‘¼ã¶ãŸã‚ã« TaskRecord ã‚’å–å¾—
- `complete(outcome, decision)`: Outcome ã¨ Decision ã‚’å—ã‘å–ã‚Šã€çŠ¶æ…‹é·ç§»ã‚’å®Ÿè¡Œ
- `fail()` ã¯ deprecated ã ãŒã€ç§»è¡ŒæœŸé–“ä¸­ã¯æ®‹ã™

**å®Ÿè£…æ¸ˆã¿ï¼ˆInMemoryLeaseï¼‰:**
- `get_task_record()` ã¯å®Œå…¨å®Ÿè£…æ¸ˆã¿ï¼ˆmemory.rs:309-316ï¼‰
- `complete()` ã¯ TODO(human) ã§ã‚¹ã‚¿ãƒ–åŒ–ï¼ˆStep 6 ã§å®Ÿè£…ï¼‰

---

#### Step 2: Handler Trait ã®å¤‰æ›´ âœ…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/runtime.rs`

TaskHandler trait ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å¤‰æ›´ï¼š

```rust
// å¤‰æ›´å‰
#[async_trait]
pub trait TaskHandler: Send + Sync {
    async fn handle(&self, envelope: &TaskEnvelope) -> Result<(), WeaverError>;
}

// å¤‰æ›´å¾Œ
#[async_trait]
pub trait TaskHandler: Send + Sync {
    async fn handle(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError>;
}
```

**å¤‰æ›´ã®ãƒã‚¤ãƒ³ãƒˆ:**
- **`Ok(Outcome)`**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®çµæœï¼ˆSUCCESS/FAILURE/BLOCKEDï¼‰
- **`Err(WeaverError)`**: ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ï¼ˆJSON decodeå¤±æ•—ã€handler panicç­‰ï¼‰

**é‡è¦ãªåŒºåˆ¥:**
- `Err(WeaverError)`: å®Ÿè¡Œã§ããªã‹ã£ãŸï¼ˆã‚¤ãƒ³ãƒ•ãƒ©å•é¡Œï¼‰
- `Ok(Outcome::Failure)`: å®Ÿè¡Œã—ãŸãŒå¤±æ•—ã—ãŸï¼ˆãƒ“ã‚¸ãƒã‚¹å•é¡Œï¼‰

**Runtime::execute() ã‚‚å¤‰æ›´:**
```rust
pub async fn execute(&self, envelope: &TaskEnvelope) -> Result<Outcome, WeaverError>
```

**ãƒ†ã‚¹ãƒˆã®æ›´æ–°:**
- OkHandler ã‚’æ›´æ–°ã—ã¦ `Outcome::success()` ã‚’è¿”ã™ã‚ˆã†ã«å¤‰æ›´
- ãƒ†ã‚¹ãƒˆã‚‚ Outcome ã‚’ã‚¢ã‚µãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«æ›´æ–°

---

#### Step 3: Decider ã‚’ Worker ã«çµ±åˆ âœ…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/worker.rs`

WorkerGroup ã¨ worker_loop ã« Decider ã‚’æ¸¡ã™ï¼š

```rust
// WorkerGroup::spawn() ã®ã‚·ã‚°ãƒãƒãƒ£å¤‰æ›´
pub fn spawn(
    n: usize,
    queue: Arc<dyn Queue>,
    runtime: Arc<Runtime>,
    decider: Arc<dyn Decider>,  // æ–°è¦è¿½åŠ 
) -> Self

// worker_loop() ã®ã‚·ã‚°ãƒãƒãƒ£å¤‰æ›´
async fn worker_loop(
    worker_id: usize,
    queue: Arc<dyn Queue>,
    runtime: Arc<Runtime>,
    decider: Arc<dyn Decider>,  // æ–°è¦è¿½åŠ 
    shutdown_rx: &mut watch::Receiver<bool>,
)
```

**Decider trait ã« Send + Sync ã‚’è¿½åŠ :**
- `pub trait Decider: Send + Sync { ... }`
- tokio::spawn ã§ Arc<dyn Decider> ã‚’æ¸¡ã™ãŸã‚ã«å¿…è¦

**å¤‰æ›´ã®ãƒã‚¤ãƒ³ãƒˆ:**
- Decider ã¯ WorkerGroup ã§å—ã‘å–ã‚Šã€å„ worker ã« Arc::clone ã§æ¸¡ã™
- Decider ã¯ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ï¼ˆã¾ãŸã¯å†…éƒ¨å¯å¤‰æ€§ã‚’ä½¿ç”¨ï¼‰ãªã®ã§ Arc å…±æœ‰ãŒå®‰å…¨
- WorkerGroup ãŒå®Ÿè¡Œæˆ¦ç•¥ï¼ˆã©ã®Deciderã‚’ä½¿ã†ã‹ï¼‰ã‚’è¨­å®šã™ã‚‹è¨­è¨ˆ

---

#### Step 5: get_task_record() ã®å®Ÿè£… âœ…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/queue/memory.rs`

InMemoryLease ã« get_task_record() ã‚’å®Ÿè£…ï¼š

```rust
async fn get_task_record(&self) -> Result<TaskRecord, WeaverError> {
    let state = self.queue.lock().await;
    state
        .records
        .get(&self.task_id)
        .cloned()
        .ok_or_else(|| WeaverError::Other("task record not found".into()))
}
```

**è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆ:**
- InMemoryLease ã¯ TaskRecord ã‚’ä¿æŒã—ãªã„ï¼ˆstale data ã‚’é˜²ããŸã‚ï¼‰
- å¿…è¦ãªæ™‚ã« queue state ã‹ã‚‰å†å–å¾—ã™ã‚‹
- æ—¢å­˜ã® InMemoryLease ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ä¸€è²«æ€§ãŒã‚ã‚‹

---

### ç¾åœ¨ã®çŠ¶æ³

**ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼ˆäºˆæƒ³é€šã‚Šï¼‰:**

ç¾åœ¨ã€ä»¥ä¸‹ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ã‚‹ãŒã€ã“ã‚Œã¯**äºˆæƒ³é€šã‚Š**ã§ã€Step 4 ã¨ 6 ã§è§£æ±ºã•ã‚Œã‚‹ï¼š

1. **worker.rs:149** - å‹ã®ä¸ä¸€è‡´
   - `Result<(), WeaverError>` vs `Result<Outcome, WeaverError>`
   - â†’ Step 4 ã§æ–°ã—ã„ãƒ•ãƒ­ãƒ¼ã«æ›¸ãæ›ãˆã¦è§£æ±º

2. **worker.rs:159** - å‹æ³¨é‡ˆãŒå¿…è¦
   - `fail()` ã®ä½¿ç”¨ï¼ˆdeprecatedï¼‰
   - â†’ Step 4 ã§æ–°ã—ã„ãƒ•ãƒ­ãƒ¼ã«æ›¸ãæ›ãˆã¦è§£æ±º

3. **worker.rs:6** - æœªä½¿ç”¨ã® imports
   - `Outcome`, `OutcomeKind` ãŒã¾ã ä½¿ã‚ã‚Œã¦ã„ãªã„
   - â†’ Step 4 ã§ä½¿ç”¨ã•ã‚Œã‚‹

4. **memory.rs:320-321** - æœªä½¿ç”¨ã®å¤‰æ•°
   - `complete()` ã®å¼•æ•° `outcome`, `decision`
   - â†’ Step 6 ã§å®Ÿè£…ã•ã‚Œã‚‹

**ã“ã‚Œã‚‰ã¯å…¨ã¦å­¦ç¿’ã‚¿ã‚¹ã‚¯ã®ä¸€éƒ¨ã¨ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚**

---

## ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: Step 4 ã¨ Step 6ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰

### Step 4: Worker Loop Flowï¼ˆé«˜é›£åº¦ãƒ»é‡è¦ï¼‰

**é›£æ˜“åº¦**: â˜…â˜…â˜…â˜…â˜†
**å­¦ç¿’ä¾¡å€¤**: â˜…â˜…â˜…â˜…â˜…
**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/worker.rs`

**ã‚¿ã‚¹ã‚¯å†…å®¹**: worker_loop() ã®ä¸­æ ¸ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹

**ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ï¼ˆå‰Šé™¤ãŒå¿…è¦ï¼‰:**
```rust
#[allow(deprecated)]
let result: Result<(), WeaverError> = runtime.execute(&envelope).await;

#[allow(deprecated)]
match result {
    Ok(_) => lease.ack().await,
    Err(err) => lease.fail(err.to_string()).await,
}
```

**å®Ÿè£…ã™ã¹ãæ–°ã—ã„ãƒ•ãƒ­ãƒ¼:**
```rust
// 1. Handler ã‚’å®Ÿè¡Œ â†’ Outcome ã‚’å–å¾—
let outcome_result = runtime.execute(&envelope).await;

match outcome_result {
    // Case A: ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼
    Err(handler_error) => {
        eprintln!("[worker-{worker_id}] handler error: {handler_error}");
        // Outcome::failure ã«å¤‰æ›ã—ã¦ Decider ã¸
        let outcome = Outcome::failure(handler_error.to_string());
        // TaskRecord ã‚’å–å¾—
        let task = match lease.get_task_record().await {
            Ok(t) => t,
            Err(e) => {
                eprintln!("[worker-{worker_id}] failed to get task: {e}");
                continue;
            }
        };
        // Decider ã‚’å‘¼ã¶
        let decision = decider.decide(&task, &outcome);
        // Decision ã‚’å®Ÿè¡Œ
        if let Err(e) = lease.complete(outcome, decision).await {
            eprintln!("[worker-{worker_id}] complete failed: {e}");
        }
    }

    // Case B: Handler ãŒæ­£å¸¸å®Ÿè¡Œ
    Ok(outcome) => {
        match outcome.kind {
            OutcomeKind::Success => {
                // SUCCESS: Decider ä¸è¦ã€ç›´æ¥ ack
                if let Err(e) = lease.ack().await {
                    eprintln!("[worker-{worker_id}] ack failed: {e}");
                }
            }

            OutcomeKind::Failure | OutcomeKind::Blocked => {
                // FAILURE/BLOCKED: Decider ã‚’å‘¼ã¶
                let task = match lease.get_task_record().await {
                    Ok(t) => t,
                    Err(e) => {
                        eprintln!("[worker-{worker_id}] failed to get task: {e}");
                        continue;
                    }
                };
                let decision = decider.decide(&task, &outcome);
                if let Err(e) = lease.complete(outcome, decision).await {
                    eprintln!("[worker-{worker_id}] complete failed: {e}");
                }
            }
        }
    }
}
```

**å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ:**

1. **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: Worker ãŒ Handler â†’ Outcome â†’ Decider â†’ Decision ã®æµã‚Œã‚’åˆ¶å¾¡
2. **éåŒæœŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: å„ `.await` ã®çµæœã‚’é©åˆ‡ã«ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
3. **è²¬å‹™ã®åˆ†é›¢**:
   - Handler: å®Ÿè¡Œ + è¦³æ¸¬ï¼ˆOutcome ã‚’è¿”ã™ï¼‰
   - Decider: åˆ¤æ–­ï¼ˆç´”ç²‹é–¢æ•°ï¼‰
   - Worker: ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
   - TaskLease: å®Ÿè¡Œï¼ˆå‰¯ä½œç”¨ï¼‰

4. **æœ€é©åŒ–**: SUCCESS ã¯ Decider ã‚’ãƒã‚¤ãƒ‘ã‚¹ï¼ˆä¸è¦ãªå‘¼ã³å‡ºã—ã‚’é¿ã‘ã‚‹ï¼‰

5. **å›å¾©åŠ›**: å€‹åˆ¥ã®ã‚¿ã‚¹ã‚¯ã‚¨ãƒ©ãƒ¼ã§ãƒ¯ãƒ¼ã‚«ãƒ¼å…¨ä½“ã‚’æ­¢ã‚ãªã„

**TODO(human) ã®å ´æ‰€**: `worker.rs` ã® 96-165 è¡Œç›®

---

### Step 6: complete() ã®å®Ÿè£…ï¼ˆé«˜é›£åº¦ãƒ»é‡è¦ï¼‰

**é›£æ˜“åº¦**: â˜…â˜…â˜…â˜…â˜†
**å­¦ç¿’ä¾¡å€¤**: â˜…â˜…â˜…â˜…â˜…
**ãƒ•ã‚¡ã‚¤ãƒ«**: `crates/weaver-core/src/queue/memory.rs`

**ã‚¿ã‚¹ã‚¯å†…å®¹**: TaskLease::complete() ã‚’å®Ÿè£…ã™ã‚‹

**å®Ÿè£…ã™ã¹ãå†…å®¹:**

```rust
async fn complete(
    self: Box<Self>,
    outcome: Outcome,
    decision: Decision,
) -> Result<(), WeaverError> {
    // Step 1: AttemptRecord ã‚’ä½œæˆãƒ»æŒ¿å…¥
    // Step 2: Decision ã«åŸºã¥ã„ã¦å‡¦ç†ã‚’åˆ†å²
    //   - Decision::Retry: ãƒªãƒˆãƒ©ã‚¤ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    //   - Decision::MarkDead: ã‚¿ã‚¹ã‚¯ã‚’çµ‚äº†
    // Step 3: lock-outside-notify ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆADR-0003ï¼‰

    let should_notify = {
        let mut state = self.queue.lock().await;

        // AttemptRecord ã‚’ä½œæˆ
        let attempt_id = state.allocate_attempt_id();
        let attempt = AttemptRecord::new(
            attempt_id,
            self.task_id,
            self.envelope.payload().clone(),  // action
            outcome.artifacts.clone(),         // observation
            outcome.clone(),
        );
        state.attempts.insert(attempt_id, attempt);

        // Decision ã«åŸºã¥ã„ã¦åˆ†å²
        match decision {
            Decision::Retry { delay, reason } => {
                let next_run_at = Instant::now() + delay;

                // DecisionRecord ã‚’ä½œæˆ
                let trigger = serde_json::json!({
                    "outcome_kind": outcome.kind,
                    "reason": outcome.reason,
                });
                let context = Some(serde_json::json!({
                    "delay_secs": delay.as_secs(),
                    "next_run_at": format!("{:?}", next_run_at),
                }));
                let decision_record = DecisionRecord::new(
                    self.task_id,
                    trigger,
                    "DefaultDecider",
                    "schedule_retry",
                    context,
                );
                state.decisions.push(decision_record);

                // TaskRecord ã‚’æ›´æ–°
                if let Some(record) = state.records.get_mut(&self.task_id) {
                    record.schedule_retry(next_run_at, reason);
                }

                // ãƒªãƒˆãƒ©ã‚¤ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                state.scheduled.push(ScheduledTask {
                    next_run_at,
                    task_id: self.task_id,
                });

                true  // notify ãŒå¿…è¦
            }

            Decision::MarkDead { reason } => {
                // DecisionRecord ã‚’ä½œæˆ
                let trigger = serde_json::json!({
                    "outcome_kind": outcome.kind,
                    "reason": outcome.reason,
                });
                let decision_record = DecisionRecord::new(
                    self.task_id,
                    trigger,
                    "DefaultDecider",
                    "mark_dead",
                    None,
                );
                state.decisions.push(decision_record);

                // TaskRecord ã‚’æ›´æ–°
                if let Some(record) = state.records.get_mut(&self.task_id) {
                    record.mark_dead(reason);
                }

                false  // çµ‚äº†çŠ¶æ…‹ãªã®ã§ notify ä¸è¦
            }
        }
    };  // ãƒ­ãƒƒã‚¯è§£æ”¾

    // ãƒ­ãƒƒã‚¯å¤–ã§ notifyï¼ˆADR-0003ï¼‰
    if should_notify {
        self.notify.notify_one();
    }

    Ok(())
}
```

**å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ:**

1. **çŠ¶æ…‹ãƒã‚·ãƒ³**: TaskRecord ã®çŠ¶æ…‹é·ç§»ã‚’å®Ÿè£…
2. **ADR-0003 æº–æ‹ **: lock-outside-notify ãƒ‘ã‚¿ãƒ¼ãƒ³
3. **å±¥æ­´è¨˜éŒ²**: AttemptRecord ã¨ DecisionRecord ã®ä¸¡æ–¹ã‚’è¨˜éŒ²
4. **åˆ¤æ–­ã¨å®Ÿè¡Œã®åˆ†é›¢**: Decider ãŒåˆ¤æ–­ã€complete() ãŒå®Ÿè¡Œ

**å‚è€ƒå®Ÿè£…:**
- `ack()`: memory.rs:371-391 (AttemptRecord ãƒ‘ã‚¿ãƒ¼ãƒ³)
- `fail()`: memory.rs:393-457 (Decision ãƒ‘ã‚¿ãƒ¼ãƒ³ã€lock-outside-notify)

**TODO(human) ã®å ´æ‰€**: `memory.rs` ã® 318-369 è¡Œç›®

---

## ğŸ”‘ è¨­è¨ˆã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆ

### 1. Handler ã®æˆ»ã‚Šå€¤: Result<Outcome, WeaverError>

**ãªãœã“ã®è¨­è¨ˆï¼Ÿ**

- `Err(WeaverError)`: ã‚¤ãƒ³ãƒ•ãƒ©å•é¡Œï¼ˆå®Ÿè¡Œã§ããªã‹ã£ãŸï¼‰
  - ä¾‹: JSON decode å¤±æ•—ã€handler ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€panic
  - Worker ã§ `Outcome::failure()` ã«å¤‰æ›ã—ã¦ Decider ã¸

- `Ok(Outcome::Failure)`: ãƒ“ã‚¸ãƒã‚¹å•é¡Œï¼ˆå®Ÿè¡Œã—ãŸãŒå¤±æ•—ï¼‰
  - ä¾‹: API ãŒ 500 ã‚’è¿”ã—ãŸã€validation å¤±æ•—
  - Decider ãŒãƒªãƒˆãƒ©ã‚¤åˆ¤æ–­

ã“ã®åŒºåˆ¥ã«ã‚ˆã‚Šã€ã‚¤ãƒ³ãƒ•ãƒ©å•é¡Œã‚‚ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã«ã§ãã‚‹ï¼ˆresilienceï¼‰ã€‚

---

### 2. SUCCESS æ™‚ã« Decider ã‚’å‘¼ã°ãªã„ç†ç”±

**ADR-0005 ã®è¨­è¨ˆæ±ºå®š:**
- SUCCESS ã¯çµ‚äº†çŠ¶æ…‹ï¼ˆåˆ¤æ–­ä¸è¦ï¼‰
- Decider ã¯ FAILURE/BLOCKED ã®ã¿å‘¼ã¶
- æœ€é©åŒ–ï¼ˆä¸è¦ãªå‘¼ã³å‡ºã—ã‚’é¿ã‘ã‚‹ï¼‰
- ã‚·ãƒ³ãƒ—ãƒ«ã•ï¼ˆåˆ¤æ–­ãŒå¿…è¦ãªæ™‚ã ã‘å‘¼ã¶ï¼‰

**å°†æ¥ã®æ‹¡å¼µ:**
- ã€ŒSUCCESS ã ãŒæœ¬å½“ã«æˆåŠŸã‹ï¼Ÿã€ã®æ¤œè¨¼ã¯ future work
- Phase 4-1 ã§ã¯ Handler ã®åˆ¤æ–­ã‚’ä¿¡ã˜ã‚‹

---

### 3. Decider ã®é…ç½®: Worker ã«é…ç½®

**ãªãœ Workerï¼Ÿ**

- **WorkerGroup** ãŒå®Ÿè¡Œæˆ¦ç•¥ã‚’è¨­å®šï¼ˆã©ã® Decider ã‚’ä½¿ã†ã‹ï¼‰
- **Worker** ãŒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆHandler â†’ Decider â†’ TaskLeaseï¼‰
- **Queue** ã¯çŠ¶æ…‹ç®¡ç†ã«é›†ä¸­ï¼ˆåˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ã‚’æŒãŸãªã„ï¼‰

**ä»£æ›¿æ¡ˆã¨ã®æ¯”è¼ƒ:**
- Queue ã«é…ç½®: Queue ãŒåˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ã‚’æŒã¤ã“ã¨ã«ãªã‚Šã€è²¬å‹™ãŒé‡ããªã‚‹
- Runtime ã«é…ç½®: Runtime ã¯ handler dispatch ã«é›†ä¸­ã™ã¹ã

---

### 4. TaskRecord ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹: lease.get_task_record()

**ãªãœã“ã®è¨­è¨ˆï¼Ÿ**

- InMemoryLease ã¯ TaskRecord ã‚’ä¿æŒã—ãªã„ï¼ˆstale data ã‚’é˜²ãï¼‰
- å¿…è¦ãªæ™‚ã« queue state ã‹ã‚‰å†å–å¾—
- æ—¢å­˜ã® InMemoryLease ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ä¸€è²«æ€§

**ä»£æ›¿æ¡ˆã¨ã®æ¯”è¼ƒ:**
- Queue::get_task_record() ãƒ¡ã‚½ãƒƒãƒ‰: Worker ãŒ Queue å‚ç…§ã‚’æŒã¤å¿…è¦ãŒã‚ã‚‹
- TaskRecord ã‚’ Lease ä½œæˆæ™‚ã«æ¸¡ã™: stale data ã®ãƒªã‚¹ã‚¯

---

## ğŸ“š å‚è€ƒè³‡æ–™

### ADRï¼ˆArchitecture Decision Recordsï¼‰

- **ADR-0005**: Decider ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆä»Šå›ã®è¨­è¨ˆã®æ ¹æ‹ ï¼‰
  - ãƒ•ã‚¡ã‚¤ãƒ«: `dev/docs/adr/0005-decider-architecture.md`
  - å†…å®¹: 2å±¤ã® Decider ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€è²¬å‹™åˆ†æ‹…ã€Handler ã®æˆ»ã‚Šå€¤

- **ADR-0003**: ãƒ­ãƒƒã‚¯å¤–ã§ã® notify ã«ã‚ˆã‚‹éåŒæœŸå®‰å…¨æ€§
  - å†…å®¹: lock â†’ æ›´æ–° â†’ unlock â†’ notify ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
  - é©ç”¨: complete() ã®å®Ÿè£…ã§éµå®ˆå¿…è¦

- **ADR-0002**: TaskRecord ã¸ã®çŠ¶æ…‹é·ç§»ã®é›†ç´„
  - å†…å®¹: mark_succeeded, mark_dead, schedule_retry ãƒ¡ã‚½ãƒƒãƒ‰

- **ADR-0001**: TaskId ã®ã¿ã‚’ä¿æŒã™ã‚‹3ã¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆ†é›¢
  - å†…å®¹: records, ready, scheduled ã®åˆ†é›¢

### å®Ÿè£…æ¸ˆã¿ã‚³ãƒ¼ãƒ‰ï¼ˆå‚è€ƒï¼‰

- **Phase 3 ã® AttemptRecord/DecisionRecord è¨˜éŒ²**:
  - ãƒ•ã‚¡ã‚¤ãƒ«: `queue/memory.rs`
  - ack(): 371-391 è¡Œç›®
  - fail(): 393-457 è¡Œç›®

- **Decider trait ã¨ DefaultDecider**:
  - ãƒ•ã‚¡ã‚¤ãƒ«: `domain/decision.rs`
  - DefaultDecider::decide(): 77-95 è¡Œç›®

- **Outcome ã®å®šç¾©**:
  - ãƒ•ã‚¡ã‚¤ãƒ«: `domain/outcome.rs`
  - OutcomeKind enum, Outcome struct

### è¦ä»¶ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- **æœ€æ–°è¦ä»¶**: `dev/docs/requirements/2025_12_27_weaver_requirements.md`
  - ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 6.2: Decider ã®å®šç¾©
  - ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 11: é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

---

## ğŸ¯ Step 4 å®Ÿè£…ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

å®Ÿè£…æ™‚ã«ç¢ºèªã™ã¹ããƒã‚¤ãƒ³ãƒˆï¼š

### åŸºæœ¬æ©Ÿèƒ½
- [ ] `runtime.execute(&envelope).await` ã®æˆ»ã‚Šå€¤ã‚’ `Result<Outcome, WeaverError>` ã¨ã—ã¦å—ã‘å–ã‚‹
- [ ] `Err(handler_error)` ã‚’ `Outcome::failure()` ã«å¤‰æ›ã—ã¦å‡¦ç†
- [ ] `OutcomeKind::Success` ã®å ´åˆã¯ `lease.ack().await` ã‚’å‘¼ã¶
- [ ] `OutcomeKind::Failure | Blocked` ã®å ´åˆã¯ Decider ã‚’å‘¼ã¶

### Decider ã®å‘¼ã³å‡ºã—
- [ ] `lease.get_task_record().await` ã§ TaskRecord ã‚’å–å¾—
- [ ] `decider.decide(&task, &outcome)` ã§ Decision ã‚’å–å¾—
- [ ] `lease.complete(outcome, decision).await` ã§å®Ÿè¡Œ

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- [ ] å„ `.await` ã®çµæœã‚’ `if let Err(e) = ... { eprintln!(...) }` ã§ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- [ ] ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã›ãšå‡¦ç†ã‚’ç¶™ç¶š
- [ ] get_task_record å¤±æ•—æ™‚ã¯ `continue` ã§ã‚¹ã‚­ãƒƒãƒ—

### ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- [ ] å¤ã„ãƒ•ãƒ­ãƒ¼ï¼ˆ`#[allow(deprecated)]` éƒ¨åˆ†ï¼‰ã‚’å‰Šé™¤
- [ ] TODO(human) ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤

### ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ç¢ºèª
- [ ] `cargo check -p weaver-core` ãŒæˆåŠŸï¼ˆè­¦å‘Šã®ã¿ï¼‰
- [ ] æœªä½¿ç”¨ imports è­¦å‘ŠãŒãªããªã‚‹ï¼ˆOutcome, OutcomeKind ã‚’ä½¿ç”¨ï¼‰

---

## ğŸ¯ Step 6 å®Ÿè£…ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

å®Ÿè£…æ™‚ã«ç¢ºèªã™ã¹ããƒã‚¤ãƒ³ãƒˆï¼š

### AttemptRecord ã®ä½œæˆ
- [ ] `allocate_attempt_id()` ã§ ID ã‚’æ¡ç•ª
- [ ] `AttemptRecord::new()` ã§ä½œæˆï¼ˆaction, observation, outcomeï¼‰
- [ ] `state.attempts.insert()` ã§æŒ¿å…¥

### Decision ã«åŸºã¥ãåˆ†å²
- [ ] `Decision::Retry` ã®å ´åˆ:
  - [ ] `Instant::now() + delay` ã§ next_run_at ã‚’è¨ˆç®—
  - [ ] DecisionRecord ã‚’ä½œæˆï¼ˆpolicy: "DefaultDecider", decision: "schedule_retry"ï¼‰
  - [ ] `record.schedule_retry(next_run_at, reason)` ã‚’å‘¼ã¶
  - [ ] `state.scheduled.push()` ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  - [ ] should_notify = true

- [ ] `Decision::MarkDead` ã®å ´åˆ:
  - [ ] DecisionRecord ã‚’ä½œæˆï¼ˆpolicy: "DefaultDecider", decision: "mark_dead"ï¼‰
  - [ ] `record.mark_dead(reason)` ã‚’å‘¼ã¶
  - [ ] should_notify = false

### ADR-0003 æº–æ‹ 
- [ ] lock-outside-notify ãƒ‘ã‚¿ãƒ¼ãƒ³
- [ ] should_notify ã‚’ `{ ... }` ãƒ–ãƒ­ãƒƒã‚¯ã§è¨ˆç®—
- [ ] ãƒ­ãƒƒã‚¯è§£æ”¾å¾Œã« `notify.notify_one()` ã‚’å‘¼ã¶

### ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ç¢ºèª
- [ ] `cargo check -p weaver-core` ãŒæˆåŠŸ
- [ ] æœªä½¿ç”¨å¤‰æ•°è­¦å‘ŠãŒãªããªã‚‹ï¼ˆoutcome, decision ã‚’ä½¿ç”¨ï¼‰

---

## ğŸ”œ æ¬¡å›ã®ã‚¹ãƒ†ãƒƒãƒ—

Step 4 ã¨ Step 6 ã®å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ï¼š

1. **Step 7**: Handler ã®æ›´æ–°ï¼ˆCLI ã® HelloHandler ã‚’æ–°ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¤‰æ›ï¼‰
2. **Step 8**: çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆend-to-end ã®å‹•ä½œç¢ºèªï¼‰
3. **Step 9**: CLI example ã®å‹•ä½œç¢ºèª
4. **Step 10**: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆADR-0005 ã‚’ "Accepted" ã«ã€learning è¨˜éŒ²æ›´æ–°ï¼‰

---

## ğŸ“Š å®Ÿè£…ã®é€²æ—

**Phase 4-1 å…¨ä½“ã®é€²æ—: 50%**

- âœ… è¨­è¨ˆã¨ãƒ—ãƒ©ãƒ³ä½œæˆï¼ˆå®Œäº†ï¼‰
- âœ… Step 1: TaskLease Interface æ‹¡å¼µï¼ˆå®Œäº†ï¼‰
- âœ… Step 2: Handler Trait å¤‰æ›´ï¼ˆå®Œäº†ï¼‰
- âœ… Step 3: Decider çµ±åˆï¼ˆå®Œäº†ï¼‰
- âœ… Step 5: get_task_record() å®Ÿè£…ï¼ˆå®Œäº†ï¼‰
- â³ **Step 4: Worker Loop Flowï¼ˆæ¬¡ã®ã‚¿ã‚¹ã‚¯ï¼‰**
- â³ Step 6: complete() å®Ÿè£…
- â³ Step 7-10: Handleræ›´æ–°ã€ãƒ†ã‚¹ãƒˆã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

**æ¨å®šæ®‹ã‚Šæ™‚é–“: 6-8 æ™‚é–“**
- Step 4: 2-3 æ™‚é–“ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰
- Step 6: 2-3 æ™‚é–“ï¼ˆå­¦ç¿’ã‚¿ã‚¹ã‚¯ï¼‰
- Step 7-10: 2 æ™‚é–“ï¼ˆä»•ä¸Šã’ï¼‰

---

## ğŸ’¡ ä»Šæ—¥å­¦ã‚“ã ã“ã¨ï¼ˆã¾ã¨ã‚ï¼‰

### è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

1. **ç´”ç²‹é–¢æ•°ã¨å‰¯ä½œç”¨ã®åˆ†é›¢**:
   - Decider: ç´”ç²‹é–¢æ•°ï¼ˆstate + observation â†’ decisionï¼‰
   - Worker/TaskLease: å‰¯ä½œç”¨ï¼ˆdecision ã‚’å®Ÿè¡Œï¼‰

2. **è²¬å‹™ã®æ˜ç¢ºåŒ–**:
   - Handler: å®Ÿè¡Œ + è¦³æ¸¬
   - Decider: åˆ¤æ–­
   - Worker: ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
   - TaskLease: çŠ¶æ…‹é·ç§»ã®å®Ÿè¡Œ

3. **ã‚¤ãƒ³ãƒ•ãƒ©ã‚¨ãƒ©ãƒ¼ã¨ãƒ“ã‚¸ãƒã‚¹ã‚¨ãƒ©ãƒ¼ã®åŒºåˆ¥**:
   - `Err(WeaverError)`: ã‚¤ãƒ³ãƒ•ãƒ©å•é¡Œ
   - `Ok(Outcome::Failure)`: ãƒ“ã‚¸ãƒã‚¹å•é¡Œ

### Rust ã®ãƒ‘ã‚¿ãƒ¼ãƒ³

1. **Trait ã®æ‹¡å¼µ**: Send + Sync ã®è¿½åŠ ãŒ tokio::spawn ã«å¿…è¦
2. **Arc å…±æœ‰**: ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãª Decider ã¯ Arc ã§å®‰å…¨ã«å…±æœ‰å¯èƒ½
3. **å‹å®‰å…¨æ€§**: Result<Outcome, WeaverError> ã§æ˜ç¢ºãªå¥‘ç´„

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å­¦ã³

1. **æ®µéšçš„ãªå®Ÿè£…**: Steps 1-3 ã§æº–å‚™ã€Step 4-6 ã§æ ¸å¿ƒå®Ÿè£…
2. **å­¦ç¿’ã‚¿ã‚¹ã‚¯ã®è¨­è¨ˆ**: TODO(human) ã§æ˜ç¢ºãªã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
3. **backward compatibility**: deprecated ã§ç§»è¡ŒæœŸé–“ã‚’è¨­ã‘ã‚‹

---

## ğŸ¤” ç–‘å•ã¨ä»Šå¾Œã®æ¤œè¨äº‹é …

### ç–‘å•1: SUCCESS æ™‚ã® AttemptRecord

ç¾åœ¨ã€SUCCESS æ™‚ã¯ `ack()` ã‚’å‘¼ã¶ãŒã€ack() å†…ã§ AttemptRecord ã‚’ä½œæˆã—ã¦ã„ã‚‹ã€‚

**ç¢ºèªäº‹é …:**
- ack() ãŒ AttemptRecord ã‚’ä½œæˆã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
- complete() ã§ã‚‚åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨

**è§£æ±ºæ¸ˆã¿**: ack() ã¯ AttemptRecord ã‚’ä½œæˆã—ã¦ã„ã‚‹ï¼ˆmemory.rs:375-383ï¼‰

### ç–‘å•2: Infrastructure Error ã®æ‰±ã„

Worker ãŒ `Err(handler_error)` ã‚’ `Outcome::failure()` ã«å¤‰æ›ã—ã¦ã„ã‚‹ãŒã€ã“ã‚Œã§è‰¯ã„ã‹ï¼Ÿ

**æ¤œè¨:**
- Option A: Outcome::failure ã«å¤‰æ›ï¼ˆç¾åœ¨ã®è¨­è¨ˆï¼‰â†’ ãƒªãƒˆãƒ©ã‚¤å¯èƒ½
- Option B: å³åº§ã« mark_dead â†’ ãƒªãƒˆãƒ©ã‚¤ä¸å¯

**çµè«–**: Option A ã‚’æ¡ç”¨ï¼ˆresilience ã‚’å„ªå…ˆï¼‰

### ä»Šå¾Œã®æ¤œè¨: SUCCESS æ™‚ã® Decider å‘¼ã³å‡ºã—

ADR-0005 ã§ã¯ã€ŒSUCCESS æ™‚ã¯ Decider ã‚’å‘¼ã°ãªã„ã€ã¨ã—ã¦ã„ã‚‹ãŒã€å°†æ¥çš„ã«ã€ŒSUCCESS ã ãŒæœ¬å½“ã«æˆåŠŸã‹ï¼Ÿã€ã®æ¤œè¨¼ãŒå¿…è¦ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚

**Future work**: æˆåŠŸçµæœã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯

---

## ğŸ“ Step 6.5: Unit Tests for complete() (Claudeå®Ÿè£…)

**ã‚¿ã‚¹ã‚¯**: `complete()` ãƒ¡ã‚½ãƒƒãƒ‰ã®å˜ä½“ãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…

**å®Ÿè£…ã—ãŸãƒ†ã‚¹ãƒˆ** (`crates/weaver-core/src/queue/memory.rs`):

1. **test_complete_with_retry_decision**: Retry decision ãƒ‘ã‚¹ã®ãƒ†ã‚¹ãƒˆ
   - Outcome::Failure â†’ Decision::Retry â†’ TaskState::RetryScheduled
   - AttemptRecord ã¨ DecisionRecord ãŒä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
   - scheduled queue ã«ã‚¿ã‚¹ã‚¯ãŒè¿½åŠ ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

2. **test_complete_with_mark_dead_decision**: MarkDead decision ãƒ‘ã‚¹ã®ãƒ†ã‚¹ãƒˆ
   - Outcome::Failure â†’ Decision::MarkDead â†’ TaskState::Dead
   - AttemptRecord ã¨ DecisionRecord ãŒä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

3. **test_complete_creates_both_records**: ä¸¡æ–¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒä½œæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
   - AttemptRecord ã« observation (Artifact) ãŒä¿å­˜ã•ã‚Œã‚‹
   - DecisionRecord ã« context ãŒä¿å­˜ã•ã‚Œã‚‹

### ğŸ› é‡å¤§ãªãƒã‚°ã®ç™ºè¦‹ã¨ä¿®æ­£

#### å•é¡Œ

ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚ã«ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:

```
thread 'queue::memory::tests::test_complete_with_retry_decision' panicked at:
called `Option::unwrap()` on a `None` value
```

ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ `state.records.get(&task_id)` ãŒ None ã‚’è¿”ã—ã¦ã„ãŸã€‚

#### æ ¹æœ¬åŸå› 

**TaskId ã®äºŒé‡ç®¡ç†å•é¡Œ**:

1. ãƒ†ã‚¹ãƒˆã§ `TaskEnvelope::new(TaskId::new(2001), ...)` ã‚’ä½œæˆ
2. `queue.enqueue(task)` å‘¼ã³å‡ºã—
3. **enqueue() å†…ã§æ–°ã—ã„ TaskId ã‚’å‰²ã‚Šå½“ã¦** (`state.allocate_task_id()` â†’ TaskId(1))
4. `state.records.insert(task_id, record)` ã§ **TaskId(1) ã‚’ã‚­ãƒ¼**ã¨ã—ã¦ä½¿ç”¨
5. ã—ã‹ã— **record.envelope ã«ã¯å…ƒã® TaskId(2001) ãŒåŸ‹ã‚è¾¼ã¾ã‚ŒãŸã¾ã¾**
6. ãƒ†ã‚¹ãƒˆã§ `let task_id = lease.envelope().task_id()` â†’ **TaskId(2001) ã‚’å–å¾—**
7. `state.records.get(&task_id)` â†’ TaskId(2001) ã§æ¤œç´¢ â†’ **è¦‹ã¤ã‹ã‚‰ãªã„ï¼**

#### ãƒ•ãƒ­ãƒ¼ã®è©³ç´°

```rust
// 1. ãƒ†ã‚¹ãƒˆå†…
let task = TaskEnvelope::new(TaskId::new(2001), ...);

// 2. enqueue() å†… (memory.rs:202-210)
async fn enqueue(&self, envelope: TaskEnvelope) -> Result<(), WeaverError> {
    let mut state = self.state.lock().await;
    let task_id = state.allocate_task_id();  // â† TaskId(1) ã‚’å‰²ã‚Šå½“ã¦
    let record = TaskRecord::new(envelope, max_attempts);  // â† envelope ã¯ TaskId(2001) ã®ã¾ã¾
    state.records.insert(task_id, record);  // â† ã‚­ãƒ¼ã¯ TaskId(1)
    //                      ^^^^ ã“ã“ãŒå•é¡Œã®æ ¸å¿ƒ
}

// 3. lease() å†… (memory.rs:226-237)
if let Some(task_id) = state.ready.pop_front()  // â† TaskId(1)
    && let Some(record) = state.records.get_mut(&task_id)
{
    let lease = InMemoryLease {
        task_id,  // â† TaskId(1) (æ­£ã—ã„ã‚­ãƒ¼)
        envelope: record.envelope.clone(),  // â† envelope.task_id() ã¯ TaskId(2001)
        ...
    };
}

// 4. ãƒ†ã‚¹ãƒˆå†…
let task_id = lease.envelope().task_id();  // â† TaskId(2001) ã‚’å–å¾—
state.records.get(&task_id).unwrap();  // â† TaskId(2001) ã§æ¤œç´¢ â†’ None!
```

#### ä¿®æ­£æ–¹æ³•

`lease.envelope().task_id()` ã‚’ä½¿ã‚ãšã€**AttemptRecord ã‹ã‚‰æ­£ã—ã„ task_id ã‚’å–å¾—**:

```rust
// ä¿®æ­£å‰ï¼ˆãƒã‚°ã‚ã‚Šï¼‰
let lease = queue.lease().await.unwrap();
let task_id = lease.envelope().task_id();  // â† é–“é•ã„: envelope ã® TaskId ã‚’ä½¿ç”¨
lease.complete(outcome, decision).await.unwrap();
let state = queue.state.lock().await;
let record = state.records.get(&task_id).unwrap();  // â† None ã§ panic

// ä¿®æ­£å¾Œï¼ˆæ­£ã—ã„ï¼‰
let lease = queue.lease().await.unwrap();
lease.complete(outcome, decision).await.unwrap();

// AttemptRecord ã‹ã‚‰æ­£ã—ã„ task_id ã‚’å–å¾—
let attempts = queue.get_all_attempts().await;
let task_id = attempts[0].task_id;  // â† ã“ã‚Œã¯ InMemoryLease.task_id ã¨åŒã˜

// ã“ã‚Œã§æ­£ã—ã„ã‚­ãƒ¼ã§æ¤œç´¢ã§ãã‚‹
let state = queue.state.lock().await;
let record = state.records.get(&task_id).unwrap();  // â† æˆåŠŸï¼
```

### ğŸ“ å­¦ã‚“ã ã“ã¨

#### 1. ID ç®¡ç†ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

**å•é¡Œ**: TaskEnvelope ã«åŸ‹ã‚è¾¼ã¾ã‚ŒãŸ TaskId ã¨ã€å®Ÿéš›ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ TaskId ãŒç•°ãªã‚‹

**æ•™è¨“**:
- **ID ã®å‰²ã‚Šå½“ã¦å ´æ‰€ã‚’ä¸€å…ƒåŒ–**: enqueue() ã§æ–°ã—ã„ TaskId ã‚’å‰²ã‚Šå½“ã¦ã‚‹ãªã‚‰ã€envelope ã® task_id ã‚‚æ›´æ–°ã™ã¹ã
- **ID ã®çœŸã®ã‚½ãƒ¼ã‚¹ã‚’æ˜ç¢ºã«**: records ã®ã‚­ãƒ¼ãŒçœŸå®Ÿã€envelope å†…ã® ID ã¯ã€Œå…ƒã® IDã€ã«éããªã„
- **ãƒ†ã‚¹ãƒˆã§ã¯ã€ŒçœŸã®ã‚½ãƒ¼ã‚¹ã€ã‹ã‚‰å–å¾—**: AttemptRecord.task_id ã¯ InMemoryLease.task_id ã¨åŒã˜ï¼ˆæ­£ã—ã„ã‚­ãƒ¼ï¼‰

#### 2. Rust ã®æ‰€æœ‰æ¨©ã¨å‚ç…§ã®ä½¿ã„åˆ†ã‘

```rust
// InMemoryLease ã®å®šç¾©
struct InMemoryLease {
    task_id: TaskId,           // â† æ­£ã—ã„ã‚­ãƒ¼ï¼ˆrecords ã® keyï¼‰
    envelope: TaskEnvelope,    // â† envelope.task_id() ã¯ç•°ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
    ...
}

// complete() ã®å®Ÿè£…
async fn complete(self: Box<Self>, ...) {
    // self.task_id ã‚’ä½¿ã† â† ã“ã‚ŒãŒæ­£ã—ã„
    state.records.get_mut(&self.task_id)

    // self.envelope.task_id() ã‚’ä½¿ã†ã¨é–“é•ã„
}
```

#### 3. ãƒ†ã‚¹ãƒˆã§ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã®ç¢ºèª

- **Given**: TaskEnvelope ã‚’ä½œæˆ â†’ enqueue()
- **When**: lease() â†’ complete()
- **Then**: çŠ¶æ…‹ã‚’ç¢ºèª

ã“ã®ã¨ãã€**Given ã§ä½œã£ãŸ ID ãŒãã®ã¾ã¾ä½¿ãˆã‚‹ã¨ä»®å®šã—ã¦ã¯ã„ã‘ãªã„**ã€‚enqueue() ã§å¤‰æ›ã•ã‚Œã‚‹å¯èƒ½æ€§ã‚’è€ƒæ…®ã€‚

#### 4. ãƒ‡ãƒãƒƒã‚°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

1. **ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª­ã‚€**: `unwrap() on None value` â†’ ã©ã“ã§ None ã«ãªã£ãŸã‹ï¼Ÿ
2. **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’è¿½ã†**: TaskId ãŒã©ã“ã§å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€ã©ã“ã§ä½¿ã‚ã‚Œã‚‹ã‹
3. **æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆã‚’å‚è€ƒã«ã™ã‚‹**: ä»–ã®ãƒ†ã‚¹ãƒˆãŒã©ã†ã‚„ã£ã¦ task_id ã‚’å–å¾—ã—ã¦ã„ã‚‹ã‹ç¢ºèª
4. **å‹ã®æ„å‘³ã‚’è€ƒãˆã‚‹**: envelope.task_id() vs lease.task_id ã®é•ã„

### ãƒ†ã‚¹ãƒˆçµæœ

```bash
$ cargo test -p weaver-core test_complete
running 3 tests
test queue::memory::tests::test_complete_creates_both_records ... ok
test queue::memory::tests::test_complete_with_retry_decision ... ok
test queue::memory::tests::test_complete_with_mark_dead_decision ... ok

test result: ok. 3 passed; 0 failed; 0 ignored
```

```bash
$ cargo test -p weaver-core
running 28 tests
test result: ok. 28 passed; 0 failed; 0 ignored
```

âœ… **å…¨ãƒ†ã‚¹ãƒˆãƒ‘ã‚¹ï¼**

---

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

- âœ… Step 1-3: TaskLease æ‹¡å¼µã€Handler æ›´æ–°ã€Decider çµ±åˆ
- âœ… Step 4: Worker Loop Flow (ãƒ¦ãƒ¼ã‚¶ãƒ¼å®Ÿè£…)
- âœ… Step 5: get_task_record() å®Ÿè£…
- âœ… Step 6: complete() å®Ÿè£… (ãƒ¦ãƒ¼ã‚¶ãƒ¼å®Ÿè£…)
- âœ… **Step 6.5: complete() ã®å˜ä½“ãƒ†ã‚¹ãƒˆ (Claudeå®Ÿè£…)**
- ğŸ”œ **Step 7: Handler æ›´æ–°** (ãƒ¦ãƒ¼ã‚¶ãƒ¼å­¦ç¿’ã‚¿ã‚¹ã‚¯)
- ğŸ”œ Step 8: çµ±åˆãƒ†ã‚¹ãƒˆ (ãƒ¦ãƒ¼ã‚¶ãƒ¼å­¦ç¿’ã‚¿ã‚¹ã‚¯)
- ğŸ”œ Step 9: ä¾‹ã®æ›´æ–°ã¨æ¤œè¨¼
- ğŸ”œ Step 10: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

---

**æ¬¡å›ã®è¨˜éŒ²**: Step 7 å®Ÿè£…æ™‚ã«æ›´æ–°
